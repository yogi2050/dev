<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/computer_logical_organization/quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>Quick Reference Guide for Computer Logical Organization</title>
<link rel="shortcut icon" href="../favicon.png" type="image/x-icon" />
<meta name="Keywords" content="Computer, Logical, Organization, Tutorials, Learning, Beginners, Signals, Number System, Number System Conversion, Concept of coding, Codes Conversion, Complements, Binary Arithmetic, Octal Arithmetic, Hexadecimal Arithmetic, Boolean Algebra, Logic Gates, Combinational Circuits , Sequential circuits , Registers , Counters, Memory Devices,  CPU Architecture, Addressing Modes , I/O Architecture." />
<meta name="description" content="Quick Reference Guide for Computer Logical Organization - Learning digital computer organization in simple and easy steps starting from Signals, Number System, Number System Conversion, Concept of coding, Codes Conversion, Complements, Binary Arithmetic, Octal Arithmetic, Hexadecimal Arithmetic, Boolean Algebra, Logic Gates, Combinational Circuits , Sequential circuits , Registers , Counters, Memory Devices,  CPU Architecture, Addressing Modes , I/O Architecture." />
<base  />
<link rel="stylesheet" type="text/css" href="../scripts/style.css" />
<link rel="stylesheet" type="text/css" href="../scripts/prettify.css" />
<script type="text/javascript" src="../scripts/prettify.js"></script>
<style media="screen" type="text/css">
/* Computer Logical Organization */
#topmenu a:link {text-decoration:none;color:#fff !important;background-color:transparent;font-weight:bold;}
#topmenu a:visited {text-decoration:none;color:#fff !important;background-color:transparent;font-weight:bold;}
#topmenu a:hover {text-decoration:none;color:#629DCE !important;background-color:transparent;font-weight:bold;}
#header{ 
background:#3A8BCE !important;
}
#topmenu
{
background-color:#07579c !important;
}
#leftcol ul.menu li.heading 
{
background:#3A8BCE !important;
border:1px solid #07579c !important;
}
#leftcol, #middlecol, #rightcol {min-height:1050px; padding:0px;}
</style>
<script src="../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
</script>
</head>
<body onload="prettyPrint()">
<div id="header">
<div class="wrapper">
<h1 class="logo"><a href="../index-2.html">Tutorials Point - Simply Easy Learning</a></h1>
<div id="search">
<form method="get" id="searchform" name="searchform" action="http://www.google.com/search" target="_blank">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com"/>
<input type="text" name="as_q" id="s" value="Search this site..." onfocus="if (this.value == 'Search this site...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search this site...';}"/>
<input value="FORID:11" name="cof" type="hidden"/>
<input type="hidden" name="ie" value="ISO-8859-1" />
<input class="submit btn" type="image" src="../images/icon-search.png" alt="Go"/>
</form>
</div>
</div>
</div>
<div id="topmenu">
<div class="wrapper">
<div id="left">
<a href="../index-2.html" target="_top">HOME </a>
<a href="../java/index.html" target="_top">JAVA </a>
<a href="../php/index.html" target="_top">PHP </a>
<a href="../python/index.html" target="_top">Python </a>
<a href="../ruby/index.html" target="_top">Ruby </a>
<a href="../perl/index.html" target="_top">Perl </a>
<a href="../html/index.html" target="_top">HTML </a>
<a href="../css/index.html" target="_top">CSS </a>
<a href="../javascript/index.html" target="_top">Javascript </a>
<a href="../mysql/index.html" target="_top">MySQL </a>
<a href="../cplusplus/index.html" target="_top">C++ </a>
<a href="../unix/index.html" target="_top">UNIX </a>
<a href="../more.html" target="_top">MORE...</a>
</div>
<div id="right">
<a href="../references.html" target="_top">REFERENCES</a> |
<a href="../forums/index.html" target="_top">FORUM</a> |
<a href="../about/index.html" target="_top">ABOUT</a> |
<a href="../about/contact_us.html" target="_top">CONTACT</a>
</div>
</div>
</div>
<div class="wrapper">
<div id="leftcol">
<div class="mini-logo">
<img src="../images/computer-oragnization-mini-logo.png" alt="Computer Logical Organization Tutorial" />
</div>
<ul class="menu">
<li class="heading">Computer Organization</li>
<li><a class="left" target="_top" href="index.html">Home</a></li>
<li><a class="left" target="_top" href="overview.html">Overview</a></li>
<li><a class="left" target="_top" href="digital_number_system.html">Digital Number System</a></li>
<li><a class="left" target="_top" href="number_system_conversion.html">Number System Conversion</a></li>
<li><a class="left" target="_top" href="binary_codes.html">Binary Codes</a></li>
<li><a class="left" target="_top" href="codes_conversion.html">Codes Conversion</a></li>
<li><a class="left" target="_top" href="complement_arithmetic.html">Complement Arithmetic</a></li>
<li><a class="left" target="_top" href="binary_arithmetic.html">Binary Arithmetic</a></li>
<li><a class="left" target="_top" href="octal_arithmetic.html">Octal Arithmetic</a></li>
<li><a class="left" target="_top" href="hexadecimal_arithmetic.html">Hexadecimal Arithmetic</a></li>
<li><a class="left" target="_top" href="boolean_algebra.html">Boolean Algebra</a></li>
<li><a class="left" target="_top" href="logic_gates.html">Logic Gates</a></li>
<li><a class="left" target="_top" href="combinational_circuits.html">Combinational Circuits</a></li>
<li><a class="left" target="_top" href="sequential_circuits.html">Sequential Circuits</a></li>
<li><a class="left" target="_top" href="digital_registers.html">Digital Registers</a></li>
<li><a class="left" target="_top" href="digital_counters.html">Digital Counters</a></li>
<li><a class="left" target="_top" href="memory_devices.html">Memory Devices</a></li>
<li><a class="left" target="_top" href="cpu_architecture.html">CPU Architecture</a></li>
</ul>
<ul class="menu">
<li class="heading">Useful Resources</li>
<li><a class="left" target="_top" href="quick_guide.html"><b>Quick Reference Guide</b></a></li>
<li><a class="left" target="_top" href="useful_resources.html">Useful Resources</a></li>
</ul>
<ul class="menu">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</div><!-- leftcol -->
<div id="middlecol">
<!-- PRINTING STARTS HERE -->
<div class="content">
<h1>Quick Reference Guide</h1>
<div class="topgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="cpu_architecture.html">Previous Page</a>
</div>
<div class="nxt-btn">
<a href="useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
<p>In the modern world of electronic, the term <b>Digital</b> is generally associated with a computer because the term <b>Digital</b> is derived from the way computers perform operation, by counting digits. For many year, the application of digital electronics was only in the computer system. But now-a-days, the digital electronic is used in many other application. Following are some of the examples in whihc <b>Digital electronics</b> is heavyily used.</p>
<ul class="list">
<li><p>Industrial process control</p></li>
<li><p>Military system</p></li>
<li><p>Television</p></li>
<li><p>Communication system</p></li>
<li><p>Medical equipment</p></li>
<li><p>Radar</p></li>
<li><p>navigation</p></li>
</ul>
<h2>Signal</h2>
<p><b>Signal</b> can be defined as a physical quantity, which contains some information. It is a function of one or more than one independent variables. Signal are of two types.</p>
<ul class="list">
<li><p>Analog Signal</p></li>
<li><p>Digital Signal</p></li>
</ul>
<h2>Analog Signal</h2>
<p>An <b>analog signal</b> is defined as the signal having continuous values. Analog signal can have infinite number of different values. In real world sceanario, most of the things observed in nature are analog. Examples of the analog signals are following.</p>
<ul class="list">
<li><p>Temperature</p></li>
<li><p>Pressure</p></li>
<li><p>Distance</p></li>
<li><p>Sound</p></li>
<li><p>Voltage</p></li>
<li><p>Current</p></li>
<li><p>Power</p></li>
</ul>
<h2>Graphical representation of Analog Signal (Temperature)</h2>
<img src="images/analog_signal.html" alt="Analog Signal" />
<p>The circuits that process the analog signals are called as analog circuits or system. Examples of the analog system are following.</p>
<ul class="list">
<li><p>Filter</p></li>
<li><p>Amplifiers</p></li>
<li><p>Television receiver</p></li>
<li><p>motor speed controller</p></li>
</ul>
<h3>Disadvantage of the Analog Systems</h3>
<ul class="list">
<li><p>Less accuracy</p></li>
<li><p>Less versatslity</p></li>
<li><p>More noise effect</p></li>
<li><p>More distortion</p></li>
<li><p>More effect of weather</p></li> 
</ul>
<h2>Digital Signal</h2>
<p>A <b>digital signal</b> is defined as the signal which has only a finite number of distinct values. Digital signal are not continuous signal. In the digital electronic calculator, the input is given with the help of switches. This input is converted into electrical signal which having two discrete values or levels. One of these may be called low level and another is called high level. The signal will always be one of the two levels. This type of signal is called digital signal. Examples of the digital signal are following.</p>
<ul class="list">
<li><p>Binary Signal</p></li>
<li><p>Octal Signal</p></li>
<li><p>Hexadecimal Signal</p></li>
</ul>
<h2>Graphical representation of the Digital Signal (Binary)</h2>
<img src="images/digital_signal.html" alt="Digital Signal" />
<p>The circuit that process that digital signal are called digital system or digital circuit. Examples of the digital system are following.</p>
<ul class="list">
<li><p>Registers</p></li>
<li><p>Flip-flop</p></li>
<li><p>Counters</p></li>
<li><p>Microprocessors</p></li>
</ul>
<h1>Digital Number System</h1>
<p>A digital system can understand positional number system only where there are only a few symbols called digits and these
symbols represent different values depending on the position they occupy in the number.</p>
A value of each digit in a number can be determined using
<ul class="list">
<li><p>The digit</p></li>
<li><p>The position of the digit in the number</p></li>
<li><p>The base of the number system (where base is defined as the total number of digits available in the number system).</p></li>
</ul>
<h2>Decimal Number System</h2>
<p>The number system that we use in our day-to-day life is the decimal number system. Decimal number system has base 10 as it uses 10 digits from 0 to 9. In decimal number system, the successive
positions to the left of the decimal point represent units, tens, hundreds, thousands and so on.</p>
<p>Each position represents a specific power of the base (10). For example, the decimal number 1234 consists of the digit 4 in the units position, 3 in the tens position, 2 in the
hundreds position, and 1 in the thousands position, and its value can be written as</p>
<p>(1x1000)+ (2x100)+ (3x10)+ (4xl)</p>
<p>(1x10<sup>3</sup>)+ (2x10<sup>2</sup>)+ (3x10<sup>1</sup>)+ (4xl0<sup>0</sup>)</p>
<p>1000 + 200 + 30 + 1</p>
<p>1234</p>
<p>As a computer programmer or an IT professional, you should understand the following number systems which are frequently used in computers.</p>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th>Number System &amp; Description</th></tr>
<tr><td>1</td><td><b>Binary Number System</b><br />Base 2. Digits used: 0, 1</td></tr>
<tr><td>2</td><td><b>Octal Number System</b><br />Base 8. Digits used: 0 to 7</td></tr>
<tr><td>4</td><td><b>Hexa Decimal Number System</b><br />Base 16. Digits used: 0 to 9, Letters used: A- F</td></tr>
</table>
<h2>Binary Number System</h2>
<p>Binary Number: 10101<sub>2</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>10101<sub>2</sub></td><td>((1 x 2<sup>4</sup>) + (0 x 2<sup>3</sup>) + (1 x 2<sup>2</sup>) + (0 x 2<sup>1</sup>) + (1 x 2<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>10101<sub>2</sub></td><td>(16 + 0 + 4 + 0 + 1)<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>10101<sub>2</sub></td><td>21<sub>10</sub></td></tr>
</table>
<h2>Octal Number System</h2>
<p>Octal Number: 12570<sub>8</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Octal Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>12570<sub>8</sub></td><td>((1 x 8<sup>4</sup>) + (2 x 8<sup>3</sup>) + (5 x 8<sup>2</sup>) + (7 x 8<sup>1</sup>) + (0 x 8<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>12570<sub>8</sub></td><td>(4096 + 1024 + 320 + 56 + 0)<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>12570<sub>8</sub></td><td>5496<sub>10</sub></td></tr>
</table>
<h2>Hexadecimal Number System</h2>
<p>Hexadecimal Number: 19FDE<sub>16</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>19FDE<sub>16</sub></td><td>((1 x 16<sup>4</sup>) + (9 x 16<sup>3</sup>) + (F x 16<sup>2</sup>) + (D x 16<sup>1</sup>) + (E x 16<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>19FDE<sub>16</sub></td><td>((1 x 16<sup>4</sup>) + (9 x 16<sup>3</sup>) + (15 x 16<sup>2</sup>) + (13 x 16<sup>1</sup>) + (14 x 16<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>19FDE<sub>16</sub></td><td>(65536+ 36864 + 3840 + 208 + 14)<sub>10</sub></td></tr>
<tr><td>Step 4</td><td>19FDE<sub>16</sub></td><td>106462<sub>10</sub></td></tr>
</table>
<h1>Number System Conversion</h1>
<p>There are many methods or techniques which can be used to convert numbers from one base to another. We'll demonstrate here the following</p>
<ul class="list">
<li><p>Decimal to Other Base System</p></li>
<li><p>Other Base System to Decimal</p></li>
<li><p>Other Base System to Non-Decimal</p></li>
<li><p>Shortcut method - Binary to Octal</p></li>
<li><p>Shortcut method - Octal to Binary</p></li>
<li><p>Shortcut method - Binary to Hexadecimal</p></li>
<li><p>Shortcut method - Hexadecimal to Binary</p></li>
</ul>
<h2>Base 10 to Base N Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Divide the decimal number to be converted by the value of the new base.</p></li>
<li><p><b>Step 2</b> - Get the remainder from Step 1 as the rightmost digit (least significant digit) of new base number.</p></li>
<li><p><b>Step 3</b> - Divide the quotient of the previous divide by the new base.</p></li>
<li><p><b>Step 4</b> - Record the remainder from Step 3 as the next digit (to the left) of the new base number.</p></li>
</ul>
<p>Repeat Steps 3 and 4, getting remainders from right to left, until the quotient becomes zero in Step 3.</p>
<p>The last remainder thus obtained will be the most significant digit (MSD) of the new base number.</p>
<h3>Example</h3>
<p>Decimal Number: 29<sub>10</sub></p>
<p>Calculating Binary Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Operation</th><th>Result </th><th>Remainder</th></tr>
<tr><td>Step 1</td><td>29 / 2</td><td>14</td><td>1</td></tr>
<tr><td>Step 2</td><td>14 / 2</td><td>7</td><td>0</td></tr>
<tr><td>Step 3</td><td>7 / 2</td><td>3</td><td>1</td></tr>
<tr><td>Step 4</td><td>3 / 2</td><td>1</td><td>1</td></tr>
<tr><td>Step 5</td><td>1 / 2</td><td>0</td><td>1</td></tr>
</table>
<p>As mentioned in Steps 2 and 4, the remainders have to be arranged in the reverse order so that the first remainder becomes the least significant digit (LSD) and the last remainder becomes the most significant digit (MSD).</p>
<p>Decimal Number: 29<sub>10</sub> = Binary Number: 11101<sub>2</sub>.
<h2>Base N to Base 10 Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Determine the column (positional) value of each digit (this depends on the position of the digit and the base of the number system).</p></li>
<li><p><b>Step 2</b> - Multiply the obtained column values (in Step 1) by the digits in the corresponding columns.</p></li>
<li><p><b>Step 3</b> - Sum the products calculated in Step 2. The total is the equivalent value in decimal.</p></li>
</ul>
<h3>Example</h3>
<p>Binary Number: 11101<sub>2</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>11101<sub>2</sub></td><td>((1 x 2<sup>4</sup>) + (1 x 2<sup>3</sup>) + (1 x 2<sup>2</sup>) + (0 x 2<sup>1</sup>) + (1 x 2<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>11101<sub>2</sub></td><td>(16 + 8 + 4 + 0 + 1)<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>11101<sub>2</sub></td><td>29<sub>10</sub></td></tr>
</table>
<p>Binary Number: 11101<sub>2</sub> = Decimal Number: 29<sub>10</sub>
<h2>Base N to Base M Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Convert the original number to a decimal number (base 10).</p></li>
<li><p><b>Step 2</b> - Convert the decimal number so obtained to the new base number.</p></li>
</ul>
<h3>Example</h3>
<p>Octal Number: 25<sub>8</sub></p>
<p>Calculating Binary Equivalent:</p>
<h3>Step 1: Convert to Decimal</h3>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Octal Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>27<sub>8</sub></td><td>((2 x 8<sup>1</sup>) + (5 x 8<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>27<sub>8</sub></td><td>(16 + 5 )<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>27<sub>8</sub></td><td>21<sub>10</sub></td></tr>
</table>
<p>Octal Number: 25<sub>8</sub> = Decimal Number: 21<sub>10</sub>
<h3>Step 2: Convert Decimal to Binary</h3>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Operation</th><th>Result </th><th>Remainder</th></tr>
<tr><td>Step 1</td><td>21 / 2</td><td>10</td><td>1</td></tr>
<tr><td>Step 2</td><td>10 / 2</td><td>5</td><td>0</td></tr>
<tr><td>Step 3</td><td>5 / 2</td><td>2</td><td>1</td></tr>
<tr><td>Step 4</td><td>2 / 2</td><td>1</td><td>0</td></tr>
<tr><td>Step 5</td><td>1 / 2</td><td>0</td><td>1</td></tr>
</table>
<p>Decimal Number: 21<sub>10</sub> = Binary Number: 10101<sub>2</sub>
<p>Octal Number: 25<sub>8</sub> = Binary Number: 10101<sub>2</sub>
<h2>Base 2 to Base 8 Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Divide the binary digits into groups of three (starting from the right).</p></li>
<li><p><b>Step 2</b> - Convert each group of three binary digits to one octal digit.</p></li>
</ul>
<h3>Example</h3>
<p>Binary Number: 10101<sub>2</sub></p>
<p>Calculating Octal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Octal Number</th></tr>
<tr><td>Step 1</td><td>10101<sub>2</sub></td><td>010 101</td></tr>
<tr><td>Step 2</td><td>10101<sub>2</sub></td><td>2<sub>8</sub> 5<sub>8</sub> 3<sub>8</sub></td></tr>
<tr><td>Step 3</td><td>10101<sub>2</sub></td><td>25<sub>8</sub></td></tr>
</table>
<p>Binary Number: 10101<sub>2</sub> = Octal Number: 25<sub>8</sub>
<h2>Base 8 to Base 2 Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Convert each octal digit to a 3 digit binary number (the octal digits may be treated as decimal for this conversion).</p></li>
<li><p><b>Step 2</b> - Combine all the resulting binary groups (of 3 digits each) into a single binary number.</p></li>
</ul>
<h3>Example</h3>
<p>Octal Number: 25<sub>8</sub></p>
<p>Calculating Binary Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Octal Number</th><th>Binary Number</th></tr>
<tr><td>Step 1</td><td>25<sub>8</sub></td><td>2<sub>10</sub> 5<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>25<sub>8</sub></td><td>010<sub>2</sub> 101<sub>2</sub></td></tr>
<tr><td>Step 3</td><td>25<sub>8</sub></td><td>010101<sub>2</sub></td></tr>
</table>
<p>Octal Number: 25<sub>8</sub> = Binary Number: 10101<sub>2</sub>
<h2>Base 2 to Base 16 Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Divide the binary digits into groups of four (starting from the right).</p></li>
<li><p><b>Step 2</b> - Convert each group of four binary digits to one hexadecimal symbol.</p></li>
</ul>
<h3>Example</h3>
<p>Binary Number: 10101<sub>2</sub></p>
<p>Calculating hexadecimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Hexadecimal Number</th></tr>
<tr><td>Step 1</td><td>10101<sub>2</sub></td><td>0001 0101</td></tr>
<tr><td>Step 2</td><td>10101<sub>2</sub></td><td>1<sub>10</sub> 5<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>10101<sub>2</sub></td><td>15<sub>10</sub></td></tr>
<tr><td>Step 5</td><td>10101<sub>2</sub></td><td>F<sub>16</sub></td></tr>
</table>
<p>Binary Number: 10101<sub>2</sub> = Hexadecimal Number: F<sub>16</sub>
<h2>Base 16 to Base 2 Conversion</h2>
<p>Steps</p>
<ul class="list">
<li><p><b>Step 1</b> - Convert each hexadecimal digit to a 4 digit binary number (the hexadecimal digits may be treated as decimal for this conversion).</p></li>
<li><p><b>Step 2</b> - Combine all the resulting binary groups (of 4 digits each) into a single binary number.</p></li>
</ul>
<h3>Example</h3>
<p>Hexadecimal Number: F<sub>16</sub></p>
<p>Calculating Binary Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Hexadecimal Number</th><th>Binary Number</th></tr>
<tr><td>Step 1</td><td>F<sub>16</sub></td><td>15<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>F<sub>16</sub></td><td>1<sub>10</sub> 5<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>F<sub>16</sub></td><td>0001<sub>2</sub> 0101<sub>2</sub></td></tr>
<tr><td>Step 4</td><td>F<sub>16</sub></td><td>00010101<sub>2</sub></td></tr>
</table>
<p>Hexadecimal Number: F<sub>16</sub> = Binary Number: 10101<sub>2</sub>
<h1>Binary Codes</h1>
<p>In the coding, when numbers, letters or words are represented by a specific group of symbols, it is said that the number, letter or word is being encoded. The group of symbols is called as a code. The digital data is represented, stored and transmitted as group of binary bits. This group is also called as <b>binary code</b>. The binary code is represented by the number as well as alphanumeric letter.</p>
<h2>Advantages of Binary Code</h2>
<p>Following is the list of advantages that binary code offers.</p>
<ul class="list">
<li><p>Binary codes are suitable for the computer applications.</p></li>
<li><p>Binary codes are suitable for the digital communications.</p></li>
<li><p>Binary codes make the analysis and designing of digital circuits if we use the binary codes.</p></li>
<li><p>Since only 0 & 1 are being used, implementation becomes easy.</p></li>
</ul>
<h2>Classification of binary codes</h2>
<p>The codes are broadly categorised into following four categories.</p>
<ul class="list">
<li><p>Weighted Codes</p></li>
<li><p>Non-Weighted Codes</p></li>
<li><p>Binary Coded Decimal Code</p></li>
<li><p>Alphanumeric Codes</p></li>
<li><p>Error Detecting Codes</p></li>
<li><p>Error Correcting Codes</p></li>
</ul>
<h2>Weighted Codes</h2>
<p>Weighted binary codes are those binary codes which obey the positional weight principle. Each position of the number represents a specific weight. Several system of the codes are used to express the decimal digits 0 through 9. In these codes each decimal digit is represented by a group of four bits.</p>
<img src="images/weighted_code.html" alt="Weighted Code" />
<h2>Non-Weighted Codes</h2>
<p>In this type of binary codes, the positional weights are not assigned. The example of non-weighted codes are Excess-3 code and Gray code.</p>
<h3>Excess-3 code</h3>
<p>The Excess-3 code is also called as XS-3 code. It is non-weighted code used to express decimal numbers. The Excess-3 code words are derived from the 8421 BCD code words adding (0011)2  or (3)10 to each code word in 8421. The excess-3 codes are obtained as follows</p>
<img src="images/excess3_code.html" alt="Excess-3 code" />
<p>Example</p>
<img src="images/bcd_excess3_code.html" alt="BCD to Excess-3 code" />
<h3>Gray Code</h3>
<p>It is the another non-weighted code and it is not arithmetic codes. That means there are no specific weights assigned to the bit position. It has a very special feature that has only one bit will change, each time the decimal number is incremented as shown in fig.As only one bit changes at a time, the gray code is called as a unit distance code. The gray code is a cyclic code. Gray code can not be used for arithmetic operation.</p> 
<img src="images/gray_code.html" alt="Gray code" />
<h3>Application of Gray code</h3>
<ul class="list">
<li><p>Gray code is popularly used in the shaft position encoders.</p></li>
<li><p>A shaft position encoder produces a code word which represents the angular position of the shaft.</p></li>
</ul>
<h2>Binary Coded Decimal (BCD) code</h2>
<p>In this code each decimal digit is represented by a 4-bit binary number. BCD is a way to express each of the decimal digits with a binary code. In the BCD, with four bits we can represent sixteen numbers (0000 to 1111). But in BCD code only first ten of these are used (0000 to 1001). The remaining six code combinations i.e. 1010 to 1111 are invalid in BCD.</p>
<img src="images/bcd_code.html" alt="BCD code" />
<h3>Advantages of BCD Codes</h3>
<ul class="list">
<li><p>It is very similar to decimal system.</p></li>
<li><p>We need to remember binary equivalent of decimal numbers 0 to 9 only.</p></li>
</ul>
<h3>Disadvantages of BCD Codes</h3>
<ul class="list">
<li><p>The addition and subtraction of BCD have different rules.</p></li>
<li><p>The BCD arithmetic is little more complicated.</p></li>
<li><p>BCD need more number of bits than binary to represent the decimal number. So BCD is less efficient than binary.</p></li>
</ul>
<h2>Alphanumeric codes</h2>
<p>A binary digit or bit can represent only two symbols as it has only two states '0' or '1'. But this is not enough for communication between two computers because there we need many more symbols for communication. These symbols are required to represent 26 alphabets with capital and small letters , numbers from 0 to 9 , punctuation marks and other symbols.</p>
<p>The alphanumeric codes are the codes that represent numbers and alphabetic characters. Mostly such codes also represent other characters such as symbol and various instruction necessary for conveying information. An alphanumeric code should at least represent 10 digits and 26 letters of alphabet i.e. total 36 items. The following three alphanumeric codes are very commonly used for the data representation.</p>
<ul class="list">
<li><p>American Standard Code for Information Interchange (ASCII). </p></li>
<li><p>Extended Binary Coded Decimal Interchange Code (EBCDIC).</p></li>
<li><p>Five bit Baudot Code.</p></li>
</ul>
<p>ASCII code is a 7-bit code whereas EBCDIC is an 8-bit code. ASCII code is more commonly used world wide while EBCDIC is used primarily in large IBM computers. </p>
<h1>Complement Arithmetic</h1>
<p>Complements are used in the digital computers in order to simplify the subtraction operation and for the logical manipulations. For each radix-r system (radix r represent base of number system) there are two types of complements</p>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th>Complement</th><th>Description</th></tr>
<tr><td>1</td><td>Radix Complement</td><td>The radix complement is referred to as the r's complement</td></tr> 
<tr><td>1</td><td>Diminished Radix Complement</td><td>The diminished radix complement is referred to as the (r-1)'s complement</td></tr> 
</table>
<h2>Binary system complements</h2>
<p>As the binary system has base r = 2. So the two types of complements for the binary system are 2's complement and 1's complement.<p>
<h2>1's complement</h2>
<p>The 1's complement of a number is found by changing all 1's to 0's and all 0's to 1's. This is called as taking complement or 1's complement. Example of 1's Complement is as follows.</p>
<img src="images/1s_complement.html" alt="1's complement"/>
<h2>2's complement</h2>
<p>The 2's complement of binary number is obtained by adding 1 to the Least Significant Bit (LSB) of 1's complement of the number.</p>
<p>2's complement = 1's complement + 1</p>
<p>Example of 2's Complement is as follows.</p>
<img src="images/2s_complement.html" alt="2's complement"/>
<h1>Binary Arithmetic</h1>
<p>Binary arithmetic is essential part of all the digital computers and many other digital system.</p>
<h2>Binary Addition</h2>
<p>It is a key for binary subtraction, multiplication, division. There four rules of the binary addition.</p>
<img src="images/addition_table.html" alt="Addition Table" />                                 
<p>In fourth case, a binary addition is creating a sum of (1+1=10) i.e. 0 is write in the given column and a carry of 1 over to the next column.</p>
<h3>Example - Addition</h3>
<img src="images/addition_example.html" alt="Addition Example" />   
<h2>Binary Subtraction</h2>
<p><b>Subtraction and Borrow</b>, these two words will be used very frequently for the binary subtraction.There four rules of the binary substration.There four rules of the binary substraction.</p>
<img src="images/substraction_table.html" alt="Substraction Table" />   
<h3>Example - Substraction</h3>
<img src="images/substraction_example.html" alt="Substraction Example" />   
<h2>Binary Multiplication</h2>
<p>Binary multiplication is similar to decimal multiplication. It is simpler than decimal multiplication because only 0s and 1s are involved.There four rules of the binary multiplication.</p>
<img src="images/multiplication_table.html" alt="Multiplication Table" />   
<h3>Example - Multiplication</h3>
<img src="images/multiplication_example.html" alt="Multiplication Example" />   
<h2>Binary Division</h2>
<p>Binary division is similar to decimal division. It is called as the long division procedure.</p>
<h3>Example - Division</h3>
<img src="images/division_example.html" alt="Division Example" /> 
<h1>Octal Arithmetic</h1>
<h2>Octal Number System</h2>
<p>Following are the characteristics of an octal number system.</p>
<ul class="list">
<li><p>Uses eight digits, 0,1,2,3,4,5,6,7.</p></li>
<li><p>Also called base 8 number system</p></li>
<li><p>Each position in a octal number represents a 0 power of the base (8). Example 8<sup>0</sup></p></li>
<li><p>Last position in a octal number represents a x power of the base (8). Example 8<sup>x</sup> where x represents the last position - 1.</li>
</ul>
<h3>Example</h3>
<p>Octal Number: 12570<sub>8</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Octal Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>12570<sub>8</sub></td><td>((1 x 8<sup>4</sup>) + (2 x 8<sup>3</sup>) + (5 x 8<sup>2</sup>) + (7 x 8<sup>1</sup>) + (0 x 8<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>12570<sub>8</sub></td><td>(4096 + 1024 + 320 + 56 + 0)<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>12570<sub>8</sub></td><td>5496<sub>10</sub></td></tr>
</table>
<p><b>Note: </b>12570<sub>8</sub> is normally written as 12570.</p>
<h2>Octal Addition</h2>
<p>Following octal addition table will help you greatly to handle Octal addition.</p>
<img src="images/octal_addition_table.html" alt="Octal Addition Table" />    
<p>To use this table, simply follow the directions used in this example: Add: 6<sub>8</sub> and 5<sub>8</sub>.Locate 6 in the A column then locate the 5 in the B column. The point in sum area where these two columns intersect is the sum of two number.</p>
<p>6<sub>8</sub> + 5<sub>8</sub> = 13<sub>8</sub>.
<h3>Example - Addition</h3>
<img src="images/octal_addition_example.html" alt="Octal Addition Example" />  
<h2>Octal Substraction</h2>
The subtraction of octal numbers follows the same rules as the subtraction of numbers in any other number system. The only variation is in borrowed number. In the decimal system, you borrow a group of 10<sub>10</sub>. In the binary system, you borrow a group of 2<sub>10</sub>. In the octal system you borrow a group of 8<sub>10</sub>.
<h3>Example - Substraction</h3>
<img src="images/octal_substraction_example.html" alt="Octal Substraction Example" />  
<h1>Hexadecimal Arithmetic</h1>
<h2>Hexadecimal Number System</h2>
<p>Following are the characteristics of a hexadecimal number system.</p>
<ul class="list">
<li><p>Uses 10 digits and 6 letters, 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F.</p></li>
<li><p>Letters represents numbers starting from 10. A = 10. B = 11, C = 12, D = 13, E = 14, F = 15.</p></li>
<li><p>Also called base 16 number system</p></li>
<li><p>Each position in a hexadecimal number represents a 0 power of the base (16). Example 16<sup>0</sup></p></li>
<li><p>Last position in a hexadecimal number represents a x power of the base (16). Example 16<sup>x</sup> where x represents the last position - 1.</li>
</ul>
<h3>Example</h3>
<p>Hexadecimal Number: 19FDE<sub>16</sub></p>
<p>Calculating Decimal Equivalent:</p>
<table class="src">
<tr><th style="width:20%;">Step</th><th>Binary Number</th><th>Decimal Number</th></tr>
<tr><td>Step 1</td><td>19FDE<sub>16</sub></td><td>((1 x 16<sup>4</sup>) + (9 x 16<sup>3</sup>) + (F x 16<sup>2</sup>) + (D x 16<sup>1</sup>) + (E x 16<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 2</td><td>19FDE<sub>16</sub></td><td>((1 x 16<sup>4</sup>) + (9 x 16<sup>3</sup>) + (15 x 16<sup>2</sup>) + (13 x 16<sup>1</sup>) + (14 x 16<sup>0</sup>))<sub>10</sub></td></tr>
<tr><td>Step 3</td><td>19FDE<sub>16</sub></td><td>(65536+ 36864 + 3840 + 208 + 14)<sub>10</sub></td></tr>
<tr><td>Step 4</td><td>19FDE<sub>16</sub></td><td>106462<sub>10</sub></td></tr>
</table>
<p><b>Note: </b>19FDE<sub>16</sub> is normally written as 19FDE.</p>
<h2>Hexadecimal Addition</h2>
<p>Following hexadecimal addition table will help you greatly to handle Hexadecimal addition.</p>
<img src="images/hexadecimal_addition_table.html" alt="Hexadecimal Addition Table" />    
<p>To use this table, simply follow the directions used in this example: Add: A<sub>16</sub> and 5<sub>16</sub>.Locate A in the X column then locate the 5 in the Y column. The point in sum area where these two columns intersect is the sum of two number.</p>
<p>A<sub>16</sub> + 5<sub>16</sub> = F<sub>16</sub>.
<h3>Example - Addition</h3>
<img src="images/hexadecimal_addition_example.html" alt="Hexadecimal Addition Example" />  
<h2>Hexadecimal Substraction</h2>
The subtraction of octal numbers follows the same rules as the subtraction of numbers in any other number system. The only variation is in borrowed number. In the decimal system, you borrow a group of 10<sub>10</sub>. In the binary system, you borrow a group of 2<sub>10</sub>. In the hexadecimal system you borrow a group of 16<sub>10</sub>.
<h3>Example - Substraction</h3>
<img src="images/hexadecmal_substraction_example.html" alt="hexdecimal Substraction Example" />  
<h1>Boolean Algebra</h1>
<p>Boolean Algebra is used to analyze and simplify the digital (logic) circuits. It uses only the binary numbers i.e. 0 and 1. It is also called as <b>Binary Algebra</b> or <b>logical Algebra</b>. Boolean algebra was invented by <b>George Boole</b> in 1854.</p>
<h2>Rule in boolean algebra</h2>
<p>Following are the important rules used in boolean algrebra.</p>
<ul class="list">
<li><p>Variable used can have only two values. Binary 1 for HIGH and Binary 0 for LOW.</p></li>
<li><p>Complement of a variable is represented by a overbar (-). Thus complement of variable B is represented as <img src="images/b_bar.html" alt="B Bar" class="inline"/>. Thus if B = 0 then <img src="images/b_bar.html" alt="B Bar" class="inline"/> = 1 and B = 1 then <img src="images/b_bar.html" alt="B Bar" class="inline"/> = 0.</p></li>
<li><p>ORing of the variables is represented by a plus (+) sign between them. For example ORing of A, B, C is represented as A + B + C.</p></li>
<li><p>Logical ANDing of the two or more variable is represented by writing a dot between them such as A.B.C. Sometime the dot may be omitted like ABC.</p></li>
</ul>
<h2>Boolean Laws</h2>
<p>There are six types of Boolean Laws.</p>
<h3>Commutative law</h3>
<p>Any binary operation which satisfies the following expression is referred to as commutative operation</p>
<img src="images/commutative.html" alt="Commutative Law" />
<p>Commutative law states that changing the sequence of the variables does not have any effect on the output of a logic circuit.</p>
<h3>Associative law</h3>
<p>This law states that the order in which the logic operation are performed is irrelevant as their effect is the same.</p>
<img src="images/associative.html" alt="Associative Law" />
<h3>Distributive law</h3>
<p>Distributive law states the following condition.</p>
<img src="images/distributive.html" alt="Distributive Law" />
<h3>AND law</h3>
<p>These laws use the AND operation. Therefore they are called as <b>AND</b> laws.
<img src="images/and.html" alt="AND Law" />
<h3>OR law</h3>
<p>These laws use the OR operation. Therefore they are called as <b>OR</b> laws.
<img src="images/or.html" alt="OR Law" />
<h3>INVERSION law</h3>
<p>This law uses the NOT operation. The inversion law states that double inversion of a variable result in the original variable itself.</p>
<img src="images/not.html" alt="NOT Law" />
<h2>Important Boolean Theroems</h2>
<p>Following are few important boolean theroems.</p>
<table class="src">
<tr><th width="35%">Boolean function/theroems</th><th>Description</th></tr>
<tr><td><a href="boolean_function.html" title="Boolean Functions">Boolean Functions</a></td><td>Boolean Functions and Expressions, K-Map and NAND Gates realization</td></tr>
<tr><td><a href="demorgan_theroems.html" title="De Morgan's Theroms">De Morgan's Theorems</a></td><td>De Morgan's Theorem 1 and Theorem 2</td></tr>
</table>
<h1>Logic Gates</h1>
<p>Logic gates are the basic building blocks of any digital system. It is an electronic circuit having one or more than one input and only one output. The relationship between the input and the output is based on a <b>certain logic</b>. Based on this logic gates are named as AND gate, OR gate, NOT gate etc. </p>
<h2>AND Gate</h2>
<p>A circuit which performs an AND operation is shown in figure. It has n input (n >= 2) and one output.</p>
<img src="images/and1.html" alt="AND gate" />
<h3>Logic diagram</h3>
<img src="images/and_logic.html" alt="AND Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/and_truthtable.html" alt="AND Truth Table" />
<h2>OR Gate</h2>
<p>A circuit which performs an OR operation is shown in figure. It has n input (n >= 2) and one output.</p>
<img src="images/or1.html" alt="OR gate" />
<h3>Logic diagram</h3>
<img src="images/or_logic.html" alt="OR Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/or_truthtable.html" alt="OR Truth Table" />
<h2>NOT Gate</h2>
<p>NOT gate is also known as <b>Inverter</b>. It has one input A and one output Y.</p>
<img src="images/not1.html" alt="NOT gate" />
<h3>Logic diagram</h3>
<img src="images/not_logic.html" alt="NOT Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/not_truthtable.html" alt="NOT Truth Table" />
<h2>NAND Gate</h2>
<p> A NOT-AND operation is known as NAND operation. It has n input (n >= 2) and one output. </p>
<img src="images/nand.html" alt="NAND gate" />
<h3>Logic diagram</h3>
<img src="images/nand_logic.html" alt="NAND Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/nand_truthtable.html" alt="NAND Truth Table" />
<h2>NOR Gate</h2>
<p> A NOT-OR operation is known as NOR operation. It has n input (n >= 2) and one output. </p>
<img src="images/nor.html" alt="NOR gate" />
<h3>Logic diagram</h3>
<img src="images/nor_logic.html" alt="NOR Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/nor_truthtable.html" alt="NOR Truth Table" />
<h2>XOR Gate</h2>
<p>XOR or Ex-OR gate is a special type of gate. It can be used in the half adder, full adder and subtractor. The exclusive-OR gate is abbreviated as EX-OR gate or sometime as X-OR gate. It has n input (n >= 2) and one output. </p>
<img src="images/xor.html" alt="XOR gate" />
<h3>Logic diagram</h3>
<img src="images/xor_logic.html" alt="XOR Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/xor_truthtable.html" alt="XOR Truth Table" />
<h2>XNOR Gate</h2>
<p> XNOR gate is a special type of gate. It can be used in the half adder, full adder and subtractor. The exclusive-NOR gate is abbreviated as EX-NOR gate or sometime as X-NOR gate. It has n input (n >= 2) and one output.</p>
<img src="images/xnor.html" alt="XNOR gate" />
<h3>Logic diagram</h3>
<img src="images/xnor_logic.html" alt="XNOR Logical Diagram" />
<h3>Truth Table</h3>
<img src="images/xnor_truthtable.html" alt="XNOR Truth Table" />
<h1>Combinational Circuits</h1>
<p>Combinational circuit is circuit in which we combine the different gates in the circuit for example encoder, decoder, multiplexer and demultiplexer. Some of the characteristics of combinational circuits are following. </p>
<ul class="list">
<li><p>The output of combinational circuit at any instant of time, depends only on the levels present at input terminals.</p></li>
<li><p>The combinational circuit do not use any memory. The previous state of input does not have any effect on the present state of the circuit.</p></li>
<li><p>A combinational circuit can have a n number of inputs and m number of outputs.</p></li>
</ul>
<h3>Block diagram</h3>
<img src="images/combinational_circuit_blockdiagram.html" alt="Block Diagram of combinational circuit" />
<p>We're going to elaborate few important combinational circuits as follows.</p>
<h2>Half Adder</h2>
<p>Half adder is a combinational logic circuit with two input and two output. The half adder circuit is designed to add two single bit binary number A and B. It is the basic building block for addition of two <b>single</b> bit numbers. This circuit has two outputs <b>carry</b> and <b>sum</b>.</p>
<h3>Block diagram</h3>
<img src="images/halfadder_blockdiagram.html" alt="Block Diagram of Half Adder" />
<h3>Truth Table</h3>
<img src="images/halfadder_truthtable.html" alt="Half Adder Truth Table" />
<h3>Circuit Diagram</h3>
<img src="images/halfadder_circuitdiagram.html" alt="Half Adder Circuit Diagram" />                                                        
<h2>Full Adder</h2>
<p>Full adder is developed to overcome the drawback of Half Adder circuit. It can add two one-bit numbers A and B, and carry c. The full adder is a three input and two output combinational circuit.</p>
<h3>Block diagram</h3>
<img src="images/fulladder_blockdiagram.html" alt="Block Diagram of Full Adder" />
<h3>Truth Table</h3>
<img src="images/fulladder_truthtable.html" alt="Full Adder Truth Table" />
<h3>Circuit Diagram</h3>
<img src="images/fulladder_circuitdiagram.html" alt="Full Adder Circuit Diagram" />  
<h2>N-Bit Parallel Adder</h2>
<p>The Full Adder is capable of adding only two single digit binary number along with a carry input. But in practical we need to add binary numbers which are much longer than just one bit. To add two n-bit binary numbers we need to use the n-bit parallel adder. It uses a number of full adders in cascade. The carry output of the previous full adder is connected to carry input of the next full adder.</p>
<h3>4 Bit Parallel Adder</h3>
<p>In the block diagram, A<sub>0</sub> and B<sub>0</sub> represent the LSB of the four bit words A and B. Hence Full Adder-0 is the lowest stage. Hence its C<sub>in</sub> has been permanently made 0. The rest of the connection are exactly same as those of n-bit parallel adder is shown in fig. The four bit parallel adder is a very common logic circuit.</p>
<h3>Block diagram</h3>
<img src="images/fourbitadder_blockdiagram.html" alt="Block Diagram of Four bit Adder" />
<h2>N-Bit Parallel Substractor</h2>
<p>The subtraction can be carried out by taking the 1's or 2's complement of the number to be subtracted. For example we can perform the subtraction (A-B) by adding either 1's or 2's complement of B to A. That means we can use a binary adder to perform the binary subtraction.</p>
<h3>4 Bit Parallel Subtractor</h3>
<p>The number to be subtracted (B) is first passed through inverters to obtain its 1's complement. The 4-bit adder then adds A and 2's complement of B to produce the subtraction. S<sub>3</sub> S<sub>2</sub> S<sub>1</sub> S<sub>0</sub> represent the result of binary subtraction (A-B) and carry output C<sub>out</sub> represents the polarity of the result. If A > B then Cout =0 and the result of binary form (A-B) then C<sub>out</sub> = 1 and the result is in the 2's complement form. 
<h3>Block diagram</h3>
<img src="images/fourbitsubstractor_blockdiagram.html" alt="Block Diagram of Four bit Substrator" />
<h2>Half Subtractors</h2>
<p>Half subtractor is a combination circuit with two inputs and two outputs (difference and borrow). It produces the difference between the two binary bits at the input and also produces a output (Borrow) to indicate if a 1 has been borrowed. In the subtraction (A-B), A is called as Minuend bit and B is called as Subtrahend bit.</p>
<h3>Truth Table</h3>
<img src="images/halfsubstrator_truthtable.html" alt="Half Substractor Truth Table" />
<h3>Circuit Diagram</h3>
<img src="images/halfsubstrator_circuitdiagram.html" alt="Half Substractor Circuit Diagram" />  
<h2>Full Subtractors</h2>
<p>The disadvantage of a half subtractor is overcome by full subtractor. The full subtractor is a combinational circuit with three inputs A,B,C and two output D and C'. A is the minuend, B is subtrahend, C is the borrow produced by the previous stage, D is the difference output and C' is the borrow output.</p>
<h3>Truth Table</h3>
<img src="images/fullsubstrator_truthtable.html" alt="Full Substractor Truth Table" />
<h3>Circuit Diagram</h3>
<img src="images/fullsubstrator_circuitdiagram.html" alt="Full Substractor Circuit Diagram" />  
<h2>Multiplexers</h2>
<p>Multiplexer is a special type of combinational circuit. There are n-data inputs, one output and m select inputs with 2m = n. It is a digital circuit which selects one of the n data inputs and routes it to the output. The selection of one of the n inputs is done by the selected inputs. Depending on the digital code applied at the selected inputs, one out of n data sources is selected and transmitted to the single output Y. E is called the strobe or enable input which is useful for the cascading. It is generally an active low terminal, that means it will perform the required operation when it is low.</p>
<h3>Block diagram</h3>
<img src="images/n_onemultiplexer_blockdiagram.html" alt="Block Diagram of n:1 Multiplexer" />
<p>Multiplexers come in multiple variations</p>
<ul class="list">
<li><p>2 : 1 multiplexer</p></li>
<li><p>4 : 1 multiplexer</p></li>
<li><p>16 : 1 multiplexer</p></li>
<li><p>32 : 1 multiplexer</p></li>
</ul>
<h3>Block Diagram</h3>
<img src="images/two_onemultiplexer_blockdiagram.html" alt="2:1 Multiplexer Block Diagram" />
<h3>Truth Table</h3>
<img src="images/two_onemultiplexer_truthtable.html" alt="2:1 Multiplexer Truth Table" />
<h2>Demultiplexers</h2>
<p>A demultiplexer perform the reverse operation of a multiplexer i.e. it receives one input and distributes it over several outputs. It has only one input, n outputs, m select input. At a time only one output line is selected by the select lines and the input is transmitted to the selected output line. A de-multiplexer is equivalent to a single pole multiple way switch as shown in fig.
<p>Demultiplexers come in multiple variations</p>
<ul class="list">
<li><p>1 : 2 demultiplexer</p></li>
<li><p>1 : 4 demultiplexer</p></li>
<li><p>1 : 16 demultiplexer</p></li>
<li><p>1 : 32 demultiplexer</p></li>
</ul>
<h3>Block diagram</h3>
<img src="images/one_twodemultiplexer_blockdiagram.html" alt="Block Diagram of 1:2 Demultiplexer" />
<h3>Truth Table</h3>
<img src="images/one_twodemultiplexer_truthtable.html" alt="1:2 Demultiplexer Truth Table" />
<h2>Decoder</h2>
<p>A decoder is a combinational circuit. It has n input and to a maximum m =  2n outputs. Decoder is identical to a demultiplexer without any data input. It performs operation which are exactly opposite to those of an encoder.</p>
<h3>Block diagram</h3>
<img src="images/decoder_blockdiagram.html" alt="Block Diagram of Decoder" />
<p>Examples of Decoders are following.</p>
<ul class="list">
<li><p>Code converters</p></li>
<li><p>BCD to seven segment decoders</p></li>
<li><p>Nixie tube decoders</p></li>
<li><p>Relay actuator</p></li>
</ul>
<h2>2 to 4 Line Decoder</h2>
<p>The block diagram of 2 to 4 line decoder is shown in the fig. A and B are the two inputs where D through D are the four outputs.The truth table which explains the operation of the decoder. It shows that each output is 1 for only a specific combination of inputs.</p>
<h3>Block diagram</h3>
<img src="images/two_fourdecoder_blockdiagram.html" alt="Block Diagram of 2 to 4 Decoder" />
<h3>Truth Table</h3>
<img src="images/two_fourdecoder_truthtable.html" alt="Truth Table of 2 to 4 Decoder" />
<h3>Logic Circuit</h3>
<img src="images/two_fourdecoder_logiccircuit.html" alt="Logic Circuit of 2 to 4 Decoder" />
<h2>Encoder</h2>
<p>Encoder is a combinational circuit which is designed to perform the inverse operation of the decoder. An encoder has n number of input lines and m number of output lines. An encoder produces an m bit binary code corresponding to the digital input number. The encoder accepts an n input digital word and converts it into an m bit another digital word.</p>
<h3>Block diagram</h3>
<img src="images/encoder_blockdiagram.html" alt="Block Diagram of encoder" />
<p>Examples of Encoders are following.</p>
<ul class="list">
<li><p>Priority encoders</p></li>
<li><p>Decimal to BCD encoder</p></li>
<li><p>Octal to binary encoder</p></li>
<li><p>Hexadecimal to binary encoder</p></li>
</ul>
<h2>Priority Encoder</h2>
<p>This is a special type of encoder. Priority are given to the input lines. If two or more input line are 1 at the same time, then the input line with highest priority will be considered. There are four input D<sub>0</sub>, D<sub>1</sub>, D<sub>2</sub>, D<sub>3</sub> and two output Y<sub>0</sub>, Y<sub>1</sub>. Out of the four input D<sub>3</sub> has the highest priority and D<sub>0</sub> has the lowest priority. That means if D<sub>3</sub> = 1 then Y<sub>1</sub> Y<sub>1</sub> = 11 irrespective of the other inputs. Similarly if D<sub>3</sub> = 0 and D<sub>2</sub> = 1 then Y<sub>1</sub> Y<sub>0</sub> = 10 irrespective of the other inputs.
<h3>Block diagram</h3>
<img src="images/priorityencoder_blockdiagram.html" alt="Block Diagram of Priority Encoder" />
<h3>Truth Table</h3>
<img src="images/priorityencoder_truthtable.html" alt="Truth Table of Priority Encoder" />
<h3>Logic Circuit</h3>
<img src="images/priorityencoder_logiccircuit.html" alt="Logic Circuit of Priority Encoder" />
<h1>Sequential Circuits</h1>
<p>The combinational circuit do not use any memory. Hence the previous state of input does not have any effect on the present state of the circuit. But sequential circuit has memory so output can vary based on input. This type of circuits use previous input , output ,clock and a memory element.</p>
<h3>Block diagram</h3>
<img src="images/sequential_circuit_blockdiagram.html" alt="Block Diagram of sequential circuit" />
<h2>Flip Flop</h2>
<p>Flip flop is a sequential circuit which generally samples its inputs and changes its outputs only at a particular instants of time and not continuously. Flip flop is said to be edge sensitive or edge triggered rather than being level triggered like latches.</p>
<h2>S-R Flip Flop</h2>
<p> It is basically S-R latch using NAND gates with an additional <b>enable</b> input. It is also called as level triggered SR-FF. For this circuit in output will take place if and only if the enable input (E) is made active. In short this circuit will operate as an S-R latch if E= 1 but there is no change in the output if E = 0.</p>
<h3>Block Diagram</h3>
<img src="images/srflipflop_blockdiagram.html" alt="Block Diagram of SR Flip Flop" />
<h3>Circuit Diagram</h3>
<img src="images/srflipflop_circuitdiagram.html" alt="Circuit Diagram of SR Flip Flop" />
<h3>Truth Table</h3>
<img src="images/srflipflop_truthtable.html" alt="Truth Table of SR Flip Flop" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:20%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>S = R = 0 : No change</b></td>
<td><ul class="list">
<li><p>If S = R = 0 then output of NAND gates 3 and 4 are forced to become 1.</p></li>
<li><p>Hence R' and S' both will be equal to 1. Since S' and R' are the input of the basic S-R latch using NAND gates, there will be no change in the state of outputs.</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>S = 0, R = 1, E = 1</b></td>
<td><ul class="list">
<li><p>Since S = 0, output of NAND-3 i.e. R' = 1 and E = 1 the output of NAND-4 i.e. S' = 0.</p></li>
<li><p>Hence Q<sub>n+1</sub> = 0 and Q<sub>n+1</sub> bar = 1. This is reset condition.</p></li>
</ul>
</td></tr>
<tr><td>3</td><td><b>S = 1, R = 0, E = 1</b></td>
<td><ul class="list">
<li><p>Output of NAND-3 i.e. R' = 0 and output of NAND-4 i.e. S' = 1.</p></li>
<li><p>Hence output of S-R NAND latch is Q<sub>n+1</sub> = 1 and Q<sub>n+1</sub> bar = 0. This is the reset condition.</p></li>
</ul>
</td></tr>
<tr><td>4</td><td><b>S = 1, R = 1, E = 1</b></td>
<td><ul class="list">
<li><p>As S = 1, R = 1 and E = 1, the output of NAND gates 3 and 4 both are 0 i.e. S' = R' = 0.</p></li>
<li><p>Hence the <b>Race</b> condition will occur in the basic NAND latch.</p></li>
</ul>
</td></tr>
</table>
<h2>Master Slave JK Flip Flop</h2>
<p>Master slave JK FF is a cascade of two S-R FF with feedback from the output of second to input of first. Master is a positive level triggered. But due to the presence of the inverter in the clock line, the slave will respond to the negative level. Hence when the clock = 1 (positive level) the master is active and the slave is inactive. Whereas when clock = 0 (low level) the slave is active and master is inactive.</p>
<h3>Circuit Diagram</h3>
<img src="images/jkflipflop_circuitdiagram.html" alt="Circuit Diagram of J-K Flip Flop" />
<h3>Truth Table</h3>
<img src="images/jkflipflop_truthtable.html" alt="Truth Table of J-K Flip Flop" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:20%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>J = K = 0 (No change)</b></td>
<td><ul class="list">
<li><p>When clock = 0, the slave becomes active and master is inactive. But since the S and R inputs have not changed, the slave outputs will also remain unchanged. Therefore outputs will not change if J = K =0.</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>J = 0 and K = 1 (Reset)</b></td>
<td><ul class="list">
<li><p>Clock = 1: Master active, slave inactive. Therefore outputs of the master become Q<sub>1</sub> = 0 and Q<sub>1</sub> bar = 1. That means S = 0 and R =1.</p></li>
<li><p>Clock = 0: Slave active, master inactive Therefore outputs of the slave become Q = 0 and Q bar = 1.</p></li>
<li><p>Again clock = 1:  Master active, slave inactive. Therefore even with the changed outputs Q = 0 and Q bar = 1 fed back to master, its outputs will Q1 = 0 and Q1 bar = 1. That means S = 0 and R = 1.</p></li>
<li><p>Hence with clock = 0 and slave becoming active the outputs of slave will remain Q = 0 and Q bar = 1. Thus we get a stable output from the Master slave.</p></li>
</ul>
</td></tr>
<tr><td>3</td><td><b>J = 1 and K = 0 (Set)</b></td>
<td><ul class="list">
<li><p>Clock = 1: Master active, slave inactive. Therefore outputs of the master become Q<sub>1</sub> = 1 and Q<sub>1</sub> bar = 0. That means S = 1 and R =0.</p></li>
<li><p>Clock = 0: Slave active, master inactive Therefore outputs of the slave become Q = 1 and Q bar = 0.</p></li>
<li><p>Again clock = 1: then it can be shown that the outputs of the slave are stabilized to Q = 1 and Q bar = 0.</p></li>
</ul>
</td></tr>
<tr><td>4</td><td><b>J = K = 1 (Toggle)</b></td>
<td><ul class="list">
<li><p>Clock = 1: Master active, slave inactive. Outputs of master will toggle. So S and R also will be inverted.</p></li>
<li><p>Clock = 0: Slave active, master inactive. Outputs of slave will toggle.</p></li>
<li><p>These changed output are returned back to the master inputs. But since clock = 0, the master is still inactive. So it does not respond to these changed outputs. This avoids the multiple toggling which leads to the race around condition. The master slave flip flop will avoid the race around condition.</p></li>
</ul>
</td></tr>
</table>
<h2>Deplay Flip Flop / D Flip Flop</h2>
<p>Delay Flip Flop or D Flip Flop is the simple gated S-R latch with a NAND inverter connected between S and R inputs. It has only one input. The input data is appear at the output after some time. Due to this data delay between i/p and o/p, it is called delay flip flop. S and R will be the complements of each other due to NAND inverter. Hence S = R = 0 or S = R = 1,these input condition will never apper.This problem is avoid by SR = 00 and SR = 1 conditions. </p>
<h3>Block Diagram</h3>
<img src="images/dflipflop_blockdiagram.html" alt="Block Diagram of D Flip Flop" />
<h3>Circuit Diagram</h3>
<img src="images/dflipflop_circuitdiagram.html" alt="Circuit Diagram of D Flip Flop" />
<h3>Truth Table</h3>
<img src="images/dflipflop_truthtable.html" alt="Truth Table of D Flip Flop" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:20%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>E = 0</b></td>
<td><ul class="list">
<li><p>Latch is disabled. Hence is no change in output.</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>E = 1 and D = 0</b></td>
<td><ul class="list">
<li><p>If E = 1 and D = 0 then S = 0 and R = 1. Hence irrespective of the present state, the next state is Q<sub>n+1</sub> = 0 and Q<sub>n+1</sub> bar = 1. This is the reset condition.</p></li>
</ul>
</td></tr>
<tr><td>3</td><td><b>E = 1 and D = 1</b></td>
<td><ul class="list">
<li><p>if E = 1 and D = 1, then S = 1 and R = 0. This will set the latch and Q<sub>n+1</sub> = 1 and Q<sub>n+1</sub> bar = 0 irrespective of the present state.</p></li>
</ul>
</td></tr>
</table>
<h2>Toggle Flip Flop / T Flip Flop</h2>
<p>Toggle flip flop is basically a JK flip flop with J and K terminals permanently connected together. It has only input denoted by <b>T</b> is shown in the Symbol Diagram. The symbol for positive edge triggered T flip flop is shown in the Block Diagram.</p>
<h3>Symbol Diagram</h3>
<img src="images/tflipflop_symboldiagram.html" alt="Symbol Diagram of T Flip Flop" />
<h3>Block Diagram</h3>
<img src="images/tflipflop_blockdiagram.html" alt="Block Diagram of T Flip Flop" />
<h3>Truth Table</h3>
<img src="images/tflipflop_truthtable.html" alt="Truth Table of T Flip Flop" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:20%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>T = 0, J = K = 0</b></td>
<td><ul class="list">
<li><p>The output Q and Q bar won't change</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>T = 1 ,J = K = 1</b></td>
<td><ul class="list">
<li><p>output will toggle corresponding to every leading edge of clock signal.</p></li>
</ul>
</td></tr>
</table>
<h1>Digital Registers</h1>
<p>Flip-flop is a 1 bit memory cell which can be used for storing the digital data. To increase the storage capacity in terms of number of bits, we have to use a group of flip-flop. Such a group of flip-flop is known as a <b>Register</b>. The <b>n-bit register</b> will consist of <b>n</b> number of flip-flop and it is capable of storing an <b>n-bit</b> word.</p>
<p>The binary data in a register can be moved within the register from one flip-flop to another. The registers that allow such data transfers are called as <b>shift registers</b>. There are four mode of opearation of a shift register.</p> 
<ul class="list">
<li><p>Serial Input Serial Output</p></li>
<li><p>Serial Input Parallel Output</p></li>
<li><p>Parallel Input Serial Output</p></li>
<li><p>Parallel Input Parallel Output</p></li>
</ul>
<h2>Serial Input Serial Output</h2>
<p>Let all the flip-flop be initially in the reset condition i.e. Q<sub>3</sub> = Q<sub>2</sub> = Q<sub>1</sub> = Q<sub>0</sub> = 0. If we entry of a four bit binary number 1 1 1 1 into the register. When this is to be done, this number should be applied to <b>D<sub>in</sub></b> bit by with the LSB bit applied first. The D input of FF-3 i.e. D<sub>3</sub> is connected to serial data input <b>D<sub>in</sub></b>. Output of FF-3 i.e. Q<sub>3</sub> is connected to the input of the next flip-flop i.e. D<sub>2</sub> and so on.</p>
<h3>Block Diagram</h3>
<img src="images/siso_blockdiagram.html" alt="Block Diagram of SISO Register" />
<h3>Operation</h3>
<p>Before application of clock signal let Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub> = 0000 and apply LSB bit of the number to be entered to D<sub>in</sub>. So D<sub>in</sub>=D<sub>3</sub>=1. Apply the clock. On the first falling edge of clock, the FF-3 is set, and stored word in the register is Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub> = 1000.</p> 
<img src="images/siso_operation1.html" alt="SISO Operation step 1" />
<p>Apply the next bit to D<sub>in</sub>. So D<sub>in</sub>=1. As soon as the next negative edge of the clock hits, FF-2 will set and the stored word change to Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub> = 1100. </p>
<img src="images/siso_operation2.html" alt="SISO Operation step 2" />
<p>Apply the next bit to be stored i.e. 1 to D<sub>in</sub>. Apply the clock pulse. As soon as the third negative clock edge hits, FF-1 will be set and output will be modified to Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub> = 1110.</p>
<img src="images/siso_operation3.html" alt="SISO Operation step 3" />
<p>Similarly with D<sub>in</sub>=1 and with the fourth negative clock edge arriving, the stored word in the register is  Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub> = 1111.</p>
<img src="images/siso_operation4.html" alt="SISO Operation step 4" />
<h3>Truth Table</h3>
<img src="images/siso_truthtable.html" alt="Truth Table of SISO Register" />
<h3>Waveforms</h3>
<img src="images/siso_waveform.html" alt="Waveform of SISO Register" />
<h2>Serial Input Parallel Output</h2>
<ul class="list">
<li><p>In such types of operations, the data is entered serially and taken out in parallel fashion.</p></li>
<li><p>Data is loaded bit by bit. The outputs are disabled as long as the data is loading.</p></li>
<li><p>As soon as the data loading gets completed, all the flip-flops contain their required data, the outputs are enabled so that all the loaded data is made available over all the output lines at the same time.</p></li>
<li><p>4 clock cycles are required to load a four bit word. Hence the speed of operation of SIPO mode is same as that of SISO mode.</p></li>
</ul>
<h3>Block Diagram</h3>
<img src="images/sipo_blockdiagram.html" alt="Block Diagram of SIPO Register" />
<h2>Parallel Input Serial Output (PISO)</h2>
<ul class="list">
<li><p>Data bits are entered in parallel fashion.</p></li>
<li><p>The circuit shown below is a four bit parallel input serial output register.</p></li>
<li><p>Output of previous Flip Flop is connected to the input of the next one via a combinational circuit.</p></li>
<li><p>The binary input word B<sub>0</sub>,B<sub>1</sub>,B<sub>2</sub>,B<sub>3</sub> is applied though the same combinational circuit.</p></li>
<li><p>There are two modes in which this circuit can work namely shift mode or load mode.</p></li>
</ul>
<h3>Load mode</h3>
<p>When the shift/load bar line is low (0), the AND gate 2,4 and 6 become active. They will pass B<sub>1</sub>,B<sub>2</sub>,B<sub>3</sub> bits to the corresponding flip-flops. On the low going edge of clock, the binary input B<sub>0</sub>,B<sub>1</sub>,B<sub>2</sub>,B<sub>3</sub> will get loaded into the corresponding flip-flops. Thus parallel loading takes place.</p>
<h3>Shift mode</h3>
<p>When the shift/load bar line is low (1), the AND gate 2,4 and 6 become inactive. Hence the parallel loading of the data becomes impossible. But the AND gate 1,3 and 5 become active. Therefore the shifting of data from left to right bit by bit on application of clock pulses. Thus the parallel in serial out operation take place.</p>   
<h3>Block Diagram</h3>
<img src="images/piso_blockdiagram.html" alt="Block Diagram of PISO Register" />
<h2>Parallel Input Parallel Output (PIPO)</h2>
<p>In this mode, the 4 bit binary input B<sub>0</sub>,B<sub>1</sub>,B<sub>2</sub>,B<sub>3</sub> is applied to the data inputs D<sub>0</sub>,D<sub>1</sub>,D<sub>2</sub>,D<sub>3</sub> respectively of the four flip-flops. As soon as a negative clock edge is applied, the input binary bits will be loaded into the flip-flops simultaneously. The loaded bits will appear simultaneously to the output side. Only clock pulse is essential to load all the bits.</p>
<h3>Block Diagram</h3>
<img src="images/pipo_blockdiagram.html" alt="Block Diagram of PIPO Register" />
<h2>Bidirectional Shift Register</h2>
<ul class="list">
<li><p>If a binary number is shifted left by one position then it is equivalent to multiplying the original number by 2. Similarly if a binary number is shifted right by one position then it is equivalent to dividing the original number by 2.</p></li>
<li><p>Hence if we want to use the shift register to multiply and divide the given binary number, then we should be able to move the data in either left or right direction.</p></li>
<li><p>Such a register is called as a bi-directional register. A four bit bi-directional shift register is shown in fig.</p></li>
<li><p>There are two serial inputs namely the serial right shift data input DR and the serial left shift data input DL along with a mode select input (M).</p></li>
</ul>
<h3>Block Diagram</h3>
<img src="images/bidirectional_shiftregister_blockdiagram.html" alt="Block Diagram of Bidirectional Shift Register" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:20%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>With M = 1 : Shift right operation</b></td>
<td><ul class="list">
<li><p>If M = 1, then the AND gates 1,3,5 and 7 are enable whereas the remaining AND gates 2,4,6 and 8 will be disabled.</p></li>
<li><p>The data at D<sub>R</sub> is shifted to right bit by bit from FF-3 to FF-0 on the application of clock pulses. Thus with M = 1 we get the serial right shift operation.</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>With M = 0 : Shift left operation</b></td>
<td><ul class="list">
<li><p>When the mode control M is connected to 0 then the AND gates 2,4,6 and 8 are enabled while 1,3,5 and 7 are disabled.</p></li>
<li><p>The data at D<sub>L</sub> is shifted left bit by bit from FF-0 to FF-3 on the application of clock pulses. Thus with M = 0 we get the serial right shift operation.</p></li>
</ul>
</td></tr>
</table>
<h2>Universal Shift Register</h2>
<p>A shift register which can shift the data in only one direction is called a uni-directional shift register. A shift register which can shift the data in both directions is called a bi-directional shift register. Applying the same logic, a shift register which can shift the data in both directions as well as load it parallely, then it is known as a universal shift register. The shift register is capable of performing the following operation </p>
<ul class="list">
<li><p>Parallel loading</p></li>
<li><p>Lift shifting</p></li>
<li><p>Right shifting</p></li>
</ul>
<p>The mode control input is connected to logic 1 for parallel loading operation whereas it is connected to 0 for serial shifting. With mode control pin connected to ground, the universal shift register acts as a bi-directional register. For serial left operation, the input is applied to the serial input which goes to AND gate-1 shown in figure. Whereas for the shift right operation, the serial input is applied to D input.</p>
<h3>Block Diagram</h3>
<img src="images/universal_shiftregister_blockdiagram.html" alt="Block Diagram of Universal Shift Register" />
<h1>Digital Counters</h1>
<p>Counter is a sequential circuit. A digital circuit which is used for a counting pulses is known counter. Counter is the widest application of flip-flops. It is a group of flip-flops with a clock signal applied. Counters are of two types. </p>
<ul class="list">
<li><p>Asynchronous or ripple counters </p></li>
<li><p>Synchronous counters.</p></li>
</ul>
<h2>Asynchronous or ripple counters</h2>
<p>The logic diagram of a 2-bit ripple up counter is shown in figure. The toggle(T) flip-flop are being used. But we can use the JK flip-flop also with J and K connected permanently to logic 1. External clock is applied to the clock input of flip-flop A and Q<sub>A</sub> output is applied to the clock input of the next flip-flop i.e. FF-B.</p>
<h3>Logical Diagram</h3>
<img src="images/ripple_counter_diagram.html" alt="Logic Diagram of Asynchronous or ripple counters" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:30%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>Initially let both the FFs be in the reset state</b></td>
<td>Q<sub>B</sub>Q<sub>A</sub> = 00................initially</td></tr>
<tr><td>2</td><td><b>After 1st negative clock edge</b></td>
<td>
<ul class="list">
<li><p>As soon as the first negative clock edge is applied, FF-A will toggle and Q<sub>A</sub> will be equal to 1.</p></li>
<li><p>Q<sub>A</sub> is connected to clock input of FF-B. Since Q<sub>A</sub> has changed from 0 to 1, it is treated as the positive clock edge by FF-B. There is no change in Q<sub>B</sub> because FF-B is a negative edge triggered FF.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 01................After the first clock pulse</td></tr>
<tr><td>3</td><td><b>After 2nd negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On the arrival of second negative clock edge, FF-A toggles again and Q<sub>A</sub> = 0.</p></li>
<li><p>The change in Q<sub>A</sub> acts as a negative clock edge for FF-B. So it will also toggle, and Q<sub>B</sub> will be 1.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 10................After the second clock pulse</td></tr>
<tr><td>4</td><td><b>After 3rd negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On the arrival of 3rd negative clock edge, FF-A toggles again and Q<sub>A</sub>  become 1 from 0. </p></li>
<li><p>Since this is a positive going change,FF-B does not respond to it and remains inactive. So Q<sub>B</sub> does not change and continues to be equal to 1.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 11................After the third clock pulse</td></tr>
<tr><td>5</td><td><b>After 4th negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On the arrival of 4th negative clock edge, FF-A toggles again and Q<sub>A</sub>  become 1 from 0. </p></li>
<li><p>This negative change in Q<sub>A</sub> acts as clock pulse for FF-B. Hence it toggles to change Q<sub>B</sub> from 1 to 0.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 00................After the fourth clock pulse</td></tr>
</table>
<h2>Truth Table</h2>
<img src="images/ripple_counter_truthtable.html" alt="Truth Table of Asynchronous or ripple counters" />
<h2>Synchronous counters</h2>
<p>If the "clock" pulses are applied to all the flip-flops in a counter simultaneously, then such a counter is called as synchronous counter.</p>
<h3>2-bit Synchronous up counter</h3>
<p>The J<sub>A</sub> and K<sub>A</sub> inputs of FF-A are tied to logic 1. So FF-A will work as a toggle flip-flop. The J<sub>B</sub> and K<sub>B</sub> inputs are connected to Q<sub>A</sub>.</p>
<h3>Logical Diagram</h3>
<img src="images/synchronous_counter_diagram.html" alt="Logic Diagram of Synchronous counter" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:30%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>Initially let both the FFs be in the reset state</b></td>
<td>Q<sub>B</sub>Q<sub>A</sub> = 00................initially</td></tr>
<tr><td>2</td><td><b>After 1st negative clock edge</b></td>
<td>
<ul class="list">
<li><p>As soon as the first negative clock edge is applied, FF-A will toggle and Q<sub>A</sub> will change from 0 to 1.</p></li>
<li><p>But at the instant of application of negative clock edge, Q<sub>A</sub> ,J<sub>B</sub> = K<sub>B</sub> =0 Hence FF-B will not change its state. So Q<sub>B</sub> will remain 0.
</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 01................After the first clock pulse</td></tr>
<tr><td>3</td><td><b>After 2nd negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On the arrival of second negative clock edge, FF-A toggles again and Q<sub>A</sub> change from 1 to 0.</p></li>
<li><p>But at this instant Q<sub>A</sub> was 1. So J<sub>B</sub> = K<sub>B</sub>=1 and FF-B will toggle. Hence Q<sub>B</sub> changes from 0 to 1.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 10................After the second clock pulse</td></tr>
<tr><td>4</td><td><b>After 3rd negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On application of the third falling clock edge, FF-A will toggle from 0 to 1 but there is no change of state for FF-B.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 11................After the third clock pulse</td></tr>
<tr><td>5</td><td><b>After 4th negative clock edge</b></td>
<td>
<ul class="list">
<li><p>On application of the next clock pulse, Q<sub>A</sub> will change from 1 to 0 as Q<sub>B</sub> will also change from 1 to 0.</p></li>
</ul>
<br/>
Q<sub>B</sub>Q<sub>A</sub> = 00................After the fourth clock pulse</td></tr>
</table>
<h2>Classification of counters</h2>
<p>Depending on the way in which the counting progresses, the synchronous or asynchronous counters are classified as follows.</p>
<ul class="list">
<li><p>Up counters</p></li>
<li><p>Down counters</p></li>
<li><p>Up/Down counters</p></li>
</ul>
<h2>UP/DOWN Counter</h2>
<p>In the up/down counter, when up counter and down counter combined together to obtain an UP/DOWN counter. A mode control (M) input is also provided to select either up or down mode. A combinational circuit is required to be designed and used between each pair of flip-flop in order to achieve the up/down operation.</p>
<ul class="list">
<li><p>Type of up/down counters</p></li>
<li><p>UP/DOWN ripple counters</p></li>
<li><p>UP/DOWN synchronous counters</p></li>
</ul>
<h2>UP/DOWN Ripple Counters</h2>
<p>In the UP/DOWN ripple counter all the FFs operate in the toggle mode. So either T flip-flops or JK flip-flops are to be used. The LSB flip-flop receives clock directly. But the clock to every other FF is obtained from (Q = Q bar) output of the previous FF.</p>
<ul class="list">
<li><p><b>UP counting mode (M=0)</b> - The Q output of the preceding FF is connected to the clock of the next stage if up counting is to be achieved. For this mode, the mode select input M is at logic 0 (M=0).</p></li>
<li><p><b>DOWN counting mode (M=1)</b> - If M =1, then the Q bar output of the preceding FF is connected to the next FF. This will operate the counter in the counting mode.</p></li>
</ul>
<h3>Example</h3>
<p>3-bit binary up/down ripple counter.</p>
<ul class="list">
<li><p>3-bit : hence three FFs are required.</p></li>
<li><p>UP/DOWN : So a mode control input is essential.</p></li>
<li><p>For a ripple up counter, the Q output of preceding FF is connected to the clock input of the next one.</p></li>
<li><p>For a ripple up counter, the Q output of preceding FF is connected to the clock input of the next one.</p></li>
<li><p>For a ripple down counter, the Q bar output of preceding FF is connected to the clock input of the next one.</p></li>
<li><p>Let the selection of Q and Q bar output of the preceding FF be controlled by the mode control input M such that,	If M = 0, UP counting. So connect Q to CLK. If M = 1, DOWN counting. So connect Q bar to CLK</p></li>
</ul>
<h3>Block Diagram</h3>
<img src="images/updown_counter_diagram.html" alt="Block Diagram of Up/Down counters" />
<h3>Truth Table</h3>
<img src="images/updown_counter_truthtable.html" alt="Truth Table of Up/Down counters" />
<h3>Operation</h3>
<table class="src">
<tr><th style="width:5%;">S.N.</th><th style="width:30%;">Condition</th><th>Operation</th></tr>
<tr><td>1</td><td><b>Case 1: With M = 0 (Up counting mode)</b></td>
<td>
<ul class="list">
<li><p>If M = 0 and M bar = 1, then the AND gates 1 and 3 in fig. will be enabled whereas the AND gates 2 and 4 will be disabled.</p></li>
<li><p>Hence Q<sub>A</sub> gets connected to the clock input of FF-B and Q<sub>B</sub> gets connected to the clock input of FF-C.</p></li>
<li><p>These connections are same as those for the normal up counter. Thus with M = 0 the circuit work as an up counter.</p></li>
</ul>
</td></tr>
<tr><td>2</td><td><b>Case 2: With M = 1 (Down counting mode)</b></td>
<td>
<ul class="list">
<li><p>If M = 1, then AND gates 2 and 4 in fig. are enabled whereas the AND gates 1 and 3 are disabled.</p></li>
<li><p>Hence Q<sub>A</sub> bar gets connected to the clock input of FF-B and Q<sub>B</sub> bar gets connected to the clock input of FF-C.</p></li>
<li><p>These connections will produce a down counter. Thus with M = 1 the circuit works as a down counter.</p></li>
</ul>
</td></tr>
</table>
<h2>Modulus Counter (MOD-N Counter)</h2>
<p>The 2-bit ripple counter is called as MOD-4 counter and 3-bit ripple counter is called as MOD-8 counter. So in general, an n-bit ripple counter is called as modulo-N counter. Where,MOD number = 2<sup>n</sup>
<h3>Type of modulus</h3>
<ul class="list">
<li><p>2-bit up or down (MOD-4)</p></li>
<li><p>3-bit up or down (MOD-8)</p></li>
<li><p>4-bit up or down (MOD-16)</p></li>
</ul>
<h2>Application of the counters</h2>
<ul class="list">
<li><p>Frequency counters</p></li>
<li><p>Digital clock</p></li>
<li><p>Time measurement</p></li>
<li><p>A to D converter</p></li>
<li><p>Frequency divider circuits</p></li>
<li><p>Digital triangular wave generator</p></li>
</ul>
<h1>Memory Devices</h1>
<p>A memory is just like a human brain. It is used to store data and instruction. Computer memory is the storage space in computer where data is to be processed and instructions required for processing are stored.</p>
<p>The memory is divided into large number of small parts. Each part is called cell. Each location or cell has a unique address which varies from zero to memory size minus one.</p>
<p>For example if computer has 64k words, then this memory unit has 64 * 1024=65536 memory location. The address of these locations varies from 0 to 65535.</p>
<p>Memory is primarily of two types</p>
<ul class="list">
<li><p><b>Internal Memory</b> - cache memory and primary/main memory </p></li>
<li><p><b>External Memory</b> - magnetic disk / optical disk etc.</p></li>
</ul>
<img src="images/memory_hiearchy.html" alt="Memory Hiearchy" />
<p>Characteristics of Memory Hierarchy are following when we go from top to bottom.</p>
<ul class="list">
<li><p>Capacity in terms of storage increases.</p></li>
<li><p>Cost per bit of storage decreases.</p></li>
<li><p>Frequency of access of the memory by the CPU decreases.</p></li>
<li><p>Access time by the CPU increases</p></li>
</ul>
<h2>RAM</h2>
<p>A RAM constitutes the internal memory of the CPU for storing data, program and program result. It is read/write memory. It is called random access memory (RAM).</p>
<p>Since access time in RAM is independent of the address to the word that is, each storage location inside the memory is as easy to reach as other location & takes the same amount of time. We can reach into the memory at random & extremely fast but can also be quite expensive.</p> 
<p>RAM is volatile, i.e. data stored in it is lost when we switch off the computer or if there is a power failure. Hence a backup uninterruptible power system(UPS) is often used with computers. RAM is small , both in terms of its physical size and in the amount of data it can hold.</p> 
<p>RAM is of two types</p>
<ul class="list">
<li><p>Static RAM (SRAM)</p></li>
<li><p>Dynamic RAM (DRAM)</p></li>
</ul>
<h3>Static RAM (SRAM)</h3>
<p>The word <b>static</b> indicates that the memory retains its contents as long as power remains applied. However, data is lost when the power gets down due to volatile nature. SRAM chips use a matrix of 6-transistors and no capacitors. Transistors do not require power to prevent leakage, so SRAM need not have to be refreshed on a regular basis.</p> 
<p>Because of the extra space in the matrix, SRAM uses more chips than DRAM for the same amount of storage space, thus making the manufacturing costs higher.</p> 
<p>Static RAM is used as cache memory needs to be very fast and small.</p>
<h3>Dynamic RAM (DRAM)</h3>
<p>DRAM, unlike SRAM, must be continually <b>refreshed</b> in order for it to maintain the data. This is done by  placing the memory on a refresh circuit that rewrites the data several hundred times per second. DRAM is used for most system memory because it is cheap and small. All DRAMs are made up of memory cells. These cells are composed of one capacitor and one transistor.</p>
<h2>ROM</h2> 
<p>ROM stands for Read Only Memory. The memory from which we can only read but cannot write on it. This type of memory is non-volatile. The information is stored permanently in such memories during manufacture.</p>
<p>A ROM, stores such instruction as are required to start computer when electricity is first turned on, this operation is referred to as bootstrap. ROM chip are not only used in the computer but also in other electronic items like washing machine and microwave oven.</p>
<p>Following are the varioys types of ROM</p>
<h3>MROM (Masked ROM)</h3>
<p>The very first ROMs were hard-wired devices that contained a pre-programmed set of data or instructions. These kind of ROMs are known as masked ROMs. It is inexpensive ROM.</p>
<h3>PROM (Programmable Read only Memory)</h3>
<p>PROM is read-only memory that can be modified only once by a user. The user buys a blank PROM and enters the desired contents using a PROM programmer.Inside the PROM chip there are small fuses which are burnt open during programming. It can be programmed only once and is not erasable.</p>
<h3>EPROM(Erasable and Programmable Read Only Memory)</h3>
<p>The EPROM can be erased by exposing it to ultra-violet light for a duration of upto 40 minutes. Usually, a EPROM eraser achieves this function. During programming an electrical charge is trapped in an insulated gate region. The charge is retained for more than ten years because the charge has no leakage path. For erasing this charge, ultra-violet light is passed through a quartz crystal window(lid). This exposure to ultra-violet light dissipates the charge. During normal use the quartz lid is sealed with a sticker.</p>
<h3>EEPROM(Electrically Erasable and Programmable Read Only Memory)</h3>
<p>The  EEPROM is programmed and erased electrically. It can be erased and reprogrammed about ten thousand times. Both erasing and programming take about 4 to 10 ms (milli second). In EEPROM, any location can be selectively erased and programmed. EEPROMs can be erased one byte at a time, rather than erasing the entire chip. Hence, the process of re-programming is flexible but slow.</p>
<h2>Serial Access Memory</h2>
<p>Sequential access means the system must search the storage device from the beginning of the memory address until it finds the required piece of data. Memory device which supports such access is called a Sequential Access Memory or Serial Access Memory. Magnetic tape is an example of serial access memory.</p>
<h2>Direct Access Memory</h2>
<p>Direct access memory or Random Access Memory, refers to condition in which a system can go directly to the information that the user wants. Memory device which supports such access is called a Direct Access Memory. Magnetic disk, optical disks are an examples of direct access memory.</p>
<h2>Cache Memory</h2>
<p>Cache memory is a very high speed semiconductor memory which can speed up CPU. It acts as a buffer between the CPU and main memory. It is used to hold those parts of data and program which are most frequently used by CPU. The parts of data and programs are transferred from disk to cache memory by operating system, from where CPU can access them.</p>
<h3>Advantages</h3>
<ul class="list">
<li><p>Cache memory is faster than main memory.</p></li>
<li><p>It consumes less access time as compared to main memory.</p></li>
<li><p>It stores the program that can be executed within a short period of time.</p></li>
<li><p>It stores data for temporary use.</p></li>
</ul>
<h3>Disadvantages</h3>
<ul class="list">
<li><p>Cache memory has limited capacity.</p></li>
<li><p>It is very expensive.</p></li>
</ul>
<p>Virtual memory is a technique that allows the execution of processes which are not completely available in memory. The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory is the separation of user logical memory from physical memory. </p>
<p>This separation allows an extremely large virtual memory to be provided for programmers when only a smaller physical memory is available. Following are the situations, when entire program is not required to be loaded fully in main memory.</p>
<ul class="list">
<li><p>User written error handling routines are used only when an error occured in the data or computation.</p></li>
<li><p>Certain options and features of a program may be used rarely.</p></li>
<li><p>Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used.</p></li>
<li><p>The ability to execute a program that is only partially in memory would counter many benefits.</p></li>
<li><p>Less number of I/O would be needed to load or swap each user program into memory.</p></li>
<li><p>A program would no longer be constrained by the amount of physical memory that is available.</p></li>
<li><p>Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput.</p></li>
</ul>
<h2>Auxiliary Memory</h2>
<p>Auxiliary memory is much larger in size than main memory but is slower. It normally stores system programs, instruction and data files. It is also known as secondary memory. It can also be used as an overflow/virtual memory in case the main memory capacity has been exceeded. Secondary memories can not be accessed directly by a processor. First the data / information of auxillary memory is transferred to the main memory and then that information can be accessed by the CPU. Characteristics of Auxiliary Memory are following</p>
<ul class="list">
<li><p><b>Non-volatile memory</b> - Data is not lost when power is cut off.</p></li>
<li><p><b>Reusable</b> - The data stays in the secondary storage on permanent basis until it is not overwritten or deleted by the user.</p></li>
<li><p><b>Reliable</b> - Data in secondary storage is safe because of high physical stability of secondary storage device.</p></li>
<li><p><b>Convenience</b> - With the help of a computer software, authorised people can locate and access the data quickly.</p></li>
<li><p><b>Capacity</b> - Secondary storage can store large volumes of data in sets of multiple disks.</p></li>
<li><p><b>Cost</b> - It is much lesser expensive to store data on a tape or disk than primary memory.</p></li>
</ul>
<hr />
<div class="pre-btn">
<a href="cpu_architecture.html">Previous Page</a>
</div>
<div class="print-btn">
<a href="../cgi-bin/printpage.html" target="_blank">Print Version</a>
</div>
<div class="pdf-btn">
<a href="pdf/quick_guide.html" alt="Quick Reference Guide for Computer Logical Organization" target="_blank">PDF Version</a>
</div>
<div class="nxt-btn">
<a href="useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
</div>
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text";
google_ad_channel ="9030538898";
google_color_border="ffffff";
google_color_link="900b09";
google_color_url="000000";
google_color_text="000000";
//--></script>
<script type="text/javascript" src="../../pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div>
</div><!-- middlecol -->
<div id="rightcol">
<!-- AddThis Button BEGIN -->
<div class="addthis">
<div class="addthis_toolbox addthis_default_style">
<a class="addthis_button_facebook"></a>
<a class="addthis_button_twitter"></a>
<script type="text/javascript">
<!--
 document.write('<a class="addthis_button_google_plusone" g:plusone:count="false"></a>');
//-->
</script>
<a class="addthis_button_linkedin"></a>
<a class="addthis_button_email"></a>
<a class="addthis_button_compact"></a>
</div>
<script type="text/javascript" src="../../s7.addthis.com/js/250/addthis_widget.js#pubid=ra-4f661ec623a400f0"></script>
</div>
<!-- AddThis Button END -->
<div class="localad">
<a rel="nofollow" href="http://www.modernindianbabynames.com/" target="_blank" title="Modern Baby Names">Modern Baby Names</a>
</div>
<div class="localad">
<a rel="nofollow" href="http://www.photofuntoos.com/" target="_blank" title="Online Photo Editing">Online Photo Editing</a>
</div>
<div class="rightgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
</div><!-- rightcol -->
<div style="clear:both;"></div>
</div><!-- wrapper -->
<div id="footer">
<div class="wrapper">
<div id="bottommenu">
<a href="../asp.net/index.html" target="_top">ASP.NET </a> |
<a href="../jquery/index.html" target="_top">jQuery </a> |
<a href="../ajax/index.html" target="_top">AJAX </a> |
<a href="../ant/index.html" target="_top">ANT</a> |
<a href="../jsp/index.html" target="_top">JSP </a> |
<a href="../servlets/index.html" target="_top">Servlets </a> |
<a href="../log4j/index.html" target="_top">log4j </a> |
<a href="../ibatis/index.html" target="_top">iBATIS </a> |
<a href="../hibernate/index.html" target="_top">Hibernate </a> |
<a href="../jdbc/index.html" target="_top">JDBC </a> |
<a href="../struts_2/index.html" target="_top">Struts </a> |
<a href="../html5/index.html" target="_top">HTML5 </a> |
<a href="../sql/index.html" target="_top">SQL </a> |
<a href="../mysql/index.html" target="_top">MySQL </a> |
<a href="../cplusplus/index.html" target="_top">C++ </a> |
<a href="../unix/index.html" target="_top">UNIX </a>
</div>
<div id="copyright">
<p>Copyright &copy; 2012 by tutorialspoint. All Rights Reserved.</p>
</div>
</div>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/computer_logical_organization/quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
</html>
