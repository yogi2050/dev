<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<!-- Mirrored from www.tutorialspoint.com/scala/scala_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<title>Scala Quick Guide</title>
<link rel="shortcut icon" href="../favicon.png" type="image/x-icon" />
<meta name="Keywords" content="Scala, Tutorials, Learning, Beginners, Basics, Object Oriented Language, Methods, Traits, Oriented Language, Methods, Pattern Matching, Tuples, Annotations, Designators." />
<meta name="description" content="Scala Quick Guide - Learning Scala in simple and easy steps . A beginner's tutorial containing complete knowledge of Scala Syntax Object Oriented Language, Traits, Methods, Pattern Matching, Tuples, Annotations, Extractors." />
<meta http-equiv="pragma" content="no-cache" />
<meta http-equiv="cache-control" content="no-cache" />
<base  />
<link rel="stylesheet" type="text/css" href="../tp.css" />
<script src="../../www.google-analytics.com/urchin.js" type="text/javascript"> 
</script>
<script type="text/javascript"> 
_uacct = "UA-232293-6";
urchinTracker();
</script>
</head>
<body>
<center>
<a name="top"></a>
<table border="0" class="main" cellpadding="2" cellspacing="0">
<tr>
<td class="content" valign="top" align="left">
<a href="../index-2.html"><img src="../images/tp-logo.gif" border="0"  alt="Tutorials Point" /></a>
<br />
<br />
<div  class="search">
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/custom" target="google_window">
<table border="0">
<tr><td nowrap="nowrap" valign="top" align="center" height="32">
<a href="http://www.google.com/">
<img src="../../www.google.com/logos/Logo_25wht.gif" border="0" alt="Google" align="middle"></img></a>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<input type="hidden" name="domains" value="www.tutorialspoint.com"></input>
<input type="text" name="q" size="20" maxlength="255" value=""></input>
<input type="submit" name="sa" style="width:20px;font-weight:bold" value="..."></input>
</td></tr>
<tr>
<td nowrap="nowrap">
<table>
<tr>
<td>
<input type="radio" name="sitesearch" value="" checked="checked"></input>
<font size="-1" color="#000000">Web</font>
</td>
<td>
<input type="radio" name="sitesearch" value="www.tutorialspoint.com"></input>
<font size="-1" color="#000000">This Site</font>
</td>
</tr>
</table>
<input type="hidden" name="client" value="pub-7133395778201029"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:336699;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;FORID:1"></input>
<input type="hidden" name="hl" value="en"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
</div>
<br />
&nbsp;&nbsp;<b>Scala Tutorial</b>
<div  class="left">
<ul class="menu">
<li><a class="left" target="_top" href="index.html">Scala - Home</a></li>
<li><a class="left" target="_top" href="scala_overview.html">Scala - Overview</a></li>
<li><a class="left" target="_top" href="scala_environment_setup.html">Scala - Environment Setup</a></li>
<li><a class="left" target="_top" href="scala_basic_syntax.html">Scala - Basic Syntax</a></li>
<li><a class="left" target="_top" href="scala_data_types.html">Scala - Data Types</a></li>
<li><a class="left" target="_top" href="scala_variables.html">Scala - Variables</a></li>
<li><a class="left" target="_top" href="scala_access_modifiers.html">Scala - Access Modifiers</a></li>
<li><a class="left" target="_top" href="scala_operators.html">Scala - Operators</a></li>
<li><a class="left" target="_top" href="scala_if_else.html">Scala - IF...ELSE</a></li>
<li><a class="left" target="_top" href="scala_loop_types.html">Scala - Loop Types</a></li>
<li><a class="left" target="_top" href="scala_functions.html">Scala - Functions</a></li>
<li><a class="left" target="_top" href="scala_closures.html">Scala - Closures</a></li>
<li><a class="left" target="_top" href="scala_strings.html">Scala - Strings</a></li>
<li><a class="left" target="_top" href="scala_arrays.html">Scala - Arrays</a></li>
<li><a class="left" target="_top" href="scala_collections.html">Scala - Collections</a></li>
<li><a class="left" target="_top" href="scala_classes_objects.html">Scala - Classes &amp; Objects</a></li>
<li><a class="left" target="_top" href="scala_traits.html">Scala - Traits</a></li>
<li><a class="left" target="_top" href="scala_pattern_matching.html">Scala - Pattern Matching</a></li>
<li><a class="left" target="_top" href="scala_regular_expressions.html">Scala - Regular Expressions</a></li>
<li><a class="left" target="_top" href="scala_exception_handling.html">Scala - Exception Handling</a></li>
<li><a class="left" target="_top" href="scala_extractors.html">Scala - Extractors</a></li>
<li><a class="left" target="_top" href="scala_file_io.html">Scala - Files I/O</a></li>
</ul>
</div>
<br />
&nbsp;&nbsp;<b>Scala Useful References</b>
<div  class="left">
<ul class="menu">
<li><a class="left" target="_top" href="scala_quick_guide.html"><b>Scala Quick Guide</b></a></li>
</ul>
</div>
<br />
&nbsp;&nbsp;<b>Scala Useful Resources</b>
<div  class="left">
<ul class="menu">
<li><a class="left" target="_top" href="scala_useful_resources.html">Scala Useful Resources</a></li>
</ul>
</div>
<br />
&nbsp;&nbsp;<b>Selected Reading</b>
<div  class="left">
<ul class="menu">
<li><a class="left" target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a class="left" target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</div>
<br /><br />
<small>&copy; 2013 TutorialsPoint.COM </small>
</td>
<td valign="top">
<br /><br />
<table cellpadding="0" cellspacing="0">
<tr valign="middle">
<td  style="width:20px;"></td>
<td  class="top">
&nbsp;&nbsp;<a class="top" href="../index-2.html">Home</a>&nbsp;&nbsp;
</td>
<td  style="width:20px;"></td>
<td  class="top">
&nbsp;&nbsp;<a class="top" href="../references.html">References</a>&nbsp;&nbsp;
</td>
<td  style="width:20px;"></td>
<td  class="top">
&nbsp;&nbsp;<a class="top" href="../forums/index.html">Discussion Forums</a>&nbsp;&nbsp;
</td>
<td  style="width:20px;"></td>
<td  class="top">
&nbsp;&nbsp;<a class="top" href="../about/index.html">About TP</a>&nbsp;&nbsp;
</td>
</tr>
</table>
<table class="middle" cellpadding="5" cellspacing="0">
<tr>
<td>
<!-- PRINTING STARTS HERE -->
<h1>Scala - Quick Guide</h1>
<hr />
<a href="scala_file_io.html"><img alt="previous" border="0" src="../images/previous.gif" /></a>
<a href="scala_useful_resources.html"><img alt="next" border="0" src="../images/next.gif" /></a>
<!-- AddThis Bookmark Button BEGIN -->
<a href="http://www.addthis.com/bookmark.php" rel="nofollow" onclick="addthis_url   = location.href; addthis_title = document.title; return addthis_click(this);" target="_blank"><img src="../images/add-this.gif" border="0" alt="AddThis Social Bookmark Button" /></a> <script type="text/javascript">var addthis_pub = 'tutorialspoint';</script><script type="text/javascript" src="http://s9.addthis.com/js/widget.php?v=10"></script>
<!-- AddThis Bookmark Button END -->
<br />
<br />
<hr/><div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
  src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
<hr />
<p>Scala, short for Scalable Language, is a hybrid functional programming language. It was created by Martin Odersky and it was first released in 2003.</p>
<p>Scala smoothly integrates features of object-oriented and functional languages and  Scala is compiled to run on the Java Virtual Machine. Many existing companies who depend on Java for business critical applications are turning to Scala to boost their development productivity, applications scalability and overall reliability.</p>
<p>Here are the important list of features which makes Scala a first choice of the application developers.</p>
<h2>Scala is object-oriented:</h2>
<p>Scala is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes and traits which will be explained in subsequent chapters.</p>
<p>Classes are extended by <b>subclassing</b> and a flexible <b>mixin-based composition</b> mechanism as a clean replacement for multiple inheritance.</p>
<h2>Scala is functional:</h2>
<p>Scala is also a functional language in the sense that every function is a value and because every value is an object so ultimately every function is an object.</p>
<p>Scala provides a lightweight syntax for defining <b>anonymous functions</b>, it supports <b>higher-order functions</b>, it allows functions to be <b>nested</b>, and supports <b>currying</b>. These concepts will be explained in subsequent chapters.</p>
<h2>Scala is statically typed:</h2>
<p>Scala, unlike some of the other statically typed languages, does not expect you to provide redundant type information. You don't have to specify a type in most cases, and you certainly don't have to repeat it.</p>
<h2>Scala runs on the JVM:</h2>
<p>Scala is compiled into Java Byte Code which is executed by the Java Virtual Machine (JVM). This means that Scala and Java has a common runtime platform. You can easily move from Java to Scala.</p>
<p>The Scala compiler compiles your Scala code into Java Byte Code which can then be executed by the <b>scala</b> command. The <b>scala</b> command is similar to the <b>java</b> command, in that it executes your compiled Scala code.</p>
<h2>Scala can Execute Java Code:</h2>
<p>Scala enables you to use all the classes of the Java SDK's in Scala, and also your own, custom Java classes, or your favourite Java open source projects.</p>
<h1>Scala vs Java:</h1>
<p>Scala has a set of features which differ from Java. Some of these are:</p>
<ul>
<li><p>All types are objects.</p></li>
<li><p>Type inference. </p></li>
<li><p>Nested Functions.</p></li>
<li><p>Functions are objects. </p></li>
<li><p>Domain specific language (DSL) support. </p></li>
<li><p>Traits. </p></li>
<li><p>Closures. </p></li>
<li><p>Concurrency support inspired by Erlang.</p></li>
</ul>
<h1>Scala - Environment Setup:</h1>
<p>The Scala language can be installed on any Unix-like or Windows system. Before you start installing Scala on your machine, you must have Java 1.5 or greater installed on your computer.</p>
<h2>Installing Scala on Windows:</h2>
<h3>Step (1): JAVA Setup:</h3>
<p>First, you must set the JAVA_HOME environment variable and add the JDK's bin directory to your PATH variable. To verify if everything is fine, at command prompt, type <b>java -version</b> and press Enter. You should see something like the following:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
C:\&gt;java -version
java version "1.6.0_15"
Java(TM) SE Runtime Environment (build 1.6.0_15-b03)
Java HotSpot(TM) 64-Bit Server VM (build 14.1-b02, mixed mode)

C:\&gt;
</pre></td></tr>
</table>
<p>Next, test to see that the Java compiler is installed. Type <b>javac -version</b>. You should see something like the following:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
C:\&gt;javac -version
javac 1.6.0_15

C:\&gt;
</pre></td></tr>
</table>
<h3>Step (2): Scala Setup:</h3>
<p>Next you can download Scala from <a rel="nofollow" target="_blank" href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a>. At the time of writing this tutorial I downloaded <i>scala-2.9.0.1-installer.jar</i> and put it in C:/&gt; directory. Make sure you have admin privilege to  proceed. Now execute the following command at command prompt:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
C:\&gt;java -jar scala-2.9.0.1-installer.jar

C:\&gt;
</pre></td></tr>
</table>
<p>Above command will display an installation wizard which will guide you to install scala on you windows machine. During installation, it will ask for license agreement, simply accept it and further it will ask a path where scala will be installed. I selected default given path <i>C:\Program Files\scala</i>, you can select a suitable path as per your convenience. Finally, open a new command prompt and type <b>scala -version</b> and press Enter. You should see the following:</p> 
<table cellpadding="5" class="src">
<tr><td><pre>
C:\&gt;scala -version
Scala code runner version 2.9.0.1 -- Copyright 2002-2011, LAMP/EPFL

C:\&gt;
</pre></td></tr>
</table>
<p>Congratulations, you have installed Scala on your Windows machine. Next section will teach you how to install scala on your Mac OS X and Unix/Linux machines.</p>
<h2>Installing Scala on Mac OS X and Linux</h2>
<h3>Step (1): JAVA Setup:</h3>
<p>Make sure you have got the Java JDK 1.5 or greater installed on your computer and set JAVA_HOME environment variable and add the JDK's bin directory to your PATH variable. To verify if everything is fine, at command prompt, type <b>java -version</b> and press Enter. You should see something like the following:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
$java -version
java version "1.5.0_22"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_22-b03)
Java HotSpot(TM) Server VM (build 1.5.0_22-b03, mixed mode)

$
</pre></td></tr>
</table>
<p>Next, test to see that the Java compiler is installed. Type <b>javac -version</b>. You should see something like the following:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
$javac -version
javac 1.5.0_22
javac: no source files
Usage: javac &lt;options&gt; &lt;source files&gt;
................................................

$
</pre></td></tr>
</table>
<h3>Step (2): Scala Setup:</h3>
<p>Next you can download Scala from <a rel="nofollow" target="_blank" href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a>. At the time of writing this tutorial I downloaded <i>scala-2.9.0.1-installer.jar</i> and put it in /tmp directory. Make sure you have admin privilege to  proceed. Now execute the following command at command prompt:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
$java -jar scala-2.9.0.1-installer.jar
Welcome to the installation of scala 2.9.0.1!
The homepage is at: http://scala-lang.org/
press 1 to continue, 2 to quit, 3 to redisplay
1
................................................
[ Starting to unpack ]
[ Processing package: Software Package Installation (1/1) ]
[ Unpacking finished ]
[ Console installation done ]

$
</pre></td></tr>
</table>
<p>During installation, it will ask for license agreement, to accept it type 1 and it will ask a path where scala will be installed. I entered <i>/usr/local/share</i>, you can select a suitable path as per your convenience. Finally, open a new command prompt and type <b>scala -version</b> and press Enter. You should see the following:</p>
<table cellpadding="5" class="src">
<tr><td><pre>
$scala -version
Scala code runner version 2.9.0.1 -- Copyright 2002-2011, LAMP/EPFL

$
</pre></td></tr>
</table>
<p>Congratulations, you have installed Scala on your Unix/Linux machine.</p>
<h1>Scala - Basic Syntax</h1>
<p>If you have good understanding on Java then it will be very easy for you to learn Scala. The biggest syntactic difference between Scala and Java is that the ; line end character is optional. When we consider a Scala program it can be defined as a collection of objects that communicate via invoking each others methods. Let us now briefly look into what do class, object, methods and instant variables mean.</p>
<ul>
<li><p><b>Object -</b> Objects have states and behaviors. Example: A dog has states-color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. </p></li>
<li><p><b>Class -</b> A class can be defined as a template/ blue print that describe the behaviors/states that object of its type support.</p></li>
<li><p><b>Methods -</b> A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li>
<li><p><b>Fields -</b> Each object has its unique set of instant variables which are called fields. An object's state is created by the values assigned to these fields.</p></li>
</ul>
<h2>First Scala Program:</h2>
<h3>Interactive Mode Programming:</h3>
<p>Invoking the interpreter without passing a script file as a parameter brings up the following prompt:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:\&gt;scala
Welcome to Scala version 2.9.0.1
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;
</pre></td></tr>
</table>
<p>Type the following text to the right of the Scala prompt and press the Enter key:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
scala&gt; println("Hello, Scala!");
</pre></td></tr>
</table>
<p>This will produce following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
Hello, Scala!
</pre></td></tr>
</table>
<h3>Script Mode Programming :</h3>
<p>Let us look at a simple code that would print the words <i>Hello, World!</i>.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object HelloWorld {
   /* This is my first java program.  
    * This will print 'Hello World' as the output
    */
   def main(args: Array[String]) {
      println("Hello, world!") // prints Hello World
   }
}
</pre></td></tr>
</table>
<p>Let's look at how to save the file, compile and run the program. Please follow the steps given below:</p>
<ol>
<li><p>Open notepad and add the code as above.</p></li>
<li><p>Save the file as:  HelloWorld.scala.</p></li>
<li><p>Open a command prompt window and go o the directory where you saved the 	program file. Assume it is C:\&gt;</p></li>
<li><p>Type 'scalac HelloWorld.scala' and press enter to compile your code. If there are no errors in your code the command prompt will take you to the next line.</p></li>
<li><p>Above command will generate a few class files in the current directory. One of them will be called <b>HelloWorld.class</b>. This is a bytecode which will run on Java Virtual Machine (JVM).</p></li>
<li><p>Now type 'scala HelloWorld' to run your program.</p></li>	
<li><p>You will be able to see 'Hello, World!' printed on the window.</p></li>
</ol>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:\&gt; scalac HelloWorld.scala
C:\&gt; scala HelloWorld
Hello, World!
</pre></td></tr>
</table>
<h2>Basic Syntax:</h2>
<p>About Scala programs, it is very important to keep in mind the following points.</p>
<ul>
<li><p><b>Case Sensitivity - </b> Scala is case sensitive which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Scala.</p></li>
<li><p><b>Class Names - </b> For all class names the first letter should be in Upper Case. <br /><br /> If several words are used to form a name of the class each inner words first letter should be in Upper Case.<br /><br /> Example <i>class MyFirstScalaClass </i></p></li>
<li><p><b>Method Names - </b> All method names should start with a Lower Case letter.  <br /><br /> If several words are  used to form the name of the method, then each inner word's first letter should be in Upper Case.<br /><br /> Example <i>def myMethodName()</i></p></li>
<li><p><b>Program File Name - </b> Name of the program file should exactly match the object name.  <br /><br /> When saving the file you should save it using the object name (Remember scala is case sensitive) and append '.scala' to the end of the name. (if the file name and the object name do not match your program will not compile).<br /><br /> Example : Assume 'HelloWorld' is the object  name. Then the file should be saved as <i>'HelloWorld.scala'</i></p></li>
<li><p><b>def main(args: Array[String]) -</b> Scala program processing starts from the main() method which is a mandatory part of every Scala Program.</p></li>
</ul>
<h2>Scala Identifiers:</h2>
<p>All Scala components require names. Names used for objects, classes, variables and methods are called identifiers. A keyword cannot be used as an identifier and identifiers are case sensitive. There are following four type of identifiers supported by Scala:</p>
<h3>Alphanumeric identifiers</h3>
<p>An alphanumeric identifier starts with a letter or underscore, which can be followed by further letters, digits, or underscores. The '$' character is reserved keyword in Scala and should not be used in identifiers. Following are legal alphanumeric identifiers:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
age, salary, _value,  __1_value
</pre></td></tr>
</table>
<p>Following are illegal identifiers:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
$salary, 123abc, -salary
</pre></td></tr>
</table>
<h3>Operator identifiers</h3>
<p>An operator identifier consists of one or more operator characters. Operator characters are printable ASCII characters such as +, :, ?, ~ or #. Following are legal operator identifiers:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
+ ++ ::: &lt;?&gt; :&gt;
</pre></td></tr>
</table>
<p>The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-&gt; would be represented internally as $colon$minus$greater.</p>
<h3>Mixed identifiers</h3>
<p>An mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier. Following are legal mixed identifiers:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
unary_+,  myvar_=
</pre></td></tr>
</table>
<p>Here unary_+ used as a method name defines a unary + operator and myvar_= used as method name defines an assignment operator.</p>
<h3>Literal identifiers</h3>
<p>An literal identifier is an arbitrary string enclosed in back ticks (` . . . `). Following are legal literal identifiers:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
`x` `&lt;clinit&gt;` `yield`
</pre></td></tr>
</table>
<h2>Scala Keywords:</h2>
<p>The following list shows the reserved words in Scala. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="src" border="1" cellpadding="5">
<tr><td>abstract</td><td>case</td><td>catch</td><td>class</td></tr>
<tr><td>def</td><td>do</td><td>else</td><td>extends</td></tr>
<tr><td>false</td><td>final</td><td>finally</td><td>for</td></tr>
<tr><td>forSome</td><td>if</td><td>implicit</td><td>import</td></tr>
<tr><td>lazy</td><td>match</td><td>new</td><td>null</td></tr>
<tr><td>object</td><td>override</td><td>package</td><td>private</td></tr>
<tr><td>protected</td><td>return</td><td>sealed</td><td>super</td></tr>
<tr><td>this</td><td>throw</td><td>trait</td><td>try</td></tr>
<tr><td>true</td><td>type</td><td>val</td><td>var</td></tr>
<tr><td>while</td><td>with</td><td>yield</td><td>&nbsp;</td></tr>
<tr><td>-</td><td>:</td><td>=</td><td>=&gt;</td></tr>
<tr><td>&lt;-</td><td>&lt;:</td><td>&lt;%</td><td>&gt;:</td></tr>
<tr><td>#</td><td>@</td><td></td><td></td></tr>
</table>
<h2>Comments in Scala</h2>
<p>Scala supports single line and multi-line comments very similar to Java. Multi-line comments may be nested, but are required to be properly nested. All characters available inside any comment are ignored by Scala compiler.</p>
<table class="src" cellpadding="5">
<tr><td><pre>
object HelloWorld {
   /* This is my first java program.  
    * This will print 'Hello World' as the output
    * This is an example of multi-line comments.
    */
   def main(args: Array[String]) {
      // Prints Hello World
      // This is also an example of single line comment.
      println("Hello, world!") 
   }
}
</pre></td></tr>
</table>
<h2>Blank Lines and Whitespace:</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and Scala totally ignores it. Tokens may be separated by whitespace characters and/or comments.</p>
<h2>Newline Characters:</h2>
<p>Scala is a line-oriented language where statements may be terminated by semicolons (;) or newlines. A semicolon at the end of a statement is usually optional. You can type one if you want but you don.t have to if the statement appears by itself on a single line. On the other hand, a semicolon is required if you write multiple statements on a single line:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
val s = "hello"; println(s)
</pre></td></tr>
</table>
<h2>Scala Packages:</h2>
<p>A package is a named module of code. For example, the Lift utility package is net.liftweb.util. The package declaration is the first non-comment line in the source file as follows:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
package com.liftcode.stuff
</pre></td></tr>
</table>
<p>Scala packages can be imported so that they can be referenced in the current compilation scope. The following statement imports the contents of the scala.xml package:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
import scala.xml._
</pre></td></tr>
</table>
<p>You can import a single class and object, for example, HashMap from the scala.collection.mutable package:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
import scala.collection.mutable.HashMap
</pre></td></tr>
</table>
<p>You can import more than one class or object from a single package, for example, TreeMap and TreeSet from the scala.collection.immutable package:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
import scala.collection.immutable.{TreeMap, TreeSet}
</pre></td></tr>
</table>
<h1>Scala - Data Types</h1>
<p>Scala has all the same data types as Java, with the same memory footprint and precision. Following is the table giving detail about all the data types available in Scala:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="20%">Data Type</th><th>Description</th></tr>
<tr><td>Byte</td><td>8 bit signed value. Range from -128 to 127</td></tr>
<tr><td>Short</td><td>16 bit signed value. Range -32768 to 32767</td></tr>
<tr><td>Int</td><td>32 bit signed value. Range -2147483648 to 2147483647</td></tr>
<tr><td>Long</td><td>64 bit signed value. -9223372036854775808 to 9223372036854775807</td></tr>
<tr><td>Float</td><td>32 bit IEEE 754 single-precision float</td></tr>
<tr><td>Double</td><td>64 bit IEEE 754 double-precision float</td></tr>
<tr><td>Char</td><td>16 bit unsigned Unicode character. Range from U+0000 to U+FFFF</td></tr>
<tr><td>String</td><td>A sequence of Chars</td></tr>
<tr><td>Boolean</td><td>Either the literal true or the literal false</td></tr>
<tr><td>Unit</td><td>Corresponds to no value</td></tr>
<tr><td>Null</td><td>null or empty reference</td></tr>
<tr><td>Nothing</td><td>The subtype of every other type; includes no values</td></tr>
<tr><td>Any</td><td>The supertype of any type; any object is of type <i>Any</i></td></tr>
<tr><td>AnyRef</td><td>The supertype of any reference type</td></tr>
</table>
<p>All the data types listed above are objects. There are no primitive types like in Java. This means that you can call methods on an Int, Long etc.</p>
<h2>Scala Basic Literals:</h2>
<p>The rules Scala uses for literals are simple and intuitive. This section explains all basic Scala Literals.</p>
<h3>Integer Literals</h3>
<p>Integer literals are usually of type Int, or of type Long when followed by a L or l suffix. Here are some integer literals:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
0
035
21 
0xFFFFFFFF 
0777L
</pre></td></tr>
</table>
<h3>Floating Point Literals</h3>
<p>Floating point literals are of type Float when followed by a floating point type suffix F or f, and are of type Double otherwise. Here are some floating point literals:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
0.0 
1e30f 
3.14159f 
1.0e100
.1
</pre></td></tr>
</table>
<h3>Boolean Literals</h3>
<p>The boolean literals <b>true</b> and <b>false</b> are members of type Boolean.</p>
<h3>Symbol Literals</h3>
<p>A symbol literal 'x is a shorthand for the expression <b>scala.Symbol("x")</b>. Symbol is a case class, which is defined as follows.</p>
<table class="src" cellpadding="5">
<tr><td><pre>
package scala
final case class Symbol private (name: String) {
   override def toString: String = "'" + name
}
</pre></td></tr>
</table>
<h3>Character Literals</h3>
<p>A character literal is a single character enclosed in quotes. The character is either a printable unicode character or is described by an escape sequence. Here are some character literals:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
'a' 
'\u0041'
'\n'
'\t'
</pre></td></tr>
</table>
<h3>String Literals</h3>
<p>A string literal is a sequence of characters in double quotes. The characters are either printable unicode character or are described by escape sequences. Here are some string literals:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
"Hello,\nWorld!"
"This string contains a \" character."
</pre></td></tr>
</table>
<h3>Multi-Line Strings</h3>
<p>A multi-line string literal is a sequence of characters enclosed in triple quotes """ ... """. The sequence of characters is arbitrary, except that it may contain three or more consuctive quote characters only at the very end.</p>
<p>Characters must not necessarily be printable; newlines or other control characters are also permitted. Here is a multi-line string literal:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
"""the present string
spans three
lines."""
</pre></td></tr>
</table>
<h3>The Null Value</h3>
<p>The null value is of type <b>scala.Null</b>, and is thus compatible with every reference type. It denotes a reference value which refers to a special "null" object.</p>
<h2>Escape Sequences:</h2>
<p>The following escape sequences are recognized in character and string literals.</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="20%">Escape Sequences</th><th>Unicode</th><th>Description</th></tr>
<tr><td>\b</td><td>\u0008</td><td> backspace BS</td></tr>
<tr><td>\t</td><td>\u0009</td><td> horizontal tab HT</td></tr>
<tr><td>\n</td><td>\u000c</td><td> formfeed FF</td></tr>
<tr><td>\f</td><td>\u000c</td><td> formfeed FF</td></tr>
<tr><td>\r</td><td>\u000d</td><td>carriage return CR</td></tr>
<tr><td>\"</td><td>\u0022</td><td> double quote "</td></tr>
<tr><td>\'</td><td>\u0027</td><td> single quote .</td></tr>
<tr><td>\\</td><td>\u005c</td><td>backslash \</td></tr>
</table>
<p>A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e. a backslash '\' followed by a sequence of up to three octal characters. Following is the example to show few escape sequence characters:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      println("Hello\tWorld\n\n" );
   }
} 
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
Hello   World
</pre></td></tr>
</table>
<h1>Scala - Variables</h1>
<p>Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.</p>
<p>Based on the data type of a variable, the compiler allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.</p>
<h2>Variable Declaration</h2>
<p>Scala has the different syntax for the declaration of variables and they can be defined as value ie. constant or a variable. Following is the syntax to define a variable using <b>var</b> keyword:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
var myVar : String = "Foo"
</pre></td></tr>
</table>
<p>Here myVar is declared using the keyword var. This means that it is a variable that can change value and this is called mutable variable. Following is the syntax to define a variable using <b>val</b> keyword:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
val myVal : String = "Foo"
</pre></td></tr>
</table>
<p>Here myVal is declared using the keyword val. This means that it is a variable that can not be changed and this is called immutable variable.</p>
<h2>Variable Data Types:</h2>
<p>The type of a variable is specified after the variable name, and before equal sign. You can define any type of Scala variable by mentioning its data type as follows:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
val or val VariableName : DataType [=  Initial Value]
</pre></td></tr>
</table>
<p>If you do not assign any initial value to a variable then it is valid as follows:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
var myVar :Int;
val myVal :String;
</pre></td></tr>
</table>
<h2>Variable Type Inference:</h2>
<p>When you assign an initial value to a variable, the Scala compiler can figure out the type of the varible based on the value assigned to it. This is called variable type inference. Therefore, you could write these variable declarations like this:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
var myVar = 10;
val myVal = "Hello, Scala!";
</pre></td></tr>
</table>
<p>Here by default myVar will be Int type and myVal will become String type variable.</p>
<h2>Multiple assignments:</h2>
<p>Scala supports multiple assignment. If a code block or method returns a Tuple, the Tuple can be assigned to a val variable. [ Note: We will study Tuble in subsequent chapters.]</p>
<table class="src" cellpadding="5">
<tr><td><pre>
val (myVar1: Int, myVar2: String) = Pair(40, "Foo")
</pre></td></tr>
</table>
<p>And the type inferencer gets it right:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
val (myVar1, myVar2) = Pair(40, "Foo")
</pre></td></tr>
</table>
<h2>Variable Types:</h2>
<p>Variables in Scala can have three different scopes depending on the place where they are being used. They can exist as <b>fields</b>, as <b>method parameters</b> and as <b>local variables</b>. Below is the detail about each type of scope:</p>
<h3>Fields:</h3>
<p>Fields are variables that belong to an object. The fields are accessible from inside every method in the object. Fields can also be accessible outside the object depending on what access modifiers the field is declared with. Object fields can be both mutable or immutable types and can be defined using either var or val.</p>
<h3>Method Parameters:</h3>
<p>Method parameters are variables which are used to pass the value inside a method when the method is called. Method parameters are only accessible from inside the method  but the objects passed in may be accessible from the outside, if you have a reference to the object from outside the method. Method parameters are always mutable and defined by val keyword.</p>
<h3>Local Variables:</h3>
<p>Local variables are variables declared inside a method. Local variables are only accessible from inside the method, but the objects you create may escape the method if you return them from the method. Local variables can be both mutable or immutable types and can be defined using either var or val.</p>
<h1>Scala - Access Modifiers</h1>
<p>Members of packages, classes, or objects can be labeled with the access modifiers <b>private</b> and <b>protected</b> and if we are not using either of these two keywords then access will be assumed as <b>public</b>. These modifiers restrict accesses to the members to certain regions of code. To use a access modifier, you include its keyword in the definition of members of package, classe, or object as we will see in the following section.</p>
<h2>Private members:</h2>
<p>A <b>private</b> member is visible only inside the class or object that contains the member definition. Following is the example:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
class Outer {
   class Inner {
      private def f() { println("f") }
      class InnerMost {
         f() // OK
      }
   }
   (new Inner).f() // Error: f is not accessible
}
</pre></td></tr>
</table>
<p>In Scala, the access (new Inner).f() is illegal because f is declared private in Inner and the access is not from within class Inner. By contrast, the first access to f in class InnerMost is OK, because that access is contained in the body of class Inner. Java would permit both accesses because it lets an outer class access private members of its inner classes.</p>
<h2>Protected members:</h2>
<p>A <b>protected</b> member is only accessible from subclasses of the class in which the member is defined. Following is the example:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
package p {
   class Super {
      protected def f() { println("f") }
   }
   class Sub extends Super {
      f()
   }
   class Other {
     (new Super).f() // Error: f is not accessible
   }
}
</pre></td></tr>
</table>
<p>The access to f in class Sub is OK because f is declared protected in Super and Sub is a subclass of Super. By contrast the access to f in Other is not permitted, because Other does not inherit from Super. In Java, the latter access would be still permitted because Other is in the same package as Sub.</p>
<h2>Public members:</h2>
<p>Every member not labeled private or protected is public. There is no explicit modifier for public members. Such members can be accessed from anywhere. Following is the example:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
class Outer {
   class Inner {
      def f() { println("f") }
      class InnerMost {
         f() // OK
      }
   }
   (new Inner).f() // OK because now f() is public
}
</pre></td></tr>
</table>
<h2>Scope of protection:</h2>
<p>Access modifiers in Scala can be augmented with qualifiers. A modifier of the form private[X] or protected[X] means that access is private or protected "up to" X, where X designates some enclosing package, class or singleton object. Consider the following example:</p>
<table class="src" cellpadding="5">
<tr><td><pre>
package society {
   package professional {
      class Executive {
         private[<i>professional</i>] var workDetails = null
         private[<i>society</i>] var friends = null
         private[<i>this</i>] var secrets = null

         def help(another : Executive) {
            println(another.workDetails)
            println(another.secrets) //ERROR
         }
      }
   }
}
</pre></td></tr>
</table>
<p>Note the following points from the above example:</p>
<ul>
<li><p>Variable <i>workDetails</i> will be accessible to any class within the enclosing package <i>professional</i>.</p></li>
<li><p>Variable <i>friends</i> will be accessible to any class within the enclosing package <i>society</i>.</p></li>
<li><p>Variable <i>secrets</i>  will be accessible only on the implicit object within instance methods (this).</p></li>
</ul>
<h1>Scala - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Scala is rich in built-in operators and provides following type of operators:</p>
<ul>
<li><p>Arithmetic Operators</p></li>
<li><p>Relational Operators</p></li>
<li><p>Logical Operators</p></li>
<li><p>Bitwise Operators</p></li>
<li><p>Assignment Operators</p></li>
</ul>
<p>This chapter will examine the arithmetic, relational, and logical, bitwise, assignment and other operators one by one.</p>
<h2>Arithmetic Operators:</h2>
<p>There are following arithmetic operators supported by Scala language:</p>
<p>Assume variable A holds 10 and variable B holds 20 then:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="10%">Operator</th><th width="45%">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Adds two operands</td><td> A + B will give 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first</td><td> A - B will give -10</td></tr>
<tr><td>*</td><td>Multiply both operands</td><td> A * B will give 200</td></tr>
<tr><td>/</td><td>Divide numerator by de-numerator</td><td> B / A will give 2</td></tr>
<tr><td>%</td><td>Modulus Operator and remainder of after an integer division</td><td> B % A will give 0</td></tr>
<tr><td>++</td><td>Increment operator, increases integer value by one</td><td> A++ will give 11</td></tr>
<tr><td>--</td><td>Decrement operator, decreases integer value by one</td><td> A-- will give 9</td></tr>
</table>
<h2>Relational Operators:</h2>
<p>There are following relational operators supported by Scala language</p>
<p>Assume variable A holds 10 and variable B holds 20 then:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="10%">Operator</th><th width="45%">Description</th><th>Example</th></tr>
<tr><td>==</td><td> Checks if the value of two operands is equal or not, if yes then condition becomes true.</td><td> (A == B) is not true. </td></tr>
<tr><td>!=</td><td> Checks if the value of two operands is equal or not, if values are not equal then condition becomes true.</td><td> (A != B) is true. </td></tr>
<tr><td>&gt;</td><td> Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td><td> (A &gt; B) is not true. </td></tr>
<tr><td>&lt;</td><td> Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td><td> (A &lt; B) is true. </td></tr>
<tr><td>&gt;=</td><td> Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &gt;= B) is not true. </td></tr>
<tr><td>&lt;=</td><td> Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &lt;= B) is true. </td></tr>
</table>
<h2>Logical Operators:</h2>
<p>There are following logical operators supported by Scala language</p>
<p>Assume variable A holds 1 and variable B holds 0 then:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="10%">Operator</th><th width="45%">Description</th><th>Example</th></tr>
<tr><td>&amp;&amp;</td><td> Called Logical AND  operator. If both the operands are non zero then condition becomes true.</td><td> (A &amp;&amp; B) is false. </td></tr>
<tr><td>||</td><td>Called Logical OR Operator.  If any of the two operands is non zero then condition becomes true.</td><td> (A || B) is true. </td></tr>
<tr><td>!</td><td>Called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td><td> !(A &amp;&amp; B) is true. </td></tr>
</table>
<h2>Bitwise Operators:</h2>
<p>Bitwise operator works on bits and perform bit by bit operation. The truth tables for &amp;, |, and ^ are as follows:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th>p</th><th>q</th><th>p &amp; q</th><th>p | q</th><th>p ^ q</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</table>
<p>Assume if A = 60; and B = 13; Now in binary format they will be as follows:</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>A^B = 0011 0001</p>
<p>~A&nbsp; = 1100 0011</p>
<p>The Bitwise operators supported by Scala language is listed in the following table. Assume variable A holds 60 and variable B holds 13 then:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0" width="100%">
<tr><th width="10%">Operator</th><th width="45%">Description</th><th>Example</th></tr>
<tr><td>&amp;</td><td> Binary AND Operator copies a bit to the result if it exists in both operands. </td><td> (A &amp; B) will give 12 which is 0000 1100</td></tr>
<tr><td>|</td><td> Binary OR Operator copies a bit if it exists in eather operand. </td><td> (A | B) will give 61 which is 0011 1101</td></tr>
<tr><td>^</td><td> Binary XOR Operator copies the bit if it is set in one operand but not both. </td><td> (A ^ B) will give 49 which is 0011 0001</td></tr>
<tr><td>~</td><td> Binary Ones Complement Operator is unary and has the efect of 'flipping' bits. </td><td> (~A ) will give -60 which is 1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td><td> A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td><td> A &gt;&gt; 2 will give 15 which is 1111</td></tr>
<tr><td>&gt;&gt;&gt;</td><td> Shift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros. </td><td> A &gt;&gt;&gt;2 will give 15 which is 0000 1111</td></tr>
</table>
<h2>Assignment Operators:</h2>
<p>There are following assignment operators supported by Scala language:</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="10%">Operator</th><th width="45%">Description</th><th>Example</th></tr>
<tr><td>=</td><td>Simple assignment operator, Assigns values from right side operands to left side operand</td><td> C = A + B will assign value of A + B into C</td></tr>
<tr><td>+=</td><td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td><td> C += A is equivalent to C = C + A</td></tr>
<tr><td>-=</td><td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td><td> C -= A is equivalent to C = C - A</td></tr>
<tr><td>*=</td><td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td><td> C *= A is equivalent to C = C * A</td></tr>
<tr><td>/=</td><td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td><td> C /= A is equivalent to C = C / A</td></tr>
<tr><td>%=</td><td>Modulus AND assignment operator, It takes modulus using two operands and assign the result to  left operand</td><td> C %= A is equivalent to C = C % A</td></tr>
<tr><td>&lt;&lt;=</td><td>Left shift AND assignment operator </td><td> C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt;=</td><td>Right shift AND assignment operator </td><td> C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td></tr>
<tr><td>&amp;=</td><td>Bitwise AND assignment operator</td><td> C &amp;= 2 is same as  C = C &amp; 2</td></tr>
<tr><td>^=</td><td>bitwise exclusive OR and assignment operator</td><td> C ^= 2 is same as  C = C ^ 2</td></tr>
<tr><td>|=</td><td>bitwise inclusive OR and assignment operator</td><td> C |= 2 is same as  C = C | 2</td></tr>
</table>
<h2>Operators Precedence in Scala:</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:</p>
<p>For example x = 7 + 3 * 2;  Here  x is assigned 13, not 20 because operator * has higher precedence than + so it first get multiplied with 3*2 and then adds into 7.</p>
 <p>Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<table class="src" border="1" width="100%" cellpadding="5" cellspacing="0">
<tr><th>Category&nbsp;</th><th>Operator&nbsp;</th><th>Associativity&nbsp;</th></tr> 
<tr><td>Postfix&nbsp;</td><td>() []</td> <td>Left toright&nbsp;</td> </tr> 
<tr><td>Unary&nbsp;</td><td>!  ~ </td> <td>Right to left&nbsp;</td></tr> 
<tr><td>Multiplicative &nbsp;</td> <td>*  /  %&nbsp;</td><td>Left to right&nbsp;</td></tr>
<tr><td>Additive &nbsp;</td><td>+  -&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr><td>Shift &nbsp;</td><td>&gt;&gt; &gt;&gt;&gt; &lt;&lt; &nbsp;</td><td>Leftto right&nbsp;</td></tr> 
<tr><td>Relational &nbsp;</td><td>&gt; &gt;=  &lt; &lt;= &nbsp;</td><td>Left to right&nbsp;</td></tr>
<tr><td>Equality &nbsp;</td> <td>==  !=&nbsp;</td><td>Left to right&nbsp;</td></tr>
<tr><td>Bitwise AND&nbsp;</td><td>&amp;&nbsp;</td><td>Left to right&nbsp;</td></tr> 
<tr><td>Bitwise XOR&nbsp;</td><td>^&nbsp;</td><td>Left to right&nbsp;</td></tr> 
<tr><td>Bitwise OR&nbsp;</td><td>|&nbsp;</td><td>Left to right&nbsp;</td> </tr> 
<tr><td>Logical AND&nbsp;</td><td>&amp;&amp;&nbsp;</td><td>Left to right&nbsp;</td></tr> 
<tr><td>Logical OR&nbsp;</td><td>||&nbsp;</td><td>Left to right&nbsp;</td> </tr> 
<tr><td>Assignment&nbsp;</td><td>=  +=  -=  *=  /=  %= &gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=&nbsp;</td> <td>Right to left&nbsp;</td></tr> 
<tr><td>Comma&nbsp;</td><td>,&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
</table>
<h1>Scala - IF...ELSE</h1>
<p>Following is the general from of a typical decision making IF...ELSE structure found in most of the programming languages:</p>
<center>
<img src="../images/scala_decision_making.html" alt="Scala IF...ELSE Structure" />
</center>
<h2>The if Statement:</h2>
<p>An if statement consists of a Boolean expression followed by one or more statements.</p>
<h3>Syntax:</h3>
<p>The syntax of an if statement is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
if(Boolean_expression)
{
   // Statements will execute if the Boolean expression is true
}
</pre></td></tr>
</table>
<p>If the boolean expression evaluates to true then the block of code inside the if statement will be executed. If not the first set of code after the end of the if statement(after the closing curly brace) will be executed.</p>
<h3>Example:</h3>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var x = 10;

      if( x &lt; 20 ){
         println("This is if statement");
      }
   }
}
</pre></td></tr>
</table>
<p>This would produce following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
This is if statement

C:/&gt;
</pre></td></tr>
</table>
<h2>The if...else Statement:</h2>
<p>An if statement can be followed by an optional <i>else</i> statement, which executes when the Boolean expression is false.</p>
<h3>Syntax:</h3>
<p>The syntax of a if...else is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
if(Boolean_expression){
   //Executes when the Boolean expression is true
}else{
   //Executes when the Boolean expression is false
}
</pre></td></tr>
</table>
<h3>Example:</h3>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var x = 30;

      if( x &lt; 20 ){
         println("This is if statement");
      }else{
         println("This is else statement");
      }
   }
}
</pre></td></tr>
</table>
<p>This would produce following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
This is else statement

C:/&gt;
</pre></td></tr>
</table>
<h2>The if...else if...else Statement:</h2>
<p>An if statement can be followed by an optional <i>else if...else</i> statement, which is very usefull to test various conditions using single if...else if statement.</p>
<p>When using if , else if , else statements there are few points to keep in mind.</p>
<ul>
<li><p>An if can have zero or one else's and it must come after any else if's.</p></li>
<li><p>An if can have zero to many else if's and they must come before the else.</p></li>
<li><p>Once an else if succeeds, none of he remaining else if's or else's will be tested.</p></li>
</ul>
<h3>Syntax:</h3>
<p>The syntax of a if...else if...else is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
if(Boolean_expression 1){
   //Executes when the Boolean expression 1 is true
}else if(Boolean_expression 2){
   //Executes when the Boolean expression 2 is true
}else if(Boolean_expression 3){
   //Executes when the Boolean expression 3 is true
}else {
   //Executes when the none of the above condition is true.
}
</pre></td></tr>
</table>
<h3>Example:</h3>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var x = 30;

      if( x == 10 ){
         println("Value of X is 10");
      }else if( x == 20 ){
         println("Value of X is 20");
      }else if( x == 30 ){
         println("Value of X is 30");
      }else{
         println("This is else statement");
      }
   }
}
</pre></td></tr>
</table>
<p>This would produce following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Value of X is 30

C:/&gt;
</pre></td></tr>
</table>
<h2>Nested if...else Statement:</h2>
<p>It is always legal to nest if-else statements, which means you can use one if or else if statement inside another if or else if statement.</p>
<h3>Syntax:</h3>
<p>The syntax for a nested if...else is as follows:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
if(Boolean_expression 1){
   //Executes when the Boolean expression 1 is true
   if(Boolean_expression 2){
      //Executes when the Boolean expression 2 is true
   }
}
</pre></td></tr>
</table>
<p>You can nest <i>else if...else</i> in the similar way as we have nested <i>if</i> statement.</p>
<h3>Example:</h3>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
        var x = 30;
        var y = 10;

         if( x == 30 ){
            if( y == 10 ){
            println("X = 30 and Y = 10");
         }
      }
   }
}
</pre></td></tr>
</table>
<p>This would produce following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
X = 30 and Y = 10

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Loop Types</h1>
<p>There may be a situation when you need to execute a block of code several number of times. In general statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general from of a loop statement in most of the programming languages:</p>
<center>
<img src="../images/loop_architecture.jpg" alt="Loop Architecture" />
</center>
<p>Scala programming language provides following types of loop to handle looping requirements. Click the following links to check their detail.</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="30%">Loop Type</th><th>Description</th></tr>
<tr><td><a href="scala_while_loop.html" title="Scala while loop">while loop</a></td><td>Repeats a statement or group of statements until a given condition is true. It tests the condition before executing the loop body.</td></tr>
<tr><td><a href="scala_do_while_loop.html" title="CScala+ do...while loop">do...while loop</a></td><td>Like a while statement, except that it tests the condition at the end of the loop body</td></tr>
<tr><td><a href="scala_for_loop.html" title="CScala+ for loop">for loop</a></td><td>Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td></tr>
</table>
<h2>Loop Control Statements:</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. As such Scala does not support <b>break</b> or <b>continue</b> statement like Java does but starting from Scala version 2.8, there is a way to break the loops. Click the following links to check the detail.</p>
<table class="src" border="1" cellpadding="5" cellspacing="0">
<tr><th width="30%">Control Statement</th><th>Description</th></tr>
<tr><td><a href="scala_break_statement.html" title="Scala break statement">break statement</a></td><td>Terminates the <b>loop</b> statement and transfers execution to the statement immediately following the loop.</td></tr>
</table>
<h2>The Infinite Loop:</h2>
<p>A loop becomes infinite loop if a condition never becomes false. If you are using Scala, the <b>while</b> loop is the best way to implement infinite loop as follows</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 10;
      // An infinite loop.
      while( true ){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>If you will execute above code, it will go in infinite loop whcih you can terminate by pressing Ctrl + C keys.</p>
<h1>Scala - Loop Types</h1>
<p>A <b>while</b> loop statement repeatedly executes a target statement as long as a given condition is true.</p>
<h2>Syntax:</h2>
<p>The syntax of a while loop in Scala is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
while(condition){
   statement(s);
}
</pre></td></tr>
</table>
<p>Here <b>statement(s)</b> may be a single statement or a block of statements. The <b>condition</b> may be any expression, and true is any nonzero value. The loop iterates while the condition is true. When the condition becomes false, program control passes to the line immediately following the loop.</p>
<h2>Flow Diagram:</h2>
<center>
<img src="../images/scala_while_loop.html" alt="Scala while loop" />
</center>
<p>Here key point of the <i>while</i> loop is that the loop might not ever run. When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.</p>
 <h2>Example:</h2>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      // Local variable declaration:
      var a = 10;

      // while loop execution
      while( a &lt; 20 ){
         println( "Value of a: " + a );
         a = a + 1;
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala do...while Loop</h1>
<p>Unlike <b>while</b> loop, which test the loop condition at the top of the loop, the <b>do...while</b> loop checks its condition at the bottom of the loop. A <b>do...while</b> loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.</p>
<h2>Syntax:</h2>
<p>The syntax of a do...while loop in Scala is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
do{
   statement(s);
}while( condition );
</pre></td></tr>
</table>
<p>Notice that the conditional expression appears at the end of the loop, so the statement(s) in the loop execute once before the condition is tested. If the condition is true, the flow of control jumps back up to do, and the statement(s) in the loop execute again. This process repeats until the  given condition becomes false.</p>
<h2>Flow Diagram:</h2>
<center>
<img src="../images/scala_do_while_loop.html" alt="Scala do...while loop" />
</center>
<h2>Example:</h2>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      // Local variable declaration:
      var a = 10;

      // do loop execution
      do{
         println( "Value of a: " + a );
         a = a + 1;
      }while( a &lt; 20 )
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 10
value of a: 11
value of a: 12
value of a: 13
value of a: 14
value of a: 15
value of a: 16
value of a: 17
value of a: 18
value of a: 19

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala for Loops</h1>
<p>A <b>for</b> loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times. There are various forms of for loop in Scala which are described below:</p>
<h2>The for Loop with Ranges</h2>
<p>The simplest syntax of a for loop in Scala is:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
for( var x &lt;- Range ){
   statement(s);
}
</pre></td></tr>
</table>
<p>Here the <b>Range</b> could be a range of numbers and that is represented as <b>i to j</b> or sometime like <b>i until j</b>. The left-arrow &lt;- operator is called a <i>generator</i>, so named because it's generating individual values from a range.</p>
<h2>Example:</h2>
<p>Following is the example of for loop with range using <b>i to j</b> syntax:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      // for loop execution with a range
      for( a &lt;- 1 to 10){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9
value of a: 10

C:/&gt;
</pre></td></tr>
</table>
<p>Following is the example of for loop with range using <b>i until j</b> syntax:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      // for loop execution with a range
      for( a &lt;- 1 until 10){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9

C:/&gt;
</pre></td></tr>
</table>
<p>You can use multiple ranges separated by semicolon (;) within a <b>for loop</b> and in that case loop will iterate through all the possible computations of the given ranges. Following is an example of using just two ranges, you can use more than two ranges as well.</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      var b = 0;
      // for loop execution with a range
      for( a &lt;- 1 to 3; b &lt;- 1 to 3){
         println( "Value of a: " + a );
         println( "Value of b: " + b );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Value of a: 1
Value of b: 1
Value of a: 1
Value of b: 2
Value of a: 1
Value of b: 3
Value of a: 2
Value of b: 1
Value of a: 2
Value of b: 2
Value of a: 2
Value of b: 3
Value of a: 3
Value of b: 1
Value of a: 3
Value of b: 2
Value of a: 3
Value of b: 3

C:/&gt;
</pre></td></tr>
</table>
<h2>The for Loop with Collections</h2>
<p>The syntax of a for loop with collection is as follows:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
for( var x &lt;- List ){
   statement(s);
}
</pre></td></tr>
</table>
<p>Here the <b>List</b> variable is a collection type having a list of elements and <i>for loop</i> iterate through all the elements returning one element in x variable at a time.</p>
<h2>Example:</h2>
<p>Following is the example of for loop with a collection of numbers. Here we created this collection using <i>List()</i>. We will study collections in a separate chapter.</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6);

      // for loop execution with a collection
      for( a &lt;- numList ){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6

C:/&gt;
</pre></td></tr>
</table>
<h2>The for Loop with Filters</h2>
<p>Scala's for loop allow to filter out some elements using one or more <b>if</b> statement(s). Following is the syntax of <i>for loop</i> along with filters.</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
for( var x &lt;- List
      if condition1; if condition2...
   ){
   statement(s);
}
</pre></td></tr>
</table>
<p>To add more than one filter to a for expression, separate the filters with semicolons(;).</p>
<h2>Example:</h2>
<p>Following is the example of for loop along with filters:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for loop execution with multiple filters
      for( a &lt;- numList
           if a != 3; if a &lt; 8 ){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 1
value of a: 2
value of a: 4
value of a: 5
value of a: 6
value of a: 7

C:/&gt;
</pre></td></tr>
</table>
<h2>The for Loop with yield:</h2>
<p>You can store return values from a for loop in a variable or can return through a function. To do so, you prefix the body of the for expression by the keyword <b>yield</b> as follows:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
var retVal = for{ var x &lt;- List
     if condition1; if condition2...
}yield x
</pre></td></tr>
</table>
<p>Note the curly braces have been used to keep the variables and conditions and <i>retVal</i> is a variable where all the values of x will be stored in the form of collection.</p>
<h2>Example:</h2>
<p>Following is the example to show the usage of for loop along with yield:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for loop execution with a yield
      var retVal = for{ a &lt;- numList 
                        if a != 3; if a &lt; 8
                      }yield a

      // Now print returned values using another loop.
      for( a &lt;- retVal){
         println( "Value of a: " + a );
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
value of a: 1
value of a: 2
value of a: 4
value of a: 5
value of a: 6
value of a: 7

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala break Statement</h1>
<p>As such there is no bulit-in break statement available in Scala but if you are running Scala version 2.8 then there is a way to use <i>break</i> statement. When the <b>break</b> statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop.</p>
<h2>Syntax:</h2>
<p>The syntax of a break statement is bit unusual but it works:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
// import following package
import scala.util.control._

// create a Breaks object as follows
val loop = new Breaks;

// Keep the loop inside breakable as follows
loop.breakable{
    // Loop will go here
    for(...){
       ....
       // Break will go here
       loop.break;
   }
}
</pre></td></tr>
</table>
<h2>Flow Diagram:</h2>
<center>
<img src="../images/scala_break_statement.html" alt="Scala break statement" />
</center>
<h2>Example:</h2>
<table  class="src" cellpadding="5">
<tr><td><pre>
import scala.util.control._

object Test {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      val loop = new Breaks;
      loop.breakable {
         for( a &lt;- numList){
            println( "Value of a: " + a );
            if( a == 4 ){
               loop.break;
            }
         }
      }
      println( "After the loop" );
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Value of a: 1
Value of a: 2
Value of a: 3
Value of a: 4
After the loop

C:/&gt;
</pre></td></tr>
</table>
<h2>Breaking Nested Loops:</h2>
<p>Existing break has an issue while using for nested loops. So in case you have to use break for nested loops then following is a way to proceed:</p>
<h2>Example:</h2>
<table  class="src" cellpadding="5">
<tr><td><pre>
import scala.util.control._

object Test {
   def main(args: Array[String]) {
      var a = 0;
      var b = 0;
      val numList1 = List(1,2,3,4,5);
      val numList2 = List(11,12,13);

      val outer = new Breaks;
      val inner = new Breaks;

      outer.breakable {
         for( a &lt;- numList1){
            println( "Value of a: " + a );
            inner.breakable {
               for( b &lt;- numList2){
                  println( "Value of b: " + b );
                  if( b == 12 ){
                     inner.break;
                  }
               }
            } // inner breakable
         }
      } // outer breakable.
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Value of a: 1
Value of b: 11
Value of b: 12
Value of a: 2
Value of b: 11
Value of b: 12
Value of a: 3
Value of b: 11
Value of b: 12
Value of a: 4
Value of b: 11
Value of b: 12
Value of a: 5
Value of b: 11
Value of b: 12

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Functions</h1>
<p>A function is a group of statements that together perform a task. You can divide up your code into separate functions. How you divide up your code among different functions is up to you, but logically the division usually is so each function performs a specific task.</p>
<p>Scala has both functions and methods and we use the terms method and function interchangeably with a minor difference. A Scala method is a part of a class which has a name, a signature, optionally some annotations, and some bytecode where as a function in Scala is a complete object which can be assigned to a variable. In other words, a function which is defined as a member of some object is called a method.</p>
<p>A function definition can appear anywhere in a source file and Scala permits nested function definitions, that is, function definitions inside other function definitions. Most important point to note is that Scala function's name can have characters like +, ++, ~, &amp;,-, -- , \, /, : etc.</p>
<h2>Function Declarations:</h2>
<p>A scala function declaration has the following form:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
def functionName ([list of parameters]) : [return type]
</pre></td></tr>
</table>
<p>Methods are implicitly declared <i>abstract</i> if you leave off the equals sign and method body. The enclosing type is then itself abstract.</p>
<h2>Function Definitions:</h2>
<p>A scala function definition has the following form:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
def functionName ([list of parameters]) : [return type] = {
   function body
   return [expr]
}
</pre></td></tr>
</table>
<p>Here <b>return type</b> could be any valid scala data type and <b>list of parameters</b> will be a list of variables separated by comma and  list of parameters and return type are optional. Very similar to Java, a <b>return</b> statement can be used along with an expression in case function returns a value. Following is the function which will add two integers and return their sum:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object add{
   def addInt( a:Int, b:Int ) : Int = {
      var sum:Int = 0
      sum = a + b

      return sum
   }
}
</pre></td></tr>
</table>
<p>A function which does not return anything can return <b>Unit</b> which is equivalent to <b>void</b> in Java and indicates that function does not return anything. The functions which do not return anything in Scala, they are called procedures. Following is the syntax</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Hello{
   def printMe( ) : Unit = {
      println("Hello, Scala!")
   }
}
</pre></td></tr>
</table>
<h2>Calling Functions:</h2>
<p>Scala provides a number of syntactic variations for invoking methods. Following is the standard way to call a method:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
functionName( list of parameters )
</pre></td></tr>
</table>
<p>If function is being called using an instance of the object then we would use dot notation similar to Java as follows:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
[instance.]functionName( list of parameters )
</pre></td></tr>
</table>
<p>Following is the final example to define and then calling the same function:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
        println( "Returned Value : " + addInt(5,7) );
   }
   def addInt( a:Int, b:Int ) : Int = {
      var sum:Int = 0
      sum = a + b

      return sum
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Returned Value : 12

C:/&gt;
</pre></td></tr>
</table>
<p>Scala functions are the heart of Scala programming and that's why Scala is assumed as a functional programming language.</p>
<h1>Scala - Closures</h1>
<p>A <b>closure</b> is a function whose return value depends on the value of one or more variables declared outside this function. Consider the following piece of code with anonymous function:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
val multiplier = (i:Int) =&gt; i * 10
</pre></td></tr>
</table>
<p>Here the only variable used in the function body, i * 0, is i, which is defined as a parameter to the function. Now let us take another piece of code:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
val multiplier = (i:Int) =&gt; i * factor
</pre></td></tr>
</table>
<p>There are two free variables in multiplier: <b>i</b> and <b>factor</b>. One of them, i, is a formal parameter to the function. Hence, it is bound to a new value each time multiplier is called. However, <b>factor</b> is not a formal parameter, then what is this? Let us add one more line of code:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
var factor = 3
val multiplier = (i:Int) =&gt; i * factor
</pre></td></tr>
</table>
<p>Now <b>factor</b> has a reference to a variable outside the function but in the enclosing scope. Let us try the following example:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      println( "muliplier(1) value = " +  multiplier(1) )
      println( "muliplier(2) value = " +  multiplier(2) )
   }
   var factor = 3
   val multiplier = (i:Int) =&gt; i * factor
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
muliplier(1) value = 3
muliplier(2) value = 6

C:/&gt;
</pre></td></tr>
</table>
<p>Above function references <b>factor</b> and reads its current value each time. If a function has no external references, then it is trivially closed over itself. No external context is required.</p>
<h1>Scala - Strings</h1>
<p>Consider the following simple example where we assign a string in a variable of type val:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
object Test {
   val greeting: String = "Hello, world!"

   def main(args: Array[String]) {
      println( greeting )
   }
}
</pre></td></tr>
</table>
<p>Here the type of the value above is <b>java.lang.String</b> borrowed from Java, because Scala strings are also Java strings. It is very good point to note that every Java class is available in Scala. As such Scala does not have a String class and makes use of Java Strings. So this chapter has been written keeping Java String as a base.</p>
<p>In Scala, as in Java, a string is an immutable object, that is, an object that cannot be modified. On the other hand, objects that can be modified, like arrays, are called mutable objects. Since strings are very useful objects, in the rest of this section we present the most important methods class java.lang.String defines.</p>
<h2>Creating Strings:</h2>
<p>The most direct way to create a string is to write:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
var greeting = "Hello world!";

or

var greeting:String = "Hello world!";
</pre></td></tr>
</table>
<p>Whenever it encounters a string literal in your code, the compiler creates a String object with its value, in this case, "Hello world!', but if you like you can give String keyword as I have shown you in alternate declaration.</p>

<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   val greeting: String = "Hello, world!"

   def main(args: Array[String]) {
      println( greeting )
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Hello, world!

C:/&gt;
</pre></td></tr>
</table>
<p>As I mentioned earlier, String class is immutable, so that once it is created a String object cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters then you should use <a href="scala_string_builder.html">String Builder</a> Classe available in Scala itself.</p>
<h2>String Length:</h2>
<p>Methods used to obtain information about an object are known as accessor methods. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object.</p>
<p>After the following two lines of code have been executed, len equals 17:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var palindrome = "Dot saw I was Tod";
      var len = palindrome.length();
      println( "String Length is : " + len );
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
String Length is : 17

C:/&gt;
</pre></td></tr>
</table>
<h2>Concatenating Strings:</h2>
<p>The String class includes a method for concatenating two strings:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
string1.concat(string2);
</pre></td></tr>
</table>
<p>This returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
"My name is ".concat("Zara");
</pre></td></tr>
</table>
<p>Strings are more commonly concatenated with the + operator, as in:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
"Hello," + " world" + "!"
</pre></td></tr>
</table>
<p>Which results in:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
"Hello, world!"
</pre></td></tr>
</table>
<p>Let us look at the followinge example:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var str1 = "Dot saw I was ";
      var str2 =  "Tod";
      println("Dot " + str1 + str2);
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Dot saw I was Tod

C:/&gt;
</pre></td></tr>
</table>
<h2>Creating Format Strings:</h2>
<p>You have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object. Let us look at the followinge example which makes use of printf() method:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var floatVar = 12.456
      var intVar = 2000
      var stringVar = "Hello, Scala!"
      var fs = printf("The value of the float variable is " +
                   "%f, while the value of the integer " +
                   "variable is %d, and the string " +
                   "is %s", floatVar, intVar, stringVar)
      println(fs)
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table  class="src" cellpadding="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
The value of the float variable is 12.456000, while the 
value of the integer var iable is 2000, and the 
string is Hello, Scala!()

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Arrays</h1>
<p>Scala provides a data structure, the <b>array</b>, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables. The index of the first element of an array is the number zero and the index of the last element is the total number of elements minus one.</p>
<h2>Declaring Array Variables:</h2>
<p>To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
var z:Array[String] = new Array[String](3)

or

var z = new Array[String](3)

</pre></td></tr>
</table>
<p>Here z is declared as an array of Strings that may hold up to three elements. You can assign values to individual elements or get access to individual elements, it can be done by using commands like the following:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
z(0) = "Zara"; z(1) = "Nuha"; z(4/2) = "Ayan"
</pre></td></tr>
</table>
<p>Here the last example shows that in general the index can be any expression that yields a whole number. There is one more way of defining an array:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
var z = Array("Zara", "Nuha", "Ayan")
</pre></td></tr>
</table>
<p>Following picture represents array myList. Here myList holds ten double values and the indices are from 0 to 9.</p>
<center>
<img src="../images/java_array.jpg" alt="Scala Array" />
</center>
<h2>Processing Arrays:</h2>
<p>When processing array elements, we often use either for loop because all of the elements in an array are of the same type and the size of the array is known. Here is a complete example of showing how to create, initialize and process arrays:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      var myList = Array(1.9, 2.9, 3.4, 3.5)
      
      // Print all the array elements
      for ( x &lt;- myList ) {
         println( x )
      }

      // Summing all elements
      var total = 0.0;
      for ( i &lt;- 0 to (myList.length - 1)) {
         total += myList(i);
      }
      println("Total is " + total);

      // Finding the largest element
      var max = myList(0);
      for ( i &lt;- 1 to (myList.length - 1) ) {
         if (myList(i) > max) max = myList(i);
      }
      println("Max is " + max);
    
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
1.9
2.9
3.4
3.5
Total is 11.7
Max is 3.5

C:/&gt;
</pre></td></tr>
</table>
<h2>Multi-Dimensional Arrays:</h2>
<p>There are many situations where you would need to define and use multi-dimensional arrays (i.e., arrays whose elements are arrays). For example, matrices and tables are examples of structures that can be realized as two-dimensional arrays.</p>
<p>Scala does not directly support multi-dimensional arrays  and provides various methods to process arrays in any dimension. Following is the example of defining a two dimensional array:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
var myMatrix = ofDim[Int](3,3)
</pre></td></tr>
</table>
<p>This is an array that has three elements each being an array of integers that has three elements. The code that follows shows how one can process a multi-dimensional array:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import Array._

object Test {
   def main(args: Array[String]) {
      var myMatrix = ofDim[Int](3,3)
      
      // build a matrix
      for (i &lt;- 0 to 2) {
         for ( j &lt;- 0 to 2) {
            myMatrix(i)(j) = j;
         }
      }
      
      // Print two dimensional array
      for (i &lt;- 0 to 2) {
         for ( j &lt;- 0 to 2) {
            print(" " + myMatrix(i)(j));
         }
         println();
      }
    
   }
}
</pre></td></tr>
</table>
 <p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
0 1 2
0 1 2
0 1 2

C:/&gt;
</pre></td></tr>
</table>
<h2>Concatenate Arrays:</h2>
<p>Following is the example which makes use of concat() method to concatenate two arrays. You can pass more than one arrays as arguments to concat() method.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import Array._

object Test {
   def main(args: Array[String]) {
      var myList1 = Array(1.9, 2.9, 3.4, 3.5)
      var myList2 = Array(8.9, 7.9, 0.4, 1.5)

      var myList3 =  concat( myList1, myList2)
      
      // Print all the array elements
      for ( x &lt;- myList3 ) {
         println( x )
      }
   }
}
</pre></td></tr>
</table>
 <p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
1.9
2.9
3.4
3.5
8.9
7.9
0.4
1.5

C:/&gt;
</pre></td></tr>
</table>
<h2>Create Array with Range:</h2>
<p>Following is the example which makes use of range() method to generate an array containing a sequence of increasing integers in a given range. You can use final argument as step to create the sequence, if you do not use final argument then step would be assumed as 1.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import Array._

object Test {
   def main(args: Array[String]) {
      var myList1 = range(10, 20, 2)
      var myList2 = range(10,20)

      // Print all the array elements
      for ( x &lt;- myList1 ) {
         print( " " + x )
      }
      println()
      for ( x &lt;- myList2 ) {
         print( " " + x )
      }
   }
}
</pre></td></tr>
</table>
 <p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
10 12 14 16 18
10 11 12 13 14 15 16 17 18 19

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Collections</h1>
<p>Scala has a rich set of collection library. Collections are containers of things. Those containers can be sequenced, linear sets of items like List, Tuple, Option, Map etc. The collections may have an arbitrary number of elements or be bounded to zero or
one element (e.g., Option).</p>
<p>Collections may be <b>strict</b> or <b>lazy</b>. Lazy collections have elements that may not consume memory until they are accessed, like <b>Ranges</b>. Additionally, collections may be <b>mutable</b> (the contents of the reference can change) or <b>immutable</b> (the thing that a reference refers to is never changed). Note that immutable collections may contain mutable items.</p>
<p>For some problems, mutable collections work better, and for others, immutable collections work better. When in doubt, it is better to start with an immutable collection and change it later if you need mutable ones.</p>
<p>This chapter gives detail of the most commonly used collection types and  most frequently used operations over those collections.</p>
<table border="1" class="src" width="100%" cellpadding="5" cellspacing="0">
<tr>
<th width="5%">SN</th><th width="95%">Collections with Description</th></tr>
<tr><td>1</td><td><a href="scala_lists.html">Scala Lists</a><br />Scala's List[T] is a linked list of type T.</td></tr>
<tr><td>2</td><td><a href="scala_sets.html">Scala Sets</a><br />A set is a collection of pairwise different elements of the same type.</td></tr>
<tr><td>3</td><td><a href="scala_maps.html">Scala Maps</a><br />A Map is a collection of key/value pairs. Any value can be retrieved based on its key.</td></tr>
<tr><td>4</td><td><a href="scala_tuples.html">Scala Tuples</a><br />Unlike an array or list, a tuple can hold objects with different types.</td></tr>
<tr><td>5</td><td><a href="scala_options.html">Scala Options</a><br />Option[T] provides a container for zero or one element of a given type.</td></tr>
<tr><td>6</td><td><a href="scala_iterators.html">Scala Iterators</a><br />An iterator is not a collection, but rather a way to access the elements of a collection one by one.</td></tr>
</table>

<h2>Example:</h2>
<p>Following code snippet is a simple example to define all the above type of collections:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
// Define List of integers.
val x = List(1,2,3,4)

// Define a set.
var x = Set(1,3,5,7)

// Define a map.
val x = Map("one" -&gt; 1, "two" -&gt; 2, "three" -&gt; 3)

// Create a tuple of two elements.
val x = (10, "Scala")

// Define an option
val x:Option[Int] = Some(5)
</pre></td></tr>
</table>
<h1>Scala - Classes &amp; Objects</h1>
<p>A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword <b>new</b>. Following is a simple syntax to define a class in Scala:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}
</pre></td></tr>
</table>
<p>This class defines two variables <b>x</b> and <b>y</b> and a method: <b>move</b> which does not return a value. Class variables are called, fields of the class and methods are called class methods.</p>
<p>The class name works as a class constructor which can take a number of parameters. The above code defines two constructor arguments, <b>xc</b> and <b>yc</b>; they are both visible in the whole body of the class.</p>
<p>As mentioned ealier, you can create objects using a keywork <b>new</b> and then you can access class fields and methods as shown below in the example:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

object Test {
   def main(args: Array[String]) {
      val pt = new Point(10, 20);

      // Move to a new location
      pt.move(10, 10);
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Point x location : 20
Point y location : 30

C:/&gt;
</pre></td></tr>
</table>
<h2>Extending a Class:</h2>
<p>You can extend a base scala class in similar way you can do it in Java but there are two restrictions: method overriding requires the <b>override</b> keyword, and only the <b>primary</b> constructor can pass parameters to the
base constructor. Let us extend our above class and add one more class method:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println ("Point x location : " + x);
      println ("Point y location : " + y);
      println ("Point z location : " + z);
   }
}
</pre></td></tr>
</table>
<p>Such an <b>extends</b> clause has two effects: it makes class Location inherit all non-private members from class Point, and it makes the type <i>Location</i> a subtype of the type <i>Point</i> class. So here the <i>Point</i> class is called <b>superclass</b> and the class <i>Location</i> is called <b>subclass</b>. Extending a class and inheriting all the features of a parent class is called <b>inheritance</b> but scala allows the inheritance from just one class only. Let us take complete example showing inheirtance:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println ("Point x location : " + x);
      println ("Point y location : " + y);
      println ("Point z location : " + z);
   }
}

object Test {
   def main(args: Array[String]) {
      val loc = new Location(10, 20, 15);

      // Move to a new location
      loc.move(10, 10, 5);
   }
}
</pre></td></tr>
</table>
<p>Note that methods move and <b>move</b> do not override the corresponding definitions of move since they are different definitions (for example, the former take two arguments while the latter take three arguments). When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Point x location : 20
Point y location : 30
Point z location : 20

C:/&gt;
</pre></td></tr>
</table>
<h2>Singleton objects:</h2>
<p>Scala is more object-oriented than Java because in Scala we cannot have static members. Instead, Scala has <b>singleton objects</b>. A singleton is a class that can have only one instance ie. object. You create singleton using the keyword <b>object</b> instead of class keyword. Since you can't instantiate a singleton object, you can't pass parameters to the primary constructor. You already have seen all the examples using singleton objects where you called Scala's main method. Following is the same example of showing singleton:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
   }
}

object Test {
   def main(args: Array[String]) {
      val point = new Point(10, 20)
      printPoint

      def printPoint{
         println ("Point x location : " + point.x);
         println ("Point y location : " + point.y);
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Point x location : 10
Point y location : 20

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Traits</h1>
<p>A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits.</p>
<p>Traits are used to define object types by specifying the signature of the supported methods. Scala also allows traits to be partially implemented but traits may not have constructor parameters.</p>
<p>A trait definition looks just like a class definition except that it uses the keyword <b>trait</b> as follows:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
trait Equal {
  def isEqual(x: Any): Boolean
  def isNotEqual(x: Any): Boolean = !isEqual(x)
}
</pre></td></tr>
</table>
<p>This trait consists of two methods <b>isEqual</b> and <b>isNotEqual</b>. Here we have not given any implementation for isEqual where as another method has its implementation. Child classes extending a trait can give implementation for the un-implemented methods. So a trait is very similar to what we have <b>abstract classes</b> in Java. Below is a complete example to show the concept of traits:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
trait Equal {
  def isEqual(x: Any): Boolean
  def isNotEqual(x: Any): Boolean = !isEqual(x)
}

class Point(xc: Int, yc: Int) extends Equal {
  var x: Int = xc
  var y: Int = yc
  def isEqual(obj: Any) =
    obj.isInstanceOf[Point] &amp;&amp;
    obj.asInstanceOf[Point].x == x
}

object Test {
   def main(args: Array[String]) {
      val p1 = new Point(2, 3)
      val p2 = new Point(2, 4)
      val p3 = new Point(3, 3)

      println(p1.isNotEqual(p2))
      println(p1.isNotEqual(p3))
      println(p1.isNotEqual(2))
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
false
true
true

C:/&gt;
</pre></td></tr>
</table>
<h2>When to use traits?</h2>
<p>There is no firm rule, but here are few guidelines to consider:</p>
<ul>
<li><p>If the behavior will not be reused, then make it a concrete class. It is not reusable behavior after all.</p></li>
<li><p>If it might be reused in multiple, unrelated classes, make it a trait. Only traits can be mixed into different parts of the class hierarchy.</p></li>
<li><p>If you want to inherit from it in Java code, use an abstract class.</p></li>
<li><p>If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.</p></li>
<li><p>If efficiency is very important, lean towards using a class.</p></li>
</ul>
<h1>Scala - Pattern Matching</h1>
<p>Pattern matching is the second most widely used feature of Scala, after function values and closures. Scala provides great support for pattern matching for processing the messages.</p>
<p>A pattern match includes a sequence of alternatives, each starting with the keyword <b>case</b>. Each alternative includes a <b>pattern</b> and one or more <b>expressions</b>, which will be evaluated if the pattern matches. An arrow symbol =&gt; separates the pattern from the expressions. Here is a small example which shows how to match against an integer value:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      println(matchTest(3))

   }
   def matchTest(x: Int): String = x match {
      case 1 =&gt; "one"
      case 2 =&gt; "two"
      case _ =&gt; "many"
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
many

C:/&gt;
</pre></td></tr>
</table>
<p>The block with the case statements defines a function which maps integers to strings. The match keyword provides a convenient way of applying a function (like the pattern matching function above) to an object. Following is a second example which matches a value against patterns of different types:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      println(matchTest("two"))
      println(matchTest("test"))
      println(matchTest(1))

   }
   def matchTest(x: Any): Any = x match {
      case 1 =&gt; "one"
      case "two" =&gt; 2
      case y: Int =&gt; "scala.Int"
      case _ =&gt; "many"
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
2
many
one

C:/&gt;
</pre></td></tr>
</table>
<p>The first case matches if x refers to the integer value 1. The second case matches if x is equal to the string"two". The third case consists of a typed pattern; it matches against any integer and binds the selector value xto the variable y of type integer. Following is another form of writing same match...case expressions with the help of braces {...}:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      println(matchTest("two"))
      println(matchTest("test"))
      println(matchTest(1))

   }
   def matchTest(x: Any){
      x match {
         case 1 =&gt; "one"
         case "two" =&gt; 2
         case y: Int =&gt; "scala.Int"
         case _ =&gt; "many"
      }
   }
}
</pre></td></tr>
</table>
<h2>Matching Using case Classes:</h2>
<p>The <b>case classes</b> are special classes that are used in pattern matching with case expressions. Syntactically, these are standard classes with a special modifier: <b>case</b>. Following is a simple pattern matching example using case class:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
   	val alice = new Person("Alice", 25)
	   val bob = new Person("Bob", 32)
   	val charlie = new Person("Charlie", 32)
   
      for (person &lt;- List(alice, bob, charlie)) {
         person match {
            case Person("Alice", 25) =&gt; println("Hi Alice!")
            case Person("Bob", 32) =&gt; println("Hi Bob!")
            case Person(name, age) =&gt;
               println("Age: " + age + " year, name: " + name + "?")
         }
      }
   }
   // case class, empty one.
   case class Person(name: String, age: Int)
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Hi Alice!
Hi Bob!
Age: 32 year, name: Charlie?

C:/&gt;
</pre></td></tr>
</table>
<p>Adding the case keyword causes the compiler to add a number of useful features automatically. The keyword suggests an association with case expressions in pattern matching.</p>
<p>First, the compiler automatically converts the constructor arguments into immutable fields (vals). The val keyword is optional. If you want mutable fields, use the var keyword. So, our constructor argument lists are now shorter.</p>
<p>Second, the compiler automatically implements <b>equals, hashCode,</b> and <b>toString</b> methods to the class, which use the fields specified as constructor arguments. So, we no longer need our own toString methods.</p>
<p>Finally, Also, the body of <b>Person</b> class is gone because there are no methods that we need to define!</p>
<h1>Scala - Regular Expressions</h1>
<p>Scala supports regular expressions through <b>Regex</b> classe available in the scala.util.matching package. Let us check an example where we wil try to find out word <b>Scala</b> from a statement:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = "Scala".r
      val str = "Scala is Scalable and cool"
      
      println(pattern findFirstIn str)
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Some(Scala)

C:/&gt;
</pre></td></tr>
</table>
<p>We create a String and call the <b>r( )</b> method on it. Scala implicitly converts the String to a RichString and invokes that method to get an instance of Regex. To find a first match of the regular expression, simply call the <b>findFirstIn()</b> method. If instead of finding only the first occurrence we would like to find all occurrences of the matching word, we can use the <b>findAllIn( )</b> method and in case there are multiple Scala words available in the target string, this will return a collection of all matching words.</p>
<p>You can make use of the mkString( ) method to concatenate the resulting list and you can use a pipe (|) to search small and capital case of Scala and you can use <b>Regex</b> constructor instead or <b>r()</b> method to create a pattern as follows:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = new Regex("(S|s)cala")
      val str = "Scala is scalable and cool"
      
      println((pattern findAllIn str).mkString(","))
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Scala,scala

C:/&gt;
</pre></td></tr>
</table>
<p>If you would like to replace matching text, we can use <b>replaceFirstIn( )</b> to replace the first match or <b>replaceAllIn( )</b> to replace  all occurrences as follows:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      val pattern = "(S|s)cala".r
      val str = "Scala is scalable and cool"
      
      println(pattern replaceFirstIn(str, "Java"))
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Java is scalable and cool

C:/&gt;
</pre></td></tr>
</table>
<h2>Forming regular expressions:</h2>
<p>Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl. Here are just some examples that should be enough as refreshers:</p>
<p>Here is the table listing down all the regular expression metacharacter syntax available in Java:</p>
<table border="1" class="src" width="100%" cellpadding="5" cellspacing="0">
<tr>
<th width="25%">Subexpression</th><th width="95%">Matches</th></tr>
<tr><td>^</td><td>Matches beginning of line.</td></tr>
<tr><td>$</td><td>Matches end of line.</td></tr>
<tr><td>.</td><td>Matches any single character except newline. Using m option allows it to match
newline as well.</td></tr>
<tr><td>[...]</td><td>Matches any single character in brackets.</td></tr>
<tr><td>[^...]</td><td>Matches any single character not in brackets</td></tr>
<tr><td>\\A</td><td>Beginning of entire string</td></tr>
<tr><td>\\z</td><td>End of entire string</td></tr>
<tr><td>\\Z</td><td>End of entire string except allowable final line terminator.</td></tr>
<tr><td>re*</td><td>Matches 0 or more occurrences of preceding expression.</td></tr>
<tr><td>re+</td><td>Matches 1 or more of the previous thing</td></tr>
<tr><td>re?</td><td>Matches 0 or 1 occurrence of preceding expression.</td></tr>
<tr><td>re{ n}</td><td>Matches exactly n number of occurrences of preceding expression.</td></tr>
<tr><td>re{ n,}</td><td>Matches n or more occurrences of preceding expression.</td></tr>
<tr><td>re{ n, m}</td><td>Matches at least n and at most m occurrences of preceding expression.</td></tr>
<tr><td>a|b</td><td>Matches either a or b.</td></tr>
<tr><td>(re)</td><td>Groups regular expressions and remembers matched text.</td></tr>
<tr><td>(?: re)</td><td>Groups regular expressions without remembering matched text.</td></tr>
<tr><td>(?&gt; re)</td><td>Matches independent pattern without backtracking.</td></tr>
<tr><td>\\w</td><td>Matches word characters.</td></tr>
<tr><td>\\W</td><td>Matches nonword characters.</td></tr>
<tr><td>\\s</td><td>Matches whitespace. Equivalent to [\t\n\r\f].</td></tr>
<tr><td>\\S</td><td>Matches nonwhitespace.</td></tr>
<tr><td>\\d</td><td>Matches digits. Equivalent to [0-9].</td></tr>
<tr><td>\\D</td><td>Matches nondigits.</td></tr>
<tr><td>\\A</td><td>Matches beginning of string.</td></tr>
<tr><td>\\Z</td><td>Matches end of string. If a newline exists, it matches just before newline.</td></tr>
<tr><td>\\z</td><td>Matches end of string.</td></tr>
<tr><td>\\G</td><td>Matches point where last match finished.</td></tr>
<tr><td>\\n</td><td>Back-reference to capture group number "n"</td></tr>
<tr><td>\\b</td><td>Matches word boundaries when outside brackets. Matches backspace (0x08) when inside brackets.</td></tr>
<tr><td>\\B</td><td>Matches nonword boundaries.</td></tr>
<tr><td>\\n, \\t, etc.</td><td>Matches newlines, carriage returns, tabs, etc.</td></tr>
<tr><td>\\Q</td><td>Escape (quote) all characters up to \\E</td></tr>
<tr><td>\\E</td><td>Ends quoting begun with \\Q</td></tr>
</table>
<h2>Regular-expression Examples:</h2>
<table class="src" cellpadding="5" cellspacing="5" border="1">
<tr><th width="25%">Example</th><th>Description</th></tr>
<tr><td>.</td><td>Match any character except newline</td></tr>
<tr><td>[Rr]uby</td><td>Match "Ruby" or "ruby"</td></tr>
<tr><td>rub[ye]</td><td>Match "ruby" or "rube"</td></tr>
<tr><td>[aeiou]</td><td>Match any one lowercase vowel</td></tr>
<tr><td>[0-9] </td><td>Match any digit; same as [0123456789]</td></tr>
<tr><td>[a-z]</td><td>Match any lowercase ASCII letter</td></tr>
<tr><td>[A-Z]</td><td>Match any uppercase ASCII letter</td></tr>
<tr><td>[a-zA-Z0-9]</td><td>Match any of the above</td></tr>
<tr><td>[^aeiou]</td><td>Match anything other than a lowercase vowel</td></tr>
<tr><td>[^0-9]</td><td>Match anything other than a digit</td></tr>
<tr><td>\\d</td><td>Match a digit: [0-9]</td></tr>
<tr><td>\\D</td><td>Match a nondigit: [^0-9]</td></tr>
<tr><td>\\s</td><td>Match a whitespace character: [ \t\r\n\f]</td></tr>
<tr><td>\\S</td><td>Match nonwhitespace: [^ \t\r\n\f]</td></tr>
<tr><td>\\w</td><td>Match a single word character: [A-Za-z0-9_]</td></tr>
<tr><td>\\W</td><td>Match a nonword character: [^A-Za-z0-9_]</td></tr>
<tr><td>ruby?</td><td>Match "rub" or "ruby": the y is optional</td></tr>
<tr><td>ruby*</td><td>Match "rub" plus 0 or more ys</td></tr>
<tr><td>ruby+</td><td>Match "rub" plus 1 or more ys</td></tr>
<tr><td>\\d{3}</td><td>Match exactly 3 digits</td></tr>
<tr><td>\\d{3,}</td><td>Match 3 or more digits</td></tr>
<tr><td>\\d{3,5}</td><td>Match 3, 4, or 5 digits</td></tr>
<tr><td>\\D\\d+</td><td>No group: + repeats \\d</td></tr>
<tr><td>(\\D\\d)+/ </td><td>Grouped: + repeats \\D\d pair</td></tr>
<tr><td>([Rr]uby(, )?)+</td><td>Match "Ruby", "Ruby, ruby, ruby", etc.</td></tr>
</table>
<p>Note that, every backslash appears twice in the string above. This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string. So instead of .\. you need to write .\\. to get a single backslash in the string. Check the following example:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import scala.util.matching.Regex

object Test {
   def main(args: Array[String]) {
      val pattern = new Regex("abl[ae]\\d+")
      val str = "ablaw is able1 and cool"
      
      println((pattern findAllIn str).mkString(","))
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
able1

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Exception Handling</h1>
<p>Scala's exceptions works like exceptions in many other languages like Java. Instead of returning a value in the normal way, a method can terminate by throwing an exception. However, Scala doesn't actually have checked exceptions.</p>
<p>When you want to handle exceptions you use a try{...}catch{...} block like you would in Java except that the catch block uses matching to identify and handle the exceptions.</p>
<h2>Throwing exceptions:</h2>
<p>Throwing an exception looks the same as in Java. You create an exception object and then you throw it with the <b>throw</b> keyword:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
throw new IllegalArgumentException
</pre></td></tr>
</table>
<h2>Catching exceptions:</h2>
<p>Scala allows you to <b>try/catch</b> any exception in a single block and then perform pattern matching against it using <b>case</b> blocks as shown below:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

object Test {
   def main(args: Array[String]) {
      try {
         val f = new FileReader("input.txt")
      } catch {
         case ex: FileNotFoundException =>&gt;{
            println("Missing file exception")
         }
         case ex: IOException =&gt; {
            println("IO Exception")
         }
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Missing file exception

C:/&gt;
</pre></td></tr>
</table>
<p>The behavior of this <b>try-catch</b> expression is the same as in other languages with exceptions. The body is executed, and if it throws an exception, each <b>catch</b> clause is tried in turn.</p>
<h2>The finally clause:</h2>
<p>You can wrap an expression with a <b>finally</b> clause if you want to cause some code to execute no matter how the expression terminates.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException

object Test {
   def main(args: Array[String]) {
      try {
         val f = new FileReader("input.txt")
      } catch {
         case ex: FileNotFoundException =&gt; {
            println("Missing file exception")
         }
         case ex: IOException =&gt; {
            println("IO Exception")
         }
      } finally {
         println("Exiting finally...")
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Missing file exception
Exiting finally...

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Extractors</h1>
<p>An extractor in Scala is an object that has a method called <b>unapply</b> as one of its members. The purpose of that unapply method is to match a value and take it apart. Often, the extractor object also defines a dual method <b>apply</b> for building values, but this is not required.</p>
<p>Following example shows an extractor object for email addresses:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      
      println ("Apply method : " + apply("Zara", "gmail.com"));
      println ("Unappy method : " + unapply("Zara@gmail.com"));
      println ("Unappy method : " + unapply("Zara Ali"));

   }
   // The injection method (optional)
   def apply(user: String, domain: String) = {
      user +"@"+ domain
   }

   // The extraction method (mandatory)
   def unapply(str: String): Option[(String, String)] = {
      val parts = str split "@"
      if (parts.length == 2){
         Some(parts(0), parts(1)) 
      }else{
         None
      }
   }
}
</pre></td></tr>
</table>
<p>This object defines both <b>apply</b> and <b>unapply</b> methods. The apply method has the same meaning as always: it turns Test into an object that can be applied to arguments in parentheses in the same way a method is applied. So you can write Test("Zara", "gmail.com") to construct the string "Zara@gmail.com".</p>
<p>The <b>unapply</b> method is what turns Test class into an <b>extractor</b> and it reverses the construction process of <b>apply</b>. Where apply takes two strings and forms an email address string out of them, unapply takes an email address and returns potentially two strings: the <b>user</b> and the <b>domain</b> of the address.</p>
<p>The <b>unapply</b> must also handle the case where the given string is not an email address. That's why unapply returns an Option-type over pairs of strings. Its result is either <b>Some(user, domain)</b> if the string str is an email address with the given user and domain parts, or None, if str is not an email address. Here are some examples:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
unapply("Zara@gmail.com") equals Some("Zara", "gmail.com")
unapply("Zara Ali") equals None
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
Apply method : Zara@gmail.com
Unappy method : Some((Zara,gmail.com))
Unappy method : None

C:/&gt;
</pre></td></tr>
</table>
<h2>Pattern Matching with Extractors:</h2>
<p>When an instance of a class is followed by parentheses with a list of zero or more parameters, the compiler invokes the <b>apply</b> method on that instance. We can define apply both in objects and in classes.</p>
<p>As mentioned above, the purpose of the <b>unapply</b> method is to extract a specific value we are looking for. It does the opposite operation <b>apply</b> does. When comparing an extractor object using the <b>match</b> statement the <b>unapply</b> method will be automatically executed as shown below:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      
      val x = Test(5)
      //apply is invoked... the value 10 is returend
      println(x)

      x match
      {
         case Test(num) =&gt; println(x+" is bigger two times than "+num)
         //unapply is invoked
         case _ =&gt; println("i cannot calculate")
      }

   }
   def apply(x: Int) = x*2
   def unapply(z: Int): Option[Int] = if (z%2==0) Some(z/2) else None
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it produces following result:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
10
10 is bigger two times than 5

C:/&gt;
</pre></td></tr>
</table>
<h1>Scala - Files I/O</h1>
<p>Scala is open to make use of any Java objects and <b>java.io.File</b> is one of the object which can be used in Scala programming to read and write files. Following is an example of writing to a file:</p> 
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import java.io._

object Test {
   def main(args: Array[String]) {
      val writer = new PrintWriter(new File("test.txt" ))

      writer.write("Hello Scala")
      writer.close()
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it creates a file with "Hello Scala" content which you can check yourself.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test

C:/&gt;
</pre></td></tr>
</table>
<h2>Reading line from Screen:</h2>
<p>Sometime you need to read user input from the screen and then proceed for some further processing. Following example shows you how to read input from the screen:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
object Test {
   def main(args: Array[String]) {
      print("Please enter your input : " )
      val line = Console.readLine
      
      println("Thanks, you just typed: " + line)
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it prompts you to enter your input and it continues until you press ENTER key.</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
scala Test
Please enter your input : Scala is great
Thanks, you just typed: Scala is great

C:/&gt;
</pre></td></tr>
</table>
<h2>Reading File Content:</h2>
<p>Reading from files is really simple. You can use Scala's <b>Source</b> class and its companion object to read files. Following is the example which shows you how to read from "test.txt" file which we created ealier:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
import scala.io.Source

object Test {
   def main(args: Array[String]) {
      println("Following is the content read:" )

      Source.fromFile("test.txt" ).foreach{ 
         print 
      }
   }
}
</pre></td></tr>
</table>
<p>When the above code is compiled and executed, it will read test.txt file and display the content on the screen:</p>
<table class="src" cellpadding="5" cellspacing="5">
<tr><td><pre>
C:/&gt;scalac Test.scala
C:/&gt;scala Test
scala Test
Following is the content read:
Hello Scala

C:/&gt;
</pre></td></tr>
</table>
<br />
<hr />
<a href="scala_file_io.html"><img alt="previous" border="0" src="../images/previous.gif" /></a>
<a href="scala_useful_resources.html"><img alt="next" border="0" src="../images/next.gif" /></a>
<a href='../cgi-bin/printversion27a3.html?tutorial=scala&amp;file=scala_quick_guide.htm' target="_blank">
<img src="../images/print.gif" alt="Printer Friendly" border="0" /></a>
<br />
<hr />
<!-- PRINTING ENDS HERE -->
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text_image";
google_ad_channel ="9030538898";
google_color_border="ffffff";
google_color_link="900b09";
google_color_url="000000";
google_color_text="000000";
//--></script>
<script type="text/javascript" src="../../pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</td></tr>
</table>
</td>
<td class="right" align="center" valign="top">
<br /><br />
<table width="100%" cellpadding="0" cellspacing="0">
<tr valign="middle">
<td  class="top" style="border:0px;">
&nbsp;&nbsp;
</td>
</tr>
</table>
<table class="right"  cellpadding="0" cellspacing="0">
<tr>
<td align="center" class="right">
<p>
<u>Advertisements</u>
</p>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
  src="../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br /><br /></td></tr></table>
</td></tr></table>
</center>
</body>

<!-- Mirrored from www.tutorialspoint.com/scala/scala_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
</html>
