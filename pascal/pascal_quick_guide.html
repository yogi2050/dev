<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/pascal/pascal_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>Pascal Quick Guide</title>
<link rel="shortcut icon" href="../favicon.png" type="image/x-icon" />
<meta name="description" content="Pascal Quick Guide for Beginners - Learn turbo pascal in simple and easy steps starting with pascal syntax, data types, gloabl and local variables, units, functions, loops, constants, structure, arrays, enumeration, sets, records, files, variant records, pointers, linked lists and text processing." />
<meta name="keywords" content="Pascal, Tutorials, Learning, Beginners, Basics,  Data Types, Gloabl and Local Variables, Units, Procedures, Loops, Constants, Structure, Arrays, Enumeration, Sets, Records, Files, Variant Records, Pointers, Linked Lists, Text processing." />
<base  />
<link rel="stylesheet" type="text/css" href="../scripts/style.css" />
<link rel="stylesheet" type="text/css" href="../scripts/prettify.css" />
<script type="text/javascript" src="../scripts/prettify.js"></script>
<style media="screen" type="text/css">
/* Pascal Scheme */
#header{ 
   background:#fe8a8b !important;
}
#topmenu
{
   background-color:#423c46 !important;
}
#leftcol ul.menu li.heading 
{
   background:#fe8a8b !important;
   border:1px solid #423c46 !important;
}
#leftcol, #middlecol, #rightcol {min-height:1250px; padding:0px;}
</style>
<script src="../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
   _uacct = "UA-232293-6";
   urchinTracker();
</script>
</head>
<body onload="prettyPrint()">
<div id="header">
<div class="wrapper">
<h1 class="logo"><a href="../index-2.html">Tutorials Point Simply Easy Learning</a></h1>
<div id="search">
<form method="get" id="searchform" name="searchform" action="http://www.google.com/search" target="_blank">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com"/>
<input type="text" name="as_q" id="s" value="Search this site..." onfocus="if (this.value == 'Search this site...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search this site...';}"/>
<input value="FORID:11" name="cof" type="hidden"/>
<input type="hidden" name="ie" value="ISO-8859-1" />
<input class="submit btn" type="image" src="../images/icon-search.png" alt="Go"/>
</form>
</div>
</div>
</div>
<div id="topmenu">
<div class="wrapper">
<div id="left">
<a href="../index-2.html" target="_top">HOME </a>
<a href="../java/index.html" target="_top">JAVA </a>
<a href="../php/index.html" target="_top">PHP </a>
<a href="../python/index.html" target="_top">Python </a>
<a href="../ruby/index.html" target="_top">Ruby </a>
<a href="../perl/index.html" target="_top">Perl </a>
<a href="../html/index.html" target="_top">HTML </a>
<a href="../css/index.html" target="_top">CSS </a>
<a href="../javascript/index.html" target="_top">Javascript </a>
<a href="../mysql/index.html" target="_top">MySQL </a>
<a href="../cplusplus/index.html" target="_top">C++ </a>
<a href="../unix/index.html" target="_top">UNIX </a>
<a href="../more.html" target="_top">MORE...</a>
</div>
<div id="right">
<a href="../references.html" target="_top">REFERENCES</a> |
<a href="../forums/index.html" target="_top">FORUM</a> |
<a href="../about/index.html" target="_top">ABOUT</a> |
<a href="../about/contact_us.html" target="_top">CONTACT</a>
</div>
</div>
</div>
<div class="wrapper">
<div id="leftcol">
<div class="mini-logo">
<img src="../images/pascal-mini.png" alt="Pascal tutorial" />
</div>
<ul class="menu">
<li class="heading">Pascal Basics</li>
<li><a target="_top" href="index.html">Pascal - Home</a></li>
<li><a target="_top" href="pascal_overview.html">Pascal - Overview</a></li>
<li><a target="_top" href="pascal_environment_setup.html">Pascal - Environment</a></li>
<li><a target="_top" href="pascal_program_structure.html">Pascal - Program Structure</a></li>
<li><a target="_top" href="pascal_basic_syntax.html">Pascal - Basic Syntax</a></li>
<li><a target="_top" href="pascal_data_types.html">Pascal - Data Types</a></li>
<li><a target="_top" href="pascal_variable_types.html">Pascal - Variable Types</a></li>
<li><a target="_top" href="pascal_constants.html">Pascal - Constants</a></li>
<li><a target="_top" href="pascal_operators.html">Pascal - Operators</a></li>
<li><a target="_top" href="pascal_decision_making.html">Pascal - Decision Making</a></li>
<li><a target="_top" href="pascal_loops.html">Pascal - Loops </a></li>
<li><a target="_top" href="pascal_functions.html">Pascal - Functions</a></li>
<li><a target="_top" href="pascal_procedures.html">Pascal - Procedures</a></li>
<li><a target="_top" href="pascal_variable_scope.html">Pascal - Variable Scope</a></li>
<li><a target="_top" href="pascal_strings.html">Pascal - Strings</a></li>
<li><a target="_top" href="pascal_booleans.html">Pascal - Booleans</a></li>
<li><a target="_top" href="pascal_arrays.html">Pascal - Arrays</a></li>
<li><a target="_top" href="pascal_pointers.html">Pascal - Pointers</a></li>
<li><a target="_top" href="pascal_records.html">Pascal - Records</a></li>
<li><a target="_top" href="pascal_variants.html">Pascal - Variants</a></li>
<li><a target="_top" href="pascal_sets.html">Pascal - Sets</a></li>
<li><a target="_top" href="pascal_files_handling.html">Pascal - File Handling</a></li>
<li><a target="_top" href="pascal_memory.html">Pascal - Memory</a></li>
<li><a target="_top" href="pascal_units.html">Pascal - Units</a></li>
<li><a target="_top" href="pascal_date_time.html">Pascal - Date &amp; Time</a></li>
<li><a target="_top" href="pascal_object_oriented.html">Pascal - Objects </a></li>
<li><a target="_top" href="pascal_classes.html">Pascal - Classes</a></li>
</ul>
<ul class="menu">
<li class="heading">Pascal  Useful Resources</li>
<li><a target="_top" href="pascal_quick_guide.html">Pascal - Quick Guide</a></li>
<li><a target="_top" href="pascal_useful_resources.html"><b>Pascal - Useful Resources</b></a></li>
</ul>
<ul class="menu">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</div><!-- leftcol -->
<div id="middlecol">
<!-- PRINTING STARTS HERE -->
<div class="content">
<h1>Pascal - Quick Guide</h1>
<div class="topgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="pascal_classes.html">Previous Page</a>
</div>
<div class="nxt-btn">
<a href="pascal_useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
<p>Pascal is a general purpose high level language that was originally developed by Nicklaus Wirth in the early 1970s. It was developed for teaching programming as a systematic discipline and to develop reliable and efficient programs. </p>
<p>Pascal is Algol based language and includes many constructs of Algol. Algol 60 is a subset of Pascal. Pascal offers several data types and programming structures. It is easy to understand and maintain the Pascal programs.</p>
<p>Pascal has grown in popularity in the teaching and academics arena for various reasons:</p>
<ul class="list">
<li><p>Easy to learn.</p></li>
<li><p>Structured language.</p></li>
<li><p>It produces transparent, efficient and reliable programs.</p></li>
<li><p>It can be compiled on a variety of computer platforms.</p></li>
</ul>
<h1>Pascal - Environment Set Up</h1>
<p>We will be using Free Pascal in these tutorials. You can download Free Pascal for your operating system from the link: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/download.var">Download Free Pascal</a></p>
<h2>Installing Free Pascal on Linux </h2>
<p>The linux distribution of Free Pascal comes in three forms: </p>
<ul class="list">
<li><p>a <b>tar.gz</b> version, also available as separate files.</p></li>
<li><p>a <b>.rpm</b> (Red Hat Package Manager) version</p></li>
<li><p>a <b>.deb</b> (Debian) version.</p></li>
</ul>
<p>Installation code for the .rpm version:: </p>
<pre class="prettyprint">
rpm -i fpc-X.Y.Z-N.ARCH.rpm
</pre>
<p>Where X.Y.Z is the version number of the .rpm file, and ARCH is one of the supported architectures (i386, x86_64 etc.). </p>
<p>Installation code for the Debian version(like Ubuntu): </p>
<pre class="prettyprint">
dpkg -i fpc-XXX.deb
</pre>
<p>Where XXX is the  version number of the .deb file. </p>
<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu5.html">Free Pascal Installation Guide</a></p>
<h2>Installing Free Pascal on Mac</h2>
<p>If you use Mac OS X, the easiest way to use Free Pascal is to download the Xcode development environment from Apple's web site and follow the simple installation instructions. Once you have Xcode setup, you will be able to use the Free Pascal compiler.  </p>
<h2>Installing Free Pascal on Windows </h2>
<p>For Windows, you will download the Windows installer, setup.exe. This is a usual installation program. 
You need to take the following steps for installation: </p>
<ul class="list">
<li><p>Select a directory.</p></li>
<li><p>Select parts of the package you want to install.</p></li>
<li><p>Optionally choose to associate the .pp or .pas extensions with the Free Pascal IDE.</p></li>
</ul>
<p>For details read: <a rel="nofollow" target="_blank" href="http://www.freepascal.org/docs-html/user/usersu3.html">Free Pascal Installation Guide</a></p>
<h2>Pascal Program Structure</h2>
<p>A Pascal program basically consists of the following parts:</p>
<ul class="list">
<li><p>Program name</p></li>
<li><p>Uses command</p></li>
<li><p>Type declarations</p></li>
<li><p>Constant declarations</p></li>
<li><p>Variables declarations</p></li>
<li><p>Functions declarations</p></li>
<li><p>Procedures declarations</p></li>
<li><p>Main program block</p></li>
<li><p>Statements and Expressions within each blocks</p></li>
<li><p>Comments</p></li>
</ul>
<p>Every pascal program generally have a heading statement, a declaration and an execution part strictly in that order. Following format shows the basic syntax for a Pascal program:</p>
<pre class="prettyprint">
program {name of the program}
uses {comma delimited names of libraries you use}
const {global constant declaration block}
var {global variable declaration block}

function {function declarations, if any}
{ local variables }
begin
...
end;

procedure { procedure declarations, if any}
{ local variables }
begin
...
end;

begin { main program block starts}
...
end. { the end of main program block }
</pre>
<h2>Pascal Hello World Example</h2>
<p>Following is a simple pascal code that would print the words "Hello, World!":</p>
<pre class="prettyprint">
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
   writeln('Hello, World!');
   readkey;
end. 
</pre>
<h2> Compile and Execute Pascal Program:</h2>
<ul class="list">
<li><p>Open a text editor and add the above mentioned code.</p></li>
<li><p>Save the file as <i>hello.pas</i></p></li>
<li><p>Open a command prompt and go to the directory where you saved the file.</p></li>
<li><p>Type fpc hello.pas at command prompt and press enter to compile your code.</p></li>
<li><p>If there are no errors in your code the command prompt will take you to the next line and would generate <b>hello</b> executable file and <b>hello.o</b> object file.</p></li>
<li><p>Now type <b>hello</b> at command prompt to execute your program.</p></li>
<li><p>You will be able to see "Hello World" printed on the screen and program waits till you press any key.</p></li>
</ul>
<pre class="result">
$ fpc hello.pas
Free Pascal Compiler version 2.6.0 [2011/12/23] for x86_64
Copyright (c) 1993-2011 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling hello.pas
Linking hello
8 lines compiled, 0.1 sec

$ ./hello
Hello, World!
</pre>
<h1>Pascal - Basic Syntax</h1>
<p>You have seen a basic structure of pascal program, so it will be easy to understand other basic building blocks of the pascal programming language.</p>
<h2>Variables</h2>
<p>A variable definitions are put in a block beginning with a <b>var</b> keyword, followed by definitions of the variables as follows:</p>
<pre class="prettyprint">
var
A_Variable, B_Variable ... : Variable_Type;
</pre>
<p>Pascal variables are declared outside the code-body of the function which means they are not declared within the <b>begin</b> and <b>end</b> pairs, but they are declared after the definition of the procedure/function and before the <b>begin</b> keyword. For global variables, they are defined after the program header.</p>
<h2>Functions/Procedures</h2>
<p>In pascal a <b>procedure</b> is set of instructions to be executed, with no return value and a <b>function</b> is a procedure with a return value. The definition of function/procedures will be as follows:</p>
<pre class="prettyprint">
Function Func_Name(params...) : Return_Value;
Procedure Proc_Name(params...);
</pre>
<h2>Comments</h2>
<p>The multiline comments are enclosed within curly brackets and asterisks as {* ... *}. Pascal allows single line comment enclosed within curly brackets { ... }. </p>
<pre class="prettyprint">
{* This is a multi-line comments
   and it will span multiple lines. *}

{ This is a single line comment in pascal }
</pre>
<h2>Case Sensitivity</h2>
<p>Pascal is a case nonsensitive language which mean you can write your variables, functions and procedure in either case. Like variables A_Variable, a_variable and A_VARIABLE have same meaning in Pascal.</p>
<h2>Pascal Statements </h2>
<p>Pascal programs are made of statements. Each statement specifies a definite job of the program. These jobs could be declaration, assignment, reading data, writing data, taking logical decisions, transferring program flow control, etc. </p>
<p> For example:</p>
<pre class="prettyprint">
readln (a, b, c);
s := (a + b + c)/2.0;
area := sqrt(s * (s - a)*(s-b)*(s-c));
writeln(area);        
</pre>
<h2> Reserved Words in Pascal </h2>
<p>The statements in Pascal are designed with some specific Pascal words, which are called the reserved words.  For example, the words, program, input, output, var, real, begin, readline, writeline and end are all reserved words. 
Following is a list of reserved words available in Pascal.</p>
<table class="src">
<tr><td>and</td><td>array</td><td>begin</td><td>case</td><td>const</td></tr>
<tr><td>div</td><td>do</td><td>downto</td><td>else</td><td>end</td></tr>
<tr><td>file</td><td>for</td><td>function</td><td>goto</td><td>if</td></tr>
<tr><td>in</td><td>label</td><td>mod</td><td>nil</td><td>not</td></tr>
<tr><td>of</td><td>or</td><td>packed</td><td>procedure</td><td>program</td></tr>
<tr><td>record</td><td>repeat</td><td>set</td><td>then</td><td>to</td></tr>
<tr><td>type</td><td>until</td><td>var</td><td>while</td><td>with</td></tr>
</table>
<h2>Character set and Identifiers in Pascal </h2>
<p>The Pascal character set consists of:</p>
<ul class="list">
<li><p>All upper case letters (A-Z)</p></li>
<li><p>All lower case letters (a-z)</p></li>
<li><p>All digits (0-9)</p></li>
<li><p>Special symbols   - + * / := , . ;. () [] = {} ` white space</p></li>
</ul>
<p>The entities in a Pascal program like variables and constants, types, functions, procedures and records etc. has a name or identifier. An identifier is a sequence of letter and digits, beginning with a letter. Special symbols and blanks must not be used in an identifier.</p>
<h1>Pascal - Data Types</h1>
<h2>Pascal Data Types:</h2>
<p>Pascal data types can be summarized as below the following diagram:</p>
<img src="../images/pascal_datatypes.html" alt="Pascal Data Types"/>
<h2>Type Declarations</h2>
<p>The type declaration is used to declare the data type of an identifier. Syntax of type declaration is:</p>
<pre class="prettyprint">
 type-identifier-1, type-identfier-2 = type-specifier;
</pre>
<p>For example, the following declaration defines the variables days and age as integer type, yes and true as Boolean type, name and city as string type, fees and expenses as real type.  </p>
<pre class="prettyprint">
type
days, age = integer;
yes, true = boolean;
name, city = string;
fees, expenses = real;
</pre>
<h2>Integer Types</h2>
<p>Following table gives you detail about standard integer types with its storage sizes and value ranges used in Object Pascal:</p>
<table class="src">
<tr><th>Type</th><th>Minimum</th><th>Maximum</th><th>Format</th></tr>
<tr><td>Integer</td><td>  -2147483648</td><td>2147483647</td><td>signed 32-bit</td></tr>
<tr><td>Cardinal</td><td>0</td><td>4294967295</td><td>unsigned 32-bit</td></tr>
<tr><td>Shortint</td><td> -128</td><td>127</td><td>signed 8-bit</td></tr>
<tr><td>Smallint</td><td> -32768</td><td>32767</td><td>signed 16-bit</td></tr>
<tr><td>Longint</td><td> -2147483648</td><td>2147483647</td><td>signed 32-bit</td></tr>
<tr><td>Int64</td><td> -2^63</td><td>2^63 - 1</td><td>signed 64-bit</td></tr>
<tr><td>Byte</td><td>0</td><td>255</td><td>unsigned 8-bit</td></tr>
<tr><td>Word</td><td>0</td><td>65535</td><td>unsigned 16-bit</td></tr>
<tr><td>Longword</td><td>0</td><td>4294967295</td><td>unsigned 32-bit</td></tr>
</table>
<h2>Constants</h2>
<p>Use of constants makes a program more readable and helps to keep special quantities at one place in the beginning of the program. Pascal allows <i>numerical, logical, string</i> and <i>character</i> constants. Constants can be declared in the declaration part of the program by specifying the const declaration. Syntax of constant type declaration is follows:</p>
<pre class="prettyprint">
const
Identifier = contant_value;
</pre>
<p>Following are some examples of constant declarations:</p>
<pre class="prettyprint">
VELOCITY_LIGHT = 3.0E=10;
PIE = 3.141592;
NAME = 'Stuart Little';
CHOICE = yes;
OPERATOR = '+';
</pre>
<p>All constant declarations must be given before the variable declaration.</p>
<h2>Enumerated types</h2>
<p>Enumerated data types are user-defined data types. They allow values to be specified in a list. Only <i>assignment</i> operators and <i>relational</i> operators are permitted on enumerated data type. Enumerated data types can be declared as follows:</p>
<pre class="prettyprint">
type
enum-identifier = (item1, item2, item3, ... )
</pre>
<p>Following are some examples of enumerated  type declarations:</p>
<pre class="prettyprint">
type
SUMMER = (April, May, June, July, September);
COLORS = (Red, Green, Blue, Yellow, Magenta, Cyan, Black, White);
TRANSPORT = (Bus, Train, Airplane, Ship);
</pre>
<p>The order in which the items are listed in the domain of an enumerated type, defines the order of the items. For example, in the enumerated type SUMMER, April comes before May; May comes before June, and so on. The domain of enumerated type identifiers cannot consist of numeric or character constants.</p>
<h2>Subrange Types</h2>
<p>Subrange types allow a variable to assume values that lie within a certain range. For example, if the <i>age</i> of voters should lie between 18 to 100 years, a variable named age could be declared as:</p>
<pre class="prettyprint">
var
age: 18 ... 1000;
</pre>
<p>We will look at variable declaration in details in the next section. You can also define a subrange type using the type declaration. Syntax for declaring a subrange type is as follows:</p>
<pre class="prettyprint">
type
subrange-identifier = lower-limit ... upper-limit;
</pre>
<p>Following are some examples of subrange type declarations:</p>
<pre class="prettyprint">
const
P = 18;
Q = 90;
type
Number = 1 ... 100;
Value = P ... Q;
</pre>
<p>Subrange types can be created from a subset of an already defined enumerated type, For example:</p>
<pre class="prettyprint">
type
months = (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);
Summer = Apr ... Aug;
Winter = Oct ... Dec;
</pre>
<h1>Pascal - Variable Types</h1>
<table class="src">
<tr><th style="width:25%;">Type</th><th>Description</th></tr>
<tr><td>Character </td><td>Typically a single octet (one byte). This is an integer type.</td></tr>
<tr><td>Integer </td><td>The most natural size of integer for the machine.</td></tr>
<tr><td>Real </td><td>A single-precision floating point value.</td></tr>
<tr><td>Boolean </td><td>Specifies true or false logical values. This is also an integer type.</td></tr>
<tr><td>Enumerated</td><td>Specifies a user-defined list.</td></tr>
<tr><td>Subrange </td><td>Represents variables whose values lie within a range.</td></tr>
<tr><td>String</td><td>Stores an array of characters.</td></tr>
</table>
<h2>Variable Declaration in Pascal</h2>
<p>All variables must be declared before we use them in Pascal program. All variable declarations are followed by the <i>var</i> keyword. A declaration specifies a list of variables, followed by a colon (:) and the type. Syntax of variable declaration is: </p>
<pre class="prettyprint">
var
variable_list : type;
</pre>
<p>Here, type must be a valid Pascal data type including character, integer, real, boolean, or any user defined data type etc., and variable_list may consist of one or more identifier names separated by commas. Some valid variable declarations are shown here: </p>
<pre class="prettyprint">
var
age, weekdays : integer;
taxrate, net_income: real;
choice, isready: boolean;
initials, grade: char;
name, surname : string;
</pre>
<h2>Enumerated Variables</h2>
<p>You have seen howto use simple variable types like integer, real and boolean. Now let's see variables of enumerated type which can be defined as:</p>
<pre class="prettyprint">
var
var1, var2, ...  : enum-identifier;
</pre>
<p>When you have declared an enumerated type, you can declare variables of that type. For example, </p>
<pre class="prettyprint">
type
months = (January, February, March, April, May, June, July, August, September, October, November, December);
Var
m: months;
...
M := January;
</pre>
<h2>Subrange Variables</h2>
<p>Subrange variables are declared as: </p>
<pre class="prettyprint">
var
subrange-name : lowerlim ... uperlim;
</pre>
<p>Examples of subrange variables are:</p>
<pre class="prettyprint">
var
marks: 1 ... 100;
grade: 'A' ... 'E';
age: 1 ... 25;
</pre>
<h1>Pascal - Constants</h1>
<p>A constant is an entity that remains unchanged during program execution. Pascal allows only constants of the following types to be declared:</p>
<ul class="list">
<li><p>Ordinal types</p></li>
<li><p>Set types</p></li>
<li><p>Pointer types (but the only allowed value is Nil).</p></li>
<li><p>Real types</p></li>
<li><p>Char</p></li>
<li><p>String</p></li>
</ul>
<h2>Declaring Constants</h2>
<p>Syntax for declaring constants is as follows:</p>
<pre class="prettyprint">
const
identifier = constant_value;
</pre>
<p>The following table provides examples of some valid constant declarations:</p>
<table class="src">
<tr><th>Constant Type</th><th>Examples</th></tr>
<tr><td>Ordinal(Integer)type constant</td><td>valid_age = 21; </td></tr>
<tr><td>Set type constant</td><td>Vowels = set of (A,E,I,O,U);</td></tr>
<tr><td>Pointer type constant</td><td>P = NIL;</td></tr>
<tr><td>Real type constant</td><td>e = 2.7182818; <br/> velocity_light = 3.0E+10; </td></tr>
<tr><td>Character type constant</td><td>Operator = '+';  </td></tr>
<tr><td>String type constant</td><td>president = 'Johnny Depp';</td></tr>
</table>
<h1>Pascal - Operators</h1>
<h2>Arithmetic Operators</h2>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Adds two operands</td><td> A + B will give 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first</td><td> A - B will give -10</td></tr>
<tr><td>*</td><td>Multiply both operands</td><td> A * B will give 200</td></tr>
<tr><td>div</td><td>Divide numerator by de-numerator</td><td> B div A will give 2</td></tr>
<tr><td>mod</td><td>Modulus Operator and remainder of after an integer division</td><td> B mod A will give 0</td></tr>
</table>
<h2>Relational Operators</h2>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>=</td><td> Checks if the value of two operands is equal or not, if yes then condition becomes true.</td><td> (A = B) is not true. </td></tr>
<tr><td>&lt;&gt;</td><td> Checks if the value of two operands is equal or not, if values are not equal then condition becomes true.</td><td> (A &lt;&gt; B) is true. </td></tr>
<tr><td>&gt;</td><td> Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td><td> (A &gt; B) is not true. </td></tr>
<tr><td>&lt;</td><td> Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td><td> (A &lt; B) is true. </td></tr>
<tr><td>&gt;=</td><td> Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &gt;= B) is not true. </td></tr>
<tr><td>&lt;=</td><td> Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &lt;= B) is true. </td></tr>
</table>
<h2>Boolean Operators</h2>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%">Description</th><th>Example</th></tr>
<tr><td>and</td><td>Called Boolean AND operator. If both the operands are true then condition becomes true.</td><td>(A and B) is false.</td></tr>
<tr><td>and then</td><td>It is similar to the AND operator, however, it guarantees the order in which the compiler evaluates the logical expression. Left to right and the right operands are evaluated only when necessary</td><td>(A and then B) is false.</td></tr>
<tr><td>or</td><td>Called Boolean OR Operator. If any of the two operands is true then condition becomes true.</td><td>(A or B) is true.</td></tr>
<tr><td>or else</td><td>It is similar to Boolean OR, however,  it guarantees the order in which the compiler evaluates the logical expression. Left to right and the right operands are evaluated only when necessary</td><td>(A or else B) is true.</td></tr>
<tr><td>not</td><td>Called Boolean NOT Operator. Used to reverse the logical state of its operand. If a condition is true then Logical NOT operator will make it false.</td><td>not (A and B) is true.</td></tr>
</table>
<h2>Bit Operators</h2>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;</td><td> Binary AND Operator copies a bit to the result if it exists in both operands. </td><td> (A &amp; B) will give 12 which is 0000 1100</td></tr>
<tr><td>|</td><td> Binary OR Operator copies a bit if it exists in either operand. </td><td> (A | B) will give 61 which is 0011 1101</td></tr>
<tr><td>!</td><td> Binary OR Operator copies a bit if it exists in either operand. </td><td> A ! B) will give 61 which is 0011 1101</td></tr>
<tr><td>~</td><td> Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. </td><td> (~A ) will give -60 which is 1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td><td> A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td><td> A &gt;&gt; 2 will give 15 which is 0000 1111</td></tr>
</table>
<p>Please note that different implementations of Pascal differ in bitwise operators. Free Pascal, the compiler we used here, however, supports the following bitwise operators: </p>
<table class="src">
<tr><th style="width:25%;">Operators</th><th>Operations</th></tr>
<tr><td>not</td><td>Bitwise NOT</td></tr>
<tr><td>and</td><td>Bitwise AND</td></tr>
<tr><td>or</td><td>Bitwise OR</td></tr>
<tr><td>xor</td><td>Bitwise exclusive OR</td></tr>
<tr><td>shl</td><td>Bitwise shift left</td></tr>
<tr><td>shr</td><td>Bitwise shift right</td></tr>
<tr><td>&lt;&lt;</td><td>Bitwise shift left</td></tr>
<tr><td>&gt;&gt;</td><td>Bitwise shift right</td></tr>
</table>
<h2>Operators Precedence in Pascal </h2>
<table class="src">
<tr><th style="width:50%;">Operator</th><th>Precedence</th></tr>
<tr><td>~, not,</td><td>Highest</td></tr>
<tr><td>*, /, div, mod, and, &amp;</td><td></td></tr>
<tr><td>|, !, +, -, or,</td><td></td></tr>
<tr><td>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, in</td><td></td></tr>
<tr><td>or else, and then</td><td>Lowest</td></tr>
</table>
<h1>Pascal - Decision Making</h1>
<p>Following is the general from of a typical decision making structure found in most of the programming languages:</p>
<img src="../images/decision_making.jpg" alt="Decision making statements in Pascal" />
<h1>if-then Statement</h1>
<p>The  <b>if-then</b> statement is the simplest form of control statement, frequently used in decision making and changing the control flow of the program execution. </p>
<h2>Syntax: </h2>
<p>Syntax for <b>if-then</b> statement is:</p>
<pre class="prettyprint">
if condition then S
</pre>
<p>Where <b>condition</b> is a Boolean or relational condition and <b>S</b> is a simple or compound statement. Example of an if-then statement is: </p>
<pre class="prettyprint">
if (a &lt;= 20) then
   c:= c+1;
</pre>
<p>If the boolean expression <b>condition</b> evaluates to true then the block of code inside the if statement will be executed. If boolean expression evaluates to false then the first set of code after the end of the if statement (after the closing end;) will be executed. </p>
<p>Pascal assumes any non-zero and non-nill values as true and if it is either zero or nill then it is assumed as false value. </p>
<h2>Flow Diagram:</h2>
<img src="../images/if_statement.html" alt="Pascal if-then statement" />
<h1>if-then-else Statement</h1>
<p>An <b>if-then</b> statement can be followed by an optional <b>else</b> statement, which executes when the Boolean expression is <b>false</b>.</p>
<h2>Syntax: </h2>
<p>Syntax for the if-then-else statement is: </p>
<pre class="prettyprint">
if condition then S1 else S2;
</pre>
<p> Where, <b>S1</b> and <b>S2</b> are different statements. <b>Please note that the statement S1 is not followed by a semicolon</b>. In the if-then-else statements, when the test condition is true, the statement S1 is executed and S2 is skipped; when the test condition is false, then S1 is bypassed and statement S2 is executed. </p>
<p>For example, </p>
<pre class="prettyprint">
if color = red then
   writeln('You have chosen a red car')
else
   writeln('Please choose a color for your car');
</pre>
<p>If the boolean expression <b>condition</b> evaluates to true then the if-then block of code will be executed otherwise the else block of code will be executed. </p>
<p>Pascal assumes any non-zero and non-nill values as true and if it is either zero or nill then it is assumed as false value. </p>
<h2>Flow Diagram:</h2>
<img src="../images/if_else_statement.html" alt="Pascal if-then-else statement" />
<h1>Case Statement</h1>
<p>You have observed that <b>if-then-else</b> statements enable us to implement multiple decisions in a program.  This can also be achieved using the <b>case</b> statement in simpler way.</p>
<h2>Syntax:</h2>
<p>The syntax of the case statement is: </p>
<pre class="prettyprint">
case (expression) of
   L1 : S1;
   L2: S2;
   ...
   ...
   Ln: Sn;
end;
</pre>
<p>Where, <b>L1</b>, <b>L2</b>... are case labels, or input values which could be integers, characters, boolean or enumerated data items. <b>S1</b>, <b>S2</b>, ... are Pascal statements, each of these statements may have one or more than one case label associated with it. The expression is called the <b>case selector</b> or the <b>case index</b>. The case index may assume values that correspond to the case labels.</p>
<p>The case statement must always have an <b>end</b> statement associated with it.  </p>
<p>The following rules apply to a case statement: </p>
<ul class="list">
<li><p>The expression used in a case statement must have an integral or enumerated type, or be of a class type in which the class has a single conversion function to an integral or enumerated type.</p></li>
<li><p>You can have any number of case statements within a case. Each case is followed by the value to be compared to and a colon.</p></li>
<li><p>The case label for a case must be the same data type as the expression in the case statement, and it must be a constant or a literal.</p></li>
<li><p>The compiler will evaluate the case expression. If one of the case label's value matches the value of the expression, the statement that follows this label is executed. After that, the program continues after the final end.</p></li>
<li><p>If none of the case label matches the expression value, the statement list after the else or otherwise keyword is executed. This can be an empty statement list. If no else part is present, and no case constant matches the expression value, program flow continues after the final end.</p></li>
<li><p>The case statements can be compound statements (i.e. a Begin ... End block).</p></li>
</ul>
<h2>Flow Diagram:</h2>
<img src="../images/case_statement.html" alt="Case statement in Pascal" />
<h1>Pascal - Loops</h1>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general from of a loop statement in most of the programming languages: </p>
<img src="../images/loop_architecture.jpg" alt="Loop Architecture" />
<h1>While-do Loops</h1>
<p> A <b>while-do</b> loop statement in Pascal allows repetitive computations till some test condition is satisfied.  In other words it repeatedly executes a target statement as long as a given condition is true.</p>
<h2>Syntax: </h2>
<p>The syntax of a while-do loop is: </p>
<pre class="prettyprint">
while (condition) do S;
</pre>
<p>Where <b>condition</b> is a Boolean or relational expression whose value would be true or false and <b>S</b> is a simple statement or group of statements
within BEGIN ... END block. </p>
<p>For example, </p>
<pre class="prettyprint">
while number&gt;0 do
begin
   sum := sum + number;
   number := number - 2;
end;
</pre>
<p>When the condition becomes false, program control passes to the line immediately following the loop. </p>
<h2>Flow Diagram: </h2>
<img src="../images/pascal_while_do_loop.html" alt="while-do loop in Pascal" />
<h1>For-do Loop</h1>
<p> A <b>for-do</b> loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times. </p>
<h2>Syntax: </h2>
<p>The syntax for the for-do loop in Pascal is as follows: </p>
<pre class="prettyprint">
for &lt; variable-name &gt; := &lt; initial_value &gt; to [down to] &lt; final_value &gt; do 
   S;
</pre>
<p>Where, the <i>variable-name</i> specifies a variable of ordinal type, called control variable or index variable; <i>initial_value</i> and <i>final_value</i> values are values that the control variable can take; and S is the body of the for-do loop that could be a simple statement or a group of statements.  </p>
<p>For example,</p>
<pre class="prettyprint">
for i:= 1 to 10 do writeln(i);
</pre>
<p>Here is the flow of control in a for-do loop: </p>
<ul class="list">
<li><p>The initial step is executed first, and only once. This step allows you to declare and initialize any loop control variables. </p></li>
<li><p>Next, the condition is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute and flow of control jumps to the next statement just after the for-do loop.</p></li>
<li><p>After the body of the for-do loop executes, the value of the variable in increased or decreased. </p></li>
<li><p>The condition is now evaluated again. If it is true, the loop executes and the process repeats itself (body of loop, then increment step, and then again condition). After the condition becomes false, the for-do loop terminates.</p></li>
</ul>
<h2>Flow Diagram</h2>
<img src="../images/pascal_for_do_loop.html" alt="for-do loop in Pascal" />
<h1>Repeat-Until Loop</h1>
<p>Unlike for and while loops, which test the loop condition at the top of the loop, the <b>repeat ... until</b> loop in Pascal checks its condition at the bottom of the loop. </p>
<p>A repeat ... until loop is similar to a while loop, except that a repeat ... until loop is guaranteed to execute at least one time. </p>
<h2>Syntax: </h2>
<pre class="prettyprint">
repeat
   S1;
   S2;
   ...
   ...
   Sn;
until condition;
</pre>
<p>For example, </p>
<pre class="prettyprint">
repeat
   sum := sum + number;
   number := number - 2;
until number = 0;
</pre>
<p>Notice that the conditional expression appears at the end of the loop, so the statement(s) in the loop execute once before the condition is tested. </p>
<p>If the condition is true, the flow of control jumps back up to repeat, and the statement(s) in the loop execute again. This process repeats until the given condition becomes false.</p>
<h2>Flow Diagram: </h2>
<img src="../images/pascal_repeat_until_loop.html" alt="repeat until loop in Pascal" />
<h1>Break Statement</h1>
<p>The <b>break</b> statement in Pascal has the following two usages:</p>
<ol class="list">
<li><p>When the <b>break</b> statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop.</p></li>
<li><p>It can be used to terminate a case in the <b>case</b> statement (covered in the next chapter).</p></li>
</ol>
<p>If you are using nested loops ( ie. one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.</p>
<h2>Syntax:</h2>
<p>The syntax for a <b>break</b> statement in Pascal is as follows:</p>
<pre class="prettyprint">
break;
</pre>
<h2>Flow Diagram:</h2>
<img src="../images/cpp_break_statement.html" alt="Pascal break statement" />
<h1>Continue Statement</h1>
<p>The <b>continue</b> statement in Pascal works somewhat like the <b>break</b> statement. Instead of forcing termination, however, <b>continue</b> forces the next iteration of the loop to take place, skipping any code in between. </p>
<p>For the <b>for-do</b> loop, <b>continue</b> statement causes the conditional test and increment portions of the loop to execute. For the <b>while-do</b> and <b>repeat...until</b> loops, <b>continue</b> statement causes the program control passes to the conditional tests. </p>
<h2>Syntax: </h2>
<p>The syntax for a continue statement in Pascal is as follows: </p>
<pre class="prettyprint">
continue;
</pre>
<h2>Flow Diagram:</h2>
<img src="../images/cpp_continue_statement.html" alt="Pascal continue statement" />
<h1>Pascal - Functions</h1>
<h2>Subprograms</h2>
<p>A subprogram is a program unit/module that performs a particular task. These subprograms are combined to form larger programs. This is basically called the 'Modular design'. A subprogram can be invoked by a subprogram/program, which is called the calling program. </p>
<p>Pascal provides two kinds of subprograms: </p>
<ul class="list">
<li><p><b>Functions</b>: these subprograms return a single value. </p></li>
<li><p><b>Procedures</b>: these subprograms do not return a value directly.</p></li>
</ul>
<h2>Defining a Function: </h2>
<p>In Pascal, a <b>function</b> is defined using the function keyword. The general form of a function definition is as follows:</p>
<pre class="prettyprint">
function name(argument(s): type1; argument(s): type2; ...): function_type;
local declarations;
begin
   ...
   &lt; statements &gt;
   ...
   name:= expression;
end;
</pre>
<p>A function definition in Pascal consists of a function <b>header</b>, local <b>declarations</b> and a function <b>body</b>. The function header consists of the keyword function and a <b>name</b> given to the function.  Here are all the parts of a function: </p>
<ul class="list">
<li><p><b>Arguments:</b> The argument(s) establish the linkage between the calling program and the function identifiers and also called the formal parameters. A parameter is like a placeholder. When a function is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a function. Use of such formal parameters is optional. These parameters may have standard data type, user-defined datatype or subrange data type.</p> <p>The formal parameters list appearing in the function statement could be simple or subscripted variables, arrays or structured variables, or subprograms.  </p></li>
<li><p><b>Return Type:</b> All functions must return a value, so all functions must be assigned a type. The <b>function-type</b> is the data type of the value the function returns. It may be standard, user-defined scalar or subrange type but it cannot be structured type. </p></li>
<li><p><b>Local declarations:</b> local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of function only. </p></li>
<li><p><b>Function Body:</b> The function body contains a collection of statements that define what the function does. It should always be enclosed between the reserved words begin and end.  It is the part of a function where all computations are done. There must be an assignment statement of the type - <b>name := expression;</b> in the function body that assigns a value to the function name. This value is returned as and when the function is executed. The last statement in the body must be an end statement. </p></li>
</ul>
<h2>Calling a Function: </h2>
<p>To call a function you simply need to pass the required parameters along with function name and if function returns a value then you can store returned value. Following is a simple example to show the usage:</p>
<pre class="prettyprint">
program exFunction;
var
   a, b, ret : integer;

(*function definition *)
function max(num1, num2: integer): integer;
var
   (* local variable declaration *)
   result: integer;
begin
   if (num1 &gt; num2) then
      result := num1
   else
      result := num2;
   max := result;
end;
begin
   a := 100;
   b := 200;
  (* calling a function to get max value *)
   ret := max(a, b);
   writeln( 'Max value is : ', ret );
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Max value is : 200 
</pre>
<h1>Pascal - Procedures</h1>
<p><b>Procedures </b>are subprograms that, instead of returning a single value, allow to obtain a group of results.</p>
<h2>Defining a Procedure: </h2>
<p>In Pascal, a procedure is defined using the <b>procedure</b> keyword. The general form of a procedure definition is as follows: </p>
<pre class="prettyprint">
procedure name(argument(s): type1, argument(s): type 2, ... );
   &lt; local declarations &gt;
begin
   &lt; procedure body &gt;
end;
</pre>
<p>A procedure <b>definition</b> in Pascal consists of a <b>header</b> , local <b>declarations</b> and a <b>body</b> of the procedure. The procedure header consists of the keyword <b>procedure</b> and a name given to the procedure.  Here are all the parts of a procedure: </p>
<ul class="list">
<li><p><b>Arguments:</b> The argument(s) establish the linkage between the calling program and the procedure identifiers and also called the formal parameters. Rules for arguments in procedures are same as that for the functions. </p></li>
<li><p><b>Local declarations:</b> local declarations refer to the declarations for labels, constants, variables, functions and procedures, which are application to the body of the procedure only. </p></li>
<li><p><b>Procedure Body:</b> The procedure body contains a collection of statements that define what the procdure does. It should always be enclosed between the reserved words begin and end.  It is the part of a procedure where all computations are done. </p></li>
</ul>
<h2>Procedure Declarations:</h2>
<p>A procedure <b>declaration</b> tells the compiler about a procedure name and how to call the procedure. The actual body of the procedure can be defined separately. </p>
<p>A procedure declaration has the following syntax: </p>
<pre class="prettyprint">
procedure name(argument(s): type1, argument(s): type 2, ... );
</pre>
<p>Please note that the <b>name of the procedure is not associated with any type</b>. For the above defined procedure <i>findMin()</i>, following is the declaration: </p>
<pre class="prettyprint">
procedure findMin(x, y, z: integer; var m: integer);
</pre>
<h2>Calling a Procedure:</h2>
<p>To call a procedure you simply need to pass the required parameters along with the procedure name as shown below:</p>
<pre class="prettyprint">
program exProcedure;
var
   a, b, c,  min: integer;
procedure findMin(x, y, z: integer; var m: integer); 
(* Finds the minimum of the 3 values *)
begin
   if x &lt; y then
      m:= x
   else
      m:= y;
   if z &lt; m then
      m:= z;
end; { end of procedure findMin }  
begin
   writeln(' Enter three numbers: ');
   readln( a, b, c);
   findMin(a, b, c, min); (* Procedure call *)
   writeln(' Minimum: ', min);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Enter three numbers:
89 45 67
Minimum: 45
</pre>
<h1>Pascal - Variable Scope</h1>
<p>A scope in any programming is a region of the program where a defined variable can have its existence and beyond that variable cannot be accessed. There are three places where variables can be declared in Pascal programming language: </p>
<ul class="list">
<li><p>Inside a subprogram or a block which is called local variables</p></li>
<li><p>Outside of all subprograms which is called global variables</p></li>
<li><p>In the definition of subprogram parameters which is called formal parameters</p></li>
</ul>
<p>Let us explain what are <b>local</b> and <b>global</b> variables and formal parameters.</p>
<h2>Local Variables </h2>
<p>Variables that are declared inside a subprogram or block are called local variables. They can be used only by statements that are inside that  subprogram or block of code. Local variables are not known to subprograms outside their own. Following is the example using local variables. Here all the variables <i>a</i>, <i>b</i> and <i>c</i> are local to program named <i>exLocal</i>.</p>
<pre class="prettyprint">
program exLocal; 
var
   a, b, c: integer;
begin
  (* actual initialization *)
   a := 10;
   b := 20;
   c := a + b;
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
value of a = 10 b = 20 c = 30
</pre>
<h2>Global Variables </h2>
<p>Global variables are defined outside of a function, usually on top of the program. The global variables will hold their value throughout the lifetime of your program and they can be accessed inside any of the functions defined for the program. </p>
<p>A <b>global</b> variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration. Following is an example using <b>global</b> and <b>local</b> variables: </p>
<pre class="prettyprint">
program exGlobal;
var
   a, b, c: integer;
procedure display;
var
   x, y, z: integer;
begin
   (* local variables *)
   x := 10;
   y := 20;
   z := x + y;
  (*global variables *)
   a := 30;
   b:= 40;
   c:= a + b;
   writeln('Winthin the procedure display');
   writeln(' Displaying the global variables a, b, and c');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   writeln('Displaying the local variables x, y, and z');
   writeln('value of x = ', x , ' y =  ',  y, ' and z = ', z);
end;
begin
   a:= 100;
   b:= 200;
   c:= 300;
   writeln('Winthin the program exlocal');
   writeln('value of a = ', a , ' b =  ',  b, ' and c = ', c);
   display();
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Within the program exlocal
value of a = 100 b = 200 c = 300
Within the procedure display
Displaying the global variables a, b, and c
value of a = 30 b = 40 c = 70
Displaying the local variables x, y, and z
value of x = 10 y = 20 z = 30
</pre>
<h1>Pascal - Strings</h1>
<p>The string in Pascal is actually a sequence of characters with an optional size specification. The characters could be numeric, letters, blank, special characters or a combination of all. Extended Pascal provides numerous types of string objects depending upon the system and implementation. We will discuss more commonly types of strings used in programs. </p>
<p>You can define a string in many ways:</p>
<ul class="list">
<li><p><b>Character arrays:</b> This is a  character string (or string for short) is a sequence of zero or more byte-sized characters  enclosed in single quotes.</p></li>
<li><p><b>String variables:</b> The variable of String type, as defined in Turbo Pascal.</p></li>
<li><p><b>Short strings:</b> The variable of String type with size specification.</p></li>
<li><p><b>Null terminated strings:</b> The variable of <b>pchar</b> type.</p></li>
<li><p><b>AnsiStrings:</b> Ansistrings are strings that have no length limit.</p></li>
</ul>
<p>Pascal provides only one string operator . string concatenation operator (+).  </p>
<h2>Examples</h2>
<p>The following program prints first four kinds of strings. We will use AnsiStrings in the next example. </p>
<pre class="prettyprint">
program exString;
var
   greetings: string;
   name: packed array [1..10] of char;
   organisation: string[10];
   message: pchar;
begin
   greetings := 'Hello ';
   message := 'Good Day!';
   writeln('Please Enter your Name');
   readln(name);
   writeln('Please Enter the name of your Organisation');
   readln(organisation);
  writeln(greetings, name, ' from ', organisation);
  writeln(message); 
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Please Enter your Name
John Smith
Please Enter the name of your Organisation
Infotech
Hello John Smith from Infotech
</pre>
<h1>Pascal - Boolean</h1>
<p>Pascal provides data types Boolean that enables the programmers to define, store and manipulate logical entities, such as constants, variables, functions and expressions etc. </p>
<p>Boolean values are basically integer type. Boolean type variables have two pre-defined possible values <b>True</b> and <b>False</b>. The expressions resolving to a Boolean value can also be assigned to a Boolean type.</p>
<p>Free Pascal also supports the <b>ByteBool</b>, <b>WordBool</b> and <b>LongBool</b> types. These are of type Byte, Word or Longint respectively.</p>
<p>The value False is equivalent to 0 (zero) and any nonzero value is considered True when converting to a Boolean value.  A Boolean value of True is converted to -1 in case it is assigned to a variable of type LongBool.</p>
<p>It shuold be noted that logical operators <b>and</b>, <b>or</b> and <b>not</b> are defined for Boolean data types.</p>
<h2>Declaration of Boolean Data Types</h2>
<p> A variable of Boolean type is declared using the var keyword.</p>
<pre class="prettyprint">
var
boolean-identifier: boolean;
</pre>
<p>for example, </p>
<pre class="prettyprint">
var
choice: boolean;
</pre>
<h1>Pascal - Arrays</h1>
<p>Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number1, number2, ..., and number100, you declare one array variable such as numbers and use numbers[1], numbers[2], and ..., numbers[100] to represent individual variables. A specific element in an array is accessed by an index.</p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element. </p>
<p>Please note that if you want a C style array starting from index 0, you just need to start the index from 0, instead of 1. </p>
<img src="../images/arrays.jpg" alt="Arrays in Pascal" />
<h2>Declaring Arrays</h2>
<p>To declare an array in Pascal, a programmer may either declare the type and then create variables of that array or directly declare the array variable. </p>
<p>The general form of type declaration of one dimensional array is: </p>
<pre class="prettyprint">
type
   array-identifier = array[index-type] of element-type;
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>array-identifier</b> indicates the name of the array type.</p></li>
<li><p><b>index-type</b> specifies the subscript of the array; it can be any scalar data type except real</p></li>
<li><p><b>element-type</b> specifies the types of values that are going to be stored</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint">
type
   vector = array [ 1..25] of real;
var
   velocity: vector;
</pre>
<p>Now velocity is a variable array of vector type, which is sufficient to hold up to 25 real numbers. </p>
<p>To start the array from 0 index, the declaration would be: </p>
<pre class="prettyprint">
type
   vector = array [ 0..24] of real;
var
   velocity: vector;
</pre>
<h2>Types of Array Subscript </h2>
<p>In Pascal, an array subscript could be of any scalar type like, integer, Boolean, enumerated or subrange, except real. Array subscripts could have negative values too. </p>
<p>For example, </p>
<pre class="prettyprint">
type
   temperature = array [-10 .. 50] of real;
var
   day_temp, night_temp: temperature;
</pre>
<p>Let us take up another example where the subscript is of character type: </p>
<pre class="prettyprint">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
</pre>
<p>Subscript could be of enumerated type: </p>
<pre class="prettyprint">
type
   color = ( red, black, blue, silver, beige);
   car_color = array of [color] of boolean;
var
   car_body: car_color;
</pre>
<h2>Initializing Arrays </h2>
<p>In Pascal, arrays are initialized through assignment, either by specifying a particular subscript or using a for-do loop. </p>
<p>For example: </p>
<pre class="prettyprint">
type
   ch_array = array[char] of 1..26;
var
   alphabet: ch_array;
   c: char;
begin
   ...
   for c:= 'A' to 'Z' do
   alphabet[c] := ord[m];  
   (* the ord() function returns the ordinal values *)
</pre>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example: </p>
<pre class="prettyprint">
a: integer;
a: = alphabet['A'];
</pre>
<h1>Pascal - Pointers</h1>
<p>Pointers in Pascal are easy and fun to learn. Some Pascal programming tasks are performed more easily with pointers, and other tasks, such as dynamic memory allocation, cannot be performed without using pointers. So it becomes necessary to learn pointers to become a perfect  Pascal programmer. Let's start learning them in simple and easy steps.</p>
<p>As you know every variable is a memory location and every memory location has its address defined which can be accessed using the name of the pointer variable, which denotes an address in memory.</p>
<h2>What Are Pointers? </h2>
<p>A pointer is a dynamic variable whose value is the address of another variable i.e. direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address.  The general form of a pointer variable declaration is: </p>
<pre class="prettyprint">
type
   ptr-identifier = ^base-variable-type;
</pre>
<p>The pointer type is defined by prefixing the up-arrow of caret symbol (^) with the base type.  The base-type defines the types of the data items.  Once a pointer variable is defined to be of certain type, it can point data items of that type only. Once a pointer type has been defined, we can use the <b>var</b> declaration to declare pointer variables.</p>
<pre class="prettyprint">
var
   p1, p2, ... : ptr-identifier;
</pre>
<p>Following are some valid pointer declarations: </p>
<pre class="prettyprint">
type
   Rptr = ^real;
   Cptr = ^char;
   Bptr = ^ Boolean;
   Aptr = ^array[1..5] of real;
   date-ptr = ^ date;
      Date = record
         Day: 1..31;
         Month: 1..12;
         Year: 1900..3000;
      End;
var
   a, b : Rptr;
   d: date-ptr;
</pre>
<p>The pointer variables are dereferenced by using the same caret symbol(^). For example, the associated variable referred by a pointer <i>rptr</i>, is <i>rptr^</i>. It can be accessed as: </p>
<pre class="prettyprint">
rptr^ := 234.56;
</pre>
<h1>Pascal - Records</h1>
<p>Pascal arrays allow you to define type of variables that can hold several data items of the same kind but a record is another user defined data type available in Pascal, which allows you to combine data items of different kinds. </p>
<p>Records consist of different fields.  Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book: </p>
<ul class="list">
<li><p>Title</p></li>
<li><p>Author</p></li>
<li><p>Subject</p></li>
<li><p>Book ID</p></li>
</ul>
<h2>Defining a Record</h2>
<p>To define a record type, you may use the type declaration statement. The record type is defined as: </p>
<pre class="prettyprint">
type
record-name = record
   field-1: field-type1;
   field-2: field-type2;
   ...
   field-n: field-typen;
end;
</pre>
<p>Here is the way you would declare the Book record:</p>
<pre class="prettyprint">
type 
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: integer;
end;
</pre>
<p>The record variables are defined in the usual way as </p>
<pre class="prettyprint">
var
   r1, r2, ... : record-name;
</pre>
<h2>Accessing Fields of a Record</h2>
<p>To access any field of a record, we use the member access operator (.). The member access operator is coded as a period between the record variable name and the field that we wish to access. Following is the example to explain usage of structure: </p>
<pre class="prettyprint">
program exRecords;
type
Books = record
   title: packed array [1..50] of char;
   author: packed array [1..50] of char;
   subject: packed array [1..100] of char;
   book_id: longint;
end;
var
   Book1, Book2: Books; (* Declare Book1 and Book2 of type Books *)
begin
   (* book 1 specification *)
   Book1.title  := 'C Programming';
   Book1.author := 'Nuha Ali '; 
   Book1.subject := 'C Programming Tutorial';
   Book1.book_id := 6495407;

   (* book 2 specification *)
   Book2.title := 'Telecom Billing';
   Book2.author := 'Zara Ali';
   Book2.subject := 'Telecom Billing Tutorial';
   Book2.book_id := 6495700;
 
   (* print Book1 info *)
   writeln ('Book 1 title : ', Book1.title);
   writeln('Book 1 author : ', Book1.author);
   writeln( 'Book 1 subject : ', Book1.subject);
   writeln( 'Book 1 book_id : ', Book1.book_id);
   writeln; 

   (* print Book2 info *)
   writeln ('Book 2 title : ', Book2.title);
   writeln('Book 2 author : ', Book2.author);
   writeln( 'Book 2 subject : ', Book2.subject);
   writeln( 'Book 2 book_id : ', Book2.book_id);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407

Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h1>Pascal - Variants</h1>
<p>Pascal supports a unique type of storage named variants.  You can assign any simple type of values in a variant variable. The type of a value stored in a variant is only determined at runtime.  Almost any simple type can be assigned to variants: ordinal types, string types, int64 types.</p>
<p>Structured types such as sets, records, arrays, files, objects and classes are not assignment-compatible with a variant.  You can also assign a pointer to a variant. </p>
<p>Free Pascal supports variants.</p>
<h2>Declaring a Variant</h2>
<p>You can declare variant type like any other types using the <b>var</b> keyword. The syntax for declaring a variant type is: </p>
<pre class="prettyprint">
var
   v: variant;
</pre>
<p>Now this variant variable v can be assigned to almost all simple types including the enumerated types and vice versa. </p>
<pre class="prettyprint">
type  
   color = (red, black, white);  
var  
   v : variant;  
   i : integer;  
   b : byte;  
   w : word;  
   q : int64;  
   e : extended;  
   d : double;  
   en : color;  
   as : ansistring;  
   ws : widestring;  
begin  
   v := i;  
   v := b;  
   v := w;  
   v := q;  
   v := e;  
   v := en;  
   v := d:  
   v := as;  
   v := ws;  
end;
</pre>
<h1>Pascal - Sets</h1>
<p>A set is a collection of elements of same type. Pascal allows defining the set data type. The elements in a set are called its members. In mathematics, sets are represented by enclosing the members within <i>braces{}</i>.  However, in Pascal, set elements are enclosed within square brackets [], which are referred as set constructor.</p>
<h2>Defining Set Types and Variables</h2>
<p>Pascal Set types are defined as</p>
<pre class="prettyprint">
type
set-identifier = set of base type;
</pre>
<p>Variables of set type are defined as</p>
<pre class="prettyprint">
var
s1, s2, ...: set-identifier;
</pre>
<p>or, </p>
<pre class="prettyprint">
s1, s2...: set of base type;
</pre>
<p>Examples of some valid set type declaration are:</p>
<pre class="prettyprint">
type
Days = (mon, tue, wed, thu, fri, sat, sun);
Letters = set of char;
DaySet = set of days;
Alphabets = set of 'A' .. 'Z';
studentAge = set of 13..20;
</pre>
<h2>Set Operators</h2>
<p>Following table shows all the set operators supported by Free Pascal. Assume that <b>S1</b> and <b>S2</b> are two character sets, such that:</p>
<p> S1 := ['a', 'b', 'c']; </p>
<p> S2 := ['c', 'd', 'e']; </p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Union of two sets</td><td>  S1 + S2 will give a set <br/> ['a', 'b', 'c', 'd', 'e']</td></tr>
<tr><td>-</td><td>Difference of two sets</td><td> S1 - S2 will give a set <br/> ['a', 'b']</td></tr>
<tr><td>*</td><td>Intersection of two sets</td><td> S1 * S2 will give a set </br> ['c']</td></tr>
<tr><td> &gt;&lt;</td><td>Symmetric difference of two sets</td><td> S1 &gt;&lt; S2 will give a set ['a', 'b', 'd', 'e']</td></tr>
<tr><td> =</td><td>Checks equality of two sets</td><td> S1 = S2 will give the boolean value False</td></tr>
<tr><td> &lt;&gt;</td><td>Checks non-equality of two sets</td><td> S1 &lt;&gt; S2 will give the boolean value True</td></tr>
<tr><td> &lt;= </td><td>Contains( Checks if one set is a subset of the other)</td><td> S1 &lt;= S2 will give the boolean value False </td></tr>
<tr><td>Include</td><td> Includes an element in the set; basically it is the Union of a set and an element of same base type</td><td> Include (S1, ['d']) will give a set <br/> ['a', 'b', 'c', 'd']</td></tr>
<tr><td>Exclude</td><td>Excludes an element from a set; basically it is the Difference of a set and an element of same base type </td><td> Exclude (S2, ['d']) will give a set <br/> ['c', 'e']</td></tr>
<tr><td>In</td><td>Checks set membership of an element in a set</td><td> ['e'] in S2 gives the boolean value True</td></tr>
</table>
<h1>Pascal - File Handling</h1>
<p>Pascal treats a file as a sequence of components which must be of uniform type. A file's type is determined by the type of the components. File data type is defined as: </p>
<pre class="prettyprint">
type
file-name = file of base-type;
</pre>
<p>Where, the base-type indicates the type of the components of the file. The base type could be anything like, integer, real, Boolean, enumerated, subrange, record, arrays and sets except another file type. Variables of a file type are created using the <i>var</i> declaration: </p>
<pre class="prettyprint">
var
f1, f2,...: file-name;
</pre>
<p>Following are some examples of defining some file types and file variables:</p>
<pre class="prettyprint">
type
   rfile = file of real;
   ifile = file of integer;
   bfile = file of boolean;
   datafile = file of record
   arrfile = file of array[1..4] of integer;
var
   marks: arrfile;
   studentdata: datafile;
   rainfalldata: rfile;
   tempdata: ifile;
   choices: bfile;
</pre>
<h2>Creating and Writing to a File </h2>
<p>Let us write a program that would create a data file for students' records. It would create a file named students.dat and write a student's data into it: </p>
<pre class="prettyprint">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;
var
   Student: StudentRecord;
   f: file of StudentRecord;

begin
   Assign(f,'students.dat');
   Rewrite(f);
   Student.s_name := 'John Smith';
   Student.s_addr := 'United States of America';
   Student.s_batchcode := 'Computer Science';
   Write(f,Student);
   Close(f);
end.
</pre>
<p>When compiled and run, the program would create a file named <i>students.dat</i> into the working directory. You can open the file using a text editor, like notepad, to look at John Smith's data. </p>
<h2>Reading from a File</h2>
<p>We have just created and written into a file named students.dat. Now let us write a program that would read the student's data from the file: </p>
<pre class="prettyprint">
program DataFiles;
type
   StudentRecord = Record
      s_name: String;
      s_addr: String;
      s_batchcode: String;
   end;
var
   Student: StudentRecord;
   f: file of StudentRecord;
begin
   assign(f, 'students.dat');
   reset(f); 
   while not eof(f) do
   begin
      read(f,Student);
      writeln('Name: ',Student.s_name);
      writeln('Address: ',Student.s_addr);
      writeln('Batch Code: ', Student.s_batchcode);
   end;
   close(f);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Name: John Smith
Address: United States of America
Batch Code: Computer Science
</pre>
<h1>Pascal - Memory Management</h1>
<p>This chapter explains dynamic memory management in Pascal. Pascal programming language provides several functions for memory allocation and management.</p>
<h2>Allocating Memory Dynamically</h2>
<p>While doing programming, if you are aware about the size of an array, then it is easy and you can define it as an array. For example to store a name of any person, it can go max 100 characters so you can define something as follows:</p>
<pre class="prettyprint">
var
name: array[1..100] of char;
</pre>
<p>But now let us consider a situation where you have no idea about the length of the text you need to store, for example you want to store a detailed description about a topic.  Here we need to define a pointer to string without defining how much memory is required. </p>
<p>Pascal provides a procedure <b>new</b>to create pointer variables. </p>
<pre class="prettyprint">
program exMemory;
var
name: array[1..100] of char;
description: ^string;
begin
   name:= 'Zara Ali';
   new(description);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<p>Now, if you need to define a pointer with specific number of bytes to be referred by it later, you should use the <b>getmem</b> function or the <b>getmem</b> procedure, which has the following syntax:</p>
<pre class="prettyprint">
procedure Getmem(
   out p: pointer;
   Size: PtrUInt
);

function GetMem(
   size: PtrUInt
):pointer;
</pre>
<p>In the previous example, we declared a pointer to a string. A string has a maximum value of 255 bytes. If you really don't need that much space, or a larger space, in terms of bytes, <i>getmem</i> subprogram allows specifying that. Let us rewrite the previous example, using <i>getmem</i>:</p>
<pre class="prettyprint">
program exMemory;
var
name: array[1..100] of char;
description: ^string;
begin
   name:= 'Zara Ali';
   description := getmem(200);
      if not assigned(description) then
         writeln(' Error - unable to allocate required memory')
      else
         description^ := 'Zara ali a DPS student in class 10th';
   writeln('Name = ', name );
   writeln('Description: ', description^ );
   freemem(description);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
</pre>
<h1>Pascal - Units</h1>
<p>A Pascal program can consist of modules called units. A unit might consist of some code blocks which in turn are made up of variables and type declarations, statements, procedures etc. There are many built-in units in Pascal and Pascal allows programmers to define and write their own units to be used later in various programs.</p>
<h2>Using Built-in Units </h2>
<p>Both the built-in units and user defined units are included in a program by the uses clause. We have already used the variants unit in the <i>Pascal - Variants</i> tutorial. This tutorial explains creating and including user-defined units. However, let us first see how to include a built-in unit <b>crt</b> in your program:</p>
<pre class="prettyprint">
program myprog;
uses crt;
</pre>
<p>The following example illustrates using the <b>crt</b> unit:</p>
<pre class="prettyprint">
Program Calculate_Area (input, output);
uses crt;
var 
   a, b, c, s, area: real;
begin
   textbackground(white); (* gives a white background *)
   clrscr; (*clears the screen *)
   textcolor(green); (* text color is green *)
   gotoxy(30, 4); (* takes the pointer to the 4th line and 30th column) 
   writeln('This program calculates area of a triangle:');
   writeln('Area = area = sqrt(s(s-a)(s-b)(s-c))');
   writeln('S stands for semi-perimeter');
   writeln('a, b, c are sides of the triangle');
   writeln('Press any key when you are ready');
   readkey;
   clrscr;
   gotoxy(20,3);
   write('Enter a: ');
   readln(a);
   gotoxy(20,5);
   write('Enter b:');
   readln(b);
   gotoxy(20, 7);
   write('Enter c: ');
   readln(c);

   s := (a + b + c)/2.0;
   area := sqrt(s * (s - a)*(s-b)*(s-c));
   gotoxy(20, 9);
   writeln('Area: ',area:10:3);
   readkey;
end.
</pre>
<p>It is the same program we used right at the beginning of the Pascal tutorial, compile and run it to find the effects of the change.</p>
<h2>Creating and Using a Pascal Unit </h2>
<p>To create a unit, you need to write the modules, or subprograms you want to store in it and save it in a file with <b>.pas</b> extension. The first line of this file should start with the keyword unit followed by the name of the unit. For example:</p>
<pre class="prettyprint">
unit calculateArea;
</pre>
<p>Following are three important steps in creating a Pascal unit:</p>
<ul class="list">
<li><p>The name of the file and the name of the unit should be exactly same. So our unit <i>calculateArea</i> will be saved in a file named <i>calculateArea.pas</i></p></li>
<li><p>The next line should consist of a single keyword <b>interface</b>. After this line, you will write the declarations for all the functions and procedures that will come in this unit.</p></li>
<li><p>Right after the function declarations, write the word <b>implementation</b>, which is again a keyword. After the line containing the keyword implementation, provide definition of all the subprograms.</p></li>
</ul>
<p>The following program creates the unit named calculateArea:</p>
<pre class="prettyprint">
unit CalculateArea;
interface
function RectangleArea( length, width: real): real;
function CircleArea(radius: real) : real;
function TriangleArea( side1, side2, side3: real): real;

implementation
function RectangleArea( length, width: real): real;
begin
   RectangleArea := length * width;
end;

function CircleArea(radius: real) : real;
const
   PI = 3.14159;
begin
   CircleArea := PI * radius * radius;
end;

function TriangleArea( side1, side2, side3: real): real;
var
   s, area: real;
begin
   s := (side1 + side2 + side3)/2.0;
   area := sqrt(s * (s - side1)*(s-side2)*(s-side3));
   TriangleArea := area;
end;

end.
</pre>
<p>Next, let us write a simple program that would use the unit we defined above:</p>
<pre class="prettyprint">
program AreaCalculation;
uses CalculateArea,crt;

var
   l, w, r, a, b, c, area: real;
begin
   clrscr;
   l := 5.4;
   w := 4.7;
   area := RectangleArea(l, w);
   writeln('Area of Rectangle 5.4 x 4.7 is: ', area:7:3);

   r:= 7.0;
   area:= CircleArea(r);
   writeln('Area of Circle with radius 7.0 is: ', area:7:3);

   a := 3.0;
   b:= 4.0;
   c:= 5.0;
   area:= TriangleArea(a, b, c);
   writeln('Area of Triangle 3.0 by 4.0 by 5.0 is: ', area:7:3);
end.
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Area of Rectangle 5.4 x 4.7 is: 25.380
Area of Circle with radius 7.0 is: 153.938
Area of Triangle 3.0 by 4.0 by 5.0 is: 6.000
</pre>
<h1>Pascal - Date &amp; Time</h1>
<p>Most of the software you write needs implementing some form of date functions returning current date and time. Dates are so much part of everyday life that it becomes easy to work with them without thinking. Pascal also provides powerful tools for date arithmetic that makes manipulating dates easy. However, the actual name and workings of these functions are different for different compilers. </p>
<h2> Getting the Current Date &amp; Time:</h2>
<p>Pascal's TimeToString function gives you the current time in a colon(: ) delimited form. The following example shows how to get the current time:</p>
<pre class="prettyprint">
program TimeDemo;
uses sysutils;
begin
   writeln ('Current time : ',TimeToStr(Time));
end.
</pre>
<p>When the above code was compiled and executed, it produced following result:</p>
<pre class="result">
Current time : 18:33:08
</pre>
<p>The <b>Date</b> function returns the current date in <b>TDateTime</b> format. The TDateTime is a double value, which needs some decoding and formatting. The following program demonstrates how to use it in your program to display the current date: </p>
<pre class="prettyprint">
Program DateDemo;
uses sysutils;
var
   YY,MM,DD : Word;
begin
   writeln ('Date : ',Date);
   DeCodeDate (Date,YY,MM,DD);
   writeln (format ('Today is (DD/MM/YY): %d/%d/%d ',[dd,mm,yy]));
 end.
</pre>
<p>When the above code was compiled and executed, it produced following result:</p>
<pre class="result">
Date: 4.111300000000000E+004
Today is (DD/MM/YY):23/7/2012
</pre>
<p>The Now function returns the current date and time:</p>
<pre class="prettyprint">
Program DatenTimeDemo;
uses sysutils;
begin
   writeln ('Date and Time at the time of writing : ',DateTimeToStr(Now));
end.
</pre>
<p>When the above code was compiled and executed, it produced following result:</p>
<pre class="result">
Date and Time at the time of writing : 23/7/2012 18:51:
</pre>
<p>Free Pascal provides a simple time stamp structure named <b>TTimeStamp</b>, which has the following format: </p>
<pre class="prettyprint">
type TTimeStamp = record
  Time: Integer;
  Date: Integer;
end;
</pre>
<hr />
<div class="pre-btn">
<a href="pascal_classes.html">Previous Page</a>
</div>
<div class="print-btn">
<a href="../cgi-bin/printpage.html" target="_blank">Print Version</a>
</div>
<div class="pdf-btn">
<a href="pdf/pascal_quick_guide.html" alt="Pascal Quick Guide" target="_blank">PDF Version</a>
</div>
<div class="nxt-btn">
<a href="pascal_useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
</div>
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text";
google_ad_channel ="9030538898";
google_color_border="ffffff";
google_color_link="900b09";
google_color_url="000000";
google_color_text="000000";
//--></script>
<script type="text/javascript" src="../../pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div>
</div><!-- middlecol -->
<div id="rightcol">
<!-- AddThis Button BEGIN -->
<div class="addthis">
<div class="addthis_toolbox addthis_default_style">
<a class="addthis_button_facebook"></a>
<a class="addthis_button_twitter"></a>
<script type="text/javascript">
<!--
 document.write('<a class="addthis_button_google_plusone" g:plusone:count="false"></a>');
//-->
</script>
<a class="addthis_button_linkedin"></a>
<a class="addthis_button_email"></a>
<a class="addthis_button_compact"></a>
</div>
<script type="text/javascript" src="../../s7.addthis.com/js/250/addthis_widget.js#pubid=ra-4f661ec623a400f0"></script>
</div>
<!-- AddThis Button END -->
<div class="localad">
<a rel="nofollow" href="http://www.modernindianbabynames.com/" target="_blank" title="Modern Baby Names">Modern Baby Names</a>
</div>
<div class="localad">
<a rel="nofollow" href="http://www.photofuntoos.com/" target="_blank" title="Online Photo Editing">Online Photo Editing</a>
</div>
<div class="rightgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
</div><!-- rightcol -->
<div style="clear:both;"></div>
</div><!-- wrapper -->
<div id="footer">
<div class="wrapper">
<div id="bottommenu">
<a href="../asp.net/index.html" target="_top">ASP.NET </a> |
<a href="../jquery/index.html" target="_top">jQuery </a> |
<a href="../ajax/index.html" target="_top">AJAX </a> |
<a href="../ant/index.html" target="_top">ANT</a> |
<a href="../jsp/index.html" target="_top">JSP </a> |
<a href="../servlets/index.html" target="_top">Servlets </a> |
<a href="../log4j/index.html" target="_top">log4j </a> |
<a href="../ibatis/index.html" target="_top">iBATIS </a> |
<a href="../hibernate/index.html" target="_top">Hibernate </a> |
<a href="../jdbc/index.html" target="_top">JDBC </a> |
<a href="../struts_2/index.html" target="_top">Struts </a> |
<a href="../html5/index.html" target="_top">HTML5 </a> |
<a href="../sql/index.html" target="_top">SQL </a> |
<a href="../mysql/index.html" target="_top">MySQL </a> |
<a href="../cplusplus/index.html" target="_top">C++ </a> |
<a href="../unix/index.html" target="_top">UNIX </a>
</div>
<div id="copyright">
<p>Copyright &copy; 2013 by tutorialspoint. All Rights Reserved.</p>
</div>
</div>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/pascal/pascal_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
</html>
