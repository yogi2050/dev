<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/csharp/csharp_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>C# Quick Guide</title>
<link rel="shortcut icon" href="../favicon.png" type="image/x-icon" />
<meta name="description" content="C# Quick Guide - Learn C Sharp Programming  in simple and easy steps starting from Environment setup, Basic Syntax, Data Types, Type Conversion, Variables, Constants, Operators, Decision Making, Loops, Methods, Arrays, Strings, Struct, Enums, File I/O, Classes, Encapsulation, Interfaces, Inheritance, Namespaces, Polymophism, Operator Overloading, Encapsulation, Reflection, Attributes, Properties, Indexes, Delegates, Events, Collections, Generics, Preprocessor Directives, Multithreading, Regular Expression, and Exception Handling." />
<meta name="keywords" content="C#, C-Sharp,  Programming, Tutorial, Beginners , Basic Syntax, Data Types, Variables, Constants, Operators, Decision Making, Loops, Methods, Arrays, Strings, Struct, Enums, File I/O, Classes, Interfaces, Inheritance, Namespaces, Polymophism, Operator Overloading, Encapsulation, Reflection, Attributes, Properties, Indexes, Delegates, Events, Collections, Generics, Preprocessor Directives, Multithreading, Regular Expression, and Exception Handling." />
<base  />
<link rel="stylesheet" type="text/css" href="../scripts/style.css" />
<link rel="stylesheet" type="text/css" href="../scripts/prettify.css" />
<script type="text/javascript" src="../scripts/prettify.js"></script>
<style media="screen" type="text/css">
#header{ 
background:#0b85d6 !important;
}
#topmenu
{
background-color:#525252 !important;
}
#leftcol ul.menu li.heading 
{
background:#0b85d6 !important;
border:1px solid #525252 !important;
}
#leftcol, #middlecol, #rightcol {min-height:1500px; padding:0px;}
</style>
<script src="../../www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
</script>
</head>
<body onload="prettyPrint()">
<div id="header">
<div class="wrapper">
<h1 class="logo"><a href="../index-2.html">Tutorials Point - Simply Easy Learning</a></h1>
<div id="search">
<form method="get" id="searchform" name="searchform" action="http://www.google.com/search" target="_blank">
<input type="hidden" name="sitesearch" value="www.tutorialspoint.com"/>
<input type="text" name="as_q" id="s" value="Search this site..." onfocus="if (this.value == 'Search this site...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search this site...';}"/>
<input value="FORID:11" name="cof" type="hidden"/>
<input type="hidden" name="ie" value="ISO-8859-1" />
<input class="submit btn" type="image" src="../images/icon-search.png" alt="Go"/>
</form>
</div>
</div>
</div>
<div id="topmenu">
<div class="wrapper">
<div id="left">
<a href="../index-2.html" target="_top">HOME </a>
<a href="../java/index.html" target="_top">JAVA </a>
<a href="../php/index.html" target="_top">PHP </a>
<a href="../python/index.html" target="_top">Python </a>
<a href="../ruby/index.html" target="_top">Ruby </a>
<a href="../perl/index.html" target="_top">Perl </a>
<a href="../html/index.html" target="_top">HTML </a>
<a href="../css/index.html" target="_top">CSS </a>
<a href="../javascript/index.html" target="_top">Javascript </a>
<a href="../mysql/index.html" target="_top">MySQL </a>
<a href="../cplusplus/index.html" target="_top">C++ </a>
<a href="../unix/index.html" target="_top">UNIX </a>
<a href="../more.html" target="_top">MORE...</a>
</div>
<div id="right">
<a href="../references.html" target="_top">REFERENCES</a> |
<a href="../forums/index.html" target="_top">FORUM</a> |
<a href="../about/index.html" target="_top">ABOUT</a> |
<a href="../about/contact_us.html" target="_top">CONTACT</a>
</div>
</div>
</div>
<div class="wrapper">
<div id="leftcol">
<div class="mini-logo">
<img src="../images/csharp-mini-logo.png" alt="C# Programming Tutorial" />
</div>
<ul class="menu">
<li class="heading">C# Basic Tutorial</li>
<li><a target="_top" href="index.html">C# Home</a></li>
<li><a target="_top" href="csharp_overview.html">C# - Overview</a></li>
<li><a target="_top" href="csharp_environment_setup.html">C# - Environment</a></li>
<li><a target="_top" href="csharp_program_structure.html">C# - Program Structure</a></li>
<li><a target="_top" href="csharp_basic_syntax.html">C# - Basic Syntax</a></li>
<li><a target="_top" href="csharp_data_types.html">C# - Data Types</a></li>
<li><a target="_top" href="csharp_type_conversion.html">C# - Type Conversion</a></li>
<li><a target="_top" href="csharp_variables.html">C# - Variables</a></li>
<li><a target="_top" href="csharp_constants.html">C# - Constants</a></li>
<li><a target="_top" href="csharp_operators.html">C# - Operators</a></li>
<li><a target="_top" href="csharp_decision_making.html">C# - Decision Making</a></li>
<li><a target="_top" href="csharp_loops.html">C# - Loops</a></li>
<li><a target="_top" href="csharp_encapsulation.html">C# - Encapsulation</a></li>
<li><a target="_top" href="csharp_methods.html">C# -  Methods</a></li>
<li><a target="_top" href="csharp_nullables.html">C# -  Nullables</a></li>
<li><a target="_top" href="csharp_arrays.html">C# - Arrays</a></li>
<li><a target="_top" href="csharp_strings.html">C# - Strings</a></li>
<li><a target="_top" href="csharp_struct.html">C# - Struct</a></li>
<li><a target="_top" href="csharp_enums.html">C# - Enums</a></li>
<li><a target="_top" href="csharp_classes.html">C# - Classes</a></li>
<li><a target="_top" href="csharp_inheritance.html">C# - Inheritance</a></li>
<li><a target="_top" href="csharp_polymorphism.html">C# - Polymorphism</a></li>
<li><a target="_top" href="csharp_operator_overloading.html">C# - Operator Overloading</a></li>
<li><a target="_top" href="csharp_interfaces.html">C# - Interfaces</a></li>
<li><a target="_top" href="csharp_namespaces.html">C# - Namespaces</a></li>
<li><a target="_top" href="csharp_preprocessor_directives.html">C# - Preprocessor Directives</a></li>
<li><a target="_top" href="csharp_regular_expressions.html">C# - Regular Expressions</a></li>
<li><a target="_top" href="csharp_exception_handling.html">C# - Exception Handling</a></li>
<li><a target="_top" href="csharp_file_io.html">C# - File I/O</a></li>
</ul>
<ul class="menu">
<li class="heading">C# Advanced Tutorial</li>
<li><a target="_top" href="csharp_attributes.html">C# - Attributes</a></li>
<li><a target="_top" href="csharp_reflection.html">C# - Reflection</a></li>
<li><a target="_top" href="csharp_properties.html">C# - Properties</a></li>
<li><a target="_top" href="csharp_indexers.html">C# - Indexers</a></li>
<li><a target="_top" href="csharp_delegates.html">C# - Delegates</a></li>
<li><a target="_top" href="csharp_events.html">C# - Events</a></li>
<li><a target="_top" href="csharp_collections.html">C# - Collections</a></li>
<li><a target="_top" href="csharp_generics.html">C# - Generics</a></li>
<li><a target="_top" href="csharp_anonymous_methods.html">C# - Anonymous Methods</a></li>
<li><a target="_top" href="csharp_unsafe_codes.html">C# - Unsafe Codes</a></li>
<li><a target="_top" href="csharp_multithreading.html">C# - Multithreading</a></li>
</ul>
<ul class="menu">
<li class="heading">C# Useful Resources</li>
<li><a target="_top" href="csharp_quick_guide.html"><b>C# Quick Guide</b></a></li>
<li><a target="_top" href="csharp_useful_resources.html">C# Useful Resources</a></li>
</ul>
<ul class="menu">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</div><!-- leftcol -->
<div id="middlecol">
<!-- PRINTING STARTS HERE -->
<div class="content">
<h1>C# - Quick Guide</h1>
<div class="topgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="csharp_multithreading.html">Previous Page</a>
</div>
<div class="nxt-btn">
<a href="csharp_useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
<h1>C# - Overview</h1>
<p>C# is a modern, general-purpose object oriented programming language developed by Microsoft and approved by Ecma and ISO. </p>
<p>C# was developed by Anders Hejlsberg and his team during the development of .Net Framework.</p>
<p>C# is designed for Common Language Infrastructure (CLI), which consists of the executable code and runtime environment that allows use of various high-level languages to be used on different computer platforms and architectures.</p>
<p>The following reasons make C# a widely used professional language:</p>
<ul class="list">
<li><p>Modern, general purpose programming language</p></li>
<li><p>Object oriented.</p></li>
<li><p>Component oriented.</p></li>
<li><p>Easy to learn.</p></li>
<li><p>Structured language.</p></li>
<li><p>It produces efficient programs.</p></li>
<li><p>It can be compiled on a variety of computer platforms.</p></li>
<li><p>Part of .Net Framework.</p></li>
</ul>
<h2>Strong Programming Features of C#</h2>
<p>Although C# constructs closely follows traditional high level languages C and C++ and being an object oriented programming language, it has strong resemblance with Java, it has numerous strong programming features that make it endearing to multitude of programmers worldwide.</p>
<p>Following is the list of few important features:</p>
<ul class="list">
<li><p>Boolean Conditions</p></li>
<li><p>Automatic Garbage Collection</p></li>
<li><p>Standard Library</p></li>
<li><p>Assembly Versioning</p></li>
<li><p>Properties and Events</p></li>
<li><p>Delegates and Events Management</p></li>
<li><p>Easy to use Generics</p></li>
<li><p>Indexers</p></li>
<li><p>Conditional Compilation</p></li>
<li><p>Simple Multithreading</p></li>
<li><p>LINQ and Lambda Expressions</p></li>
<li><p>Integration with Windows</p></li>
</ul>
<h1>C# - Environment</h1>
<h2>Integrated Development Environment (IDE) For C#</h2>
<p>Microsoft provides the following development tools for C# programming:</p>
<ul class="list">
<li><p>Visual Studio 2010 (VS)</p></li>
<li><p>Visual C# 2010 Express (VCE)</p></li>
<li><p>Visual Web Developer</p></li>
</ul>
<p>The last two are freely available from Microsoft official website. Using these tools you can write all kinds of C# programs from simple command-line applications to more complex applications. You can also write C# source code files using a basic text editor, like Notepad, and compile the code into assemblies using the command-line compiler, which is again a part of the .NET Framework.</p>
<p>Visual C# Express and Visual Web Developer Express edition are trimmed down versions of Visual Studio and has the same look and feel. They retain most features of Visual Studio. In this tutorial, we have used Visual C # 2010 Express. </p>
<p>You can download it from <a target="_blank" rel="nofollow" href="http://www.microsoft.com/visualstudio/eng/downloads">Microsoft Visual Studio</a>. It gets automatically installed in your machine. Please note that you need an active internet connection for installing the express edition. </p>
<h2>Writing C# Programs on Linux or Mac OS</h2>
<p>Although the.NET Framework runs on the Windows operating system, there are some alternative versions that work on other operating systems. <b>Mono</b> is an open-source version of the .NET Framework, which includes a C# compiler and runs on several operating systems, including various flavors of Linux and Mac OS. Kindly check <a target="_blank" rel="nofollow" href="http://www.go-mono.com/mono-downloads/download.html">Go Mono</a>.</p>
<p>The stated purpose of Mono is not only to be able to run Microsoft .NET applications cross-platform, but also to bring better development tools to Linux developers. Mono can be run on many operating systems including Android, BSD, iOS, Linux, OS X, Windows, Solaris and UNIX.</p>

<h1>C# - Program Structure</h1>
<h2>C# Hello World Example</h2>
<p>A C# program basically consists of the following parts:</p>
<ul class="list">
<li><p>Namespace declaration</p></li>
<li><p>A class</p></li>
<li><p>Class methods</p></li>
<li><p>Class attributes</p></li>
<li><p>A Main method</p></li>
<li><p>Statements & Expressions</p></li>
<li><p>Comments</p></li>
</ul>
<p>Let us look at a simple code that would print the words "Hello World":</p>
<pre class="prettyprint">
using System;
namespace HelloWorldApplication
{
   class HelloWorld
   {
      static void Main(string[] args)
      {
         /* my first program in C# */
         Console.WriteLine("Hello World");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Hello World
</pre>
<p>Let us look at various parts of the above program:</p>
<ul class="list">
<li><p>The first line of the program <b>using System;</b> -  the <b>using</b> keyword is used to include the <b>System</b> namespace in the program. 
A program generally has multiple <b>using</b> statements. </p></li>
<li><p>The next line has the <b>namespace</b> declaration. A <b>namespace</b> is a collection of classes. The <i>HelloWorldApplication</i> namespace contains the class <i>HelloWorld</i>.</p></li>
<li><p>The next line has a <b>class</b> declaration, the class <i>HelloWorld</i>, contains the data and method definitions that your program uses. Classes generally would contain more than one method. Methods define the behavior of the class. However, the <i>HelloWorld</i> class has only one method <b>Main</b>.</p></li>
<li><p>The next line defines the <b>Main</b> method, which is the <b>entry point</b> for all C# programs. The <b>Main</b> method states what the class will do when executed</p></li>
<li><p>The next line /*...*/ will be ignored by the compiler and it has been put to add additional <b>comments</b> in the program. </p></li>
<li><p>The Main method specifies its behavior with the statement <b>Console.WriteLine("Hello World"); </b>
<p><i>WriteLine</i> is a method of the <i>Console</i> class defined in the <i>System</i> namespace. This statement causes the message "Hello, World!" to be displayed on the screen.</p>
</p></li>
<li><p>The last line <b>Console.ReadKey();</b> is for the VS.NET Users. This makes the program wait for a key press and it prevents the screen from running and closing quickly when the program is launched from Visual Studio .NET. </p></li>
</ul>
<p>Its worth to note the following points:</p>
<ul class="list">
<li><p>C# is case sensitive.</p></li>
<li><p>All statements and expression must end with a semicolon (;).</p></li>
<li><p>The program execution starts at the Main method.</p></li>
<li><p>Unlike Java, file name could be different from the class name.</p></li>
</ul>
<h2>Compile & Execute a C# Program:</h2>
<p>If you are using Visual Studio.Net for compiling and executing C# programs, take the following steps:</p>
<ul class="list">
<li><p>Start Visual Studio.</p></li>
<li><p>On the menu bar, choose File, New, Project.</p></li>
<li><p>Choose Visual C# from templates, and then choose Windows.</p></li>
<li><p>Choose Console Application.</p></li>
<li><p>Specify a name for your project, and then choose the OK button.</p></li>
<li><p>The new project appears in Solution Explorer.</p></li>
<li><p>Write code in the Code Editor. </p></li>
<li><p>Click the Run button or the F5 key to run the project. A Command Prompt window appears that contains the line Hello World.</p></li>
</ul>
<p>You can compile a C# program by using the command line instead of the Visual Studio IDE:</p>
<ul class="list">
<li><p>Open a text editor and add the above mentioned code.</p></li>
<li><p>Save the file as <b>helloworld.cs</b></p></li>
<li><p>Open the command prompt tool and go to the directory where you saved the file.</p></li>
<li><p>Type <b>csc helloworld.cs</b> and press enter to compile your code.</p></li>
<li><p>If there are no errors in your code the command prompt will take you to the next line and would generate <b>helloworld.exe</b> executable file.</p></li>
<li><p>Next, type <b>helloworld</b> to execute your program.</p></li>
<li><p>You will be able to see "Hello World" printed on the screen.</p></li>
</ul>
<h1>C# - Basic Syntax</h1>
<p>C# is an object oriented programming language. In Object Oriented Programming methodology a program consists of various objects that interact with each other by means of actions. The actions that an object may take are called methods. Objects of the same kind are said to have the same type or, more often, are said to be in the same class. </p>
<p>For example, let us consider a Rectangle object. It has attributes like length and width. Depending upon the design, it may need ways for accepting the values of these attributes, calculating area and display details. </p>
<p>Let us look at an implementation of a Rectangle class and discuss C# basic syntax, on the basis of our observations in it:</p>
<pre class="prettyprint">
using System;
namespace RectangleApplication
{
    class Rectangle
    {
        // member variables
        double length;
        double width;
        public void Acceptdetails()
        {
            length = 4.5;    
            width = 3.5;
        }
        public double GetArea()
        {
            return length * width;
        }
        public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }
    
    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.Acceptdetails();
            r.Display();
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The first statement in any C# program is </p>
<pre class="prettyprint">
using System;
</pre>
<p>The <b>using</b> keyword is used for including the namespaces in the program. A program can include multiple using statements.</p>
<h2>The <i>class</i> Keyword</h2>
<p>The <b>class</b> keyword is used for declaring a class.</p> 
<h2>Comments in C#</h2>
<p>Comments are used for explaining code. Compilers ignore the comment entries. The multiline comments in C# programs start with /* and terminates with the characters */ as shown below:</p>
<pre class="prettyprint">
/* This program demonstrates
The basic syntax of C# programming 
Language */
</pre>
<p>Single line comments are indicated by the '//' symbol. For example,</p>
<pre class="prettyprint">
}//end class Rectangle    
</pre>
<h2>Member Variables</h2>
<p>Variables are attributes or data members of a class, used for storing data. In the preceding program, the <i>Rectangle</i> class has two member variables named <i>length</i> and <i>width</i>.</p> 
<h2>Member Functions</h2>
<p>Functions are set of statements that perform a specific task. The member functions of a class are declared within the class. Our sample class Rectangle contains three member functions:  <i>AcceptDetails</i>, <i>GetArea</i> and <i>Display</i>.</p> 
<h2>Instantiating a Class</h2>
<p>In the preceding program, the class <i>ExecuteRectangle</i> is used as a class which contains the <i>Main()</i> method and instantiates the <i>Rectangle</i> class. </p>
<h2>Identifiers</h2>
<p>An identifier is a name used to identify a class, variable, function, or any other user-defined item. The basic rules for naming classes in C# are as follows:</p>
<ul class="list">
<li><p>A name must begin with a letter that could be followed by a sequence of letters, digits (0 - 9) or underscore. The first character in an identifier cannot be a digit. </p></li>
<li><p>It must not contain any embedded space or symbol like ? - +! @ # % ^ & * ( ) [ ] { } . ; : " ' / and \. However an underscore ( _ ) can be used. </p></li>
<li><p>It should not be a C# keyword.</p></li>
</ul>
<h1>C# - Data Types</h1>
<p>In C#, variables are categorized into the following types:</p>
<ul class="list">
<li><p>Value types</p></li>
<li><p>Reference types</p></li>
<li><p>Pointer types</p></li>
</ul>
<h2>Value Types</h2>
<p>The following table lists the available value types in C# 2010:</p>
<table class="src">
<tr><th style="width:10%;">Type</th><th style="width:35%;">Represents</th><th style="width:45%;">Range</th><th style="width:10%;">Default<br> Value</th></tr>
<tr><td>bool</td><td>Boolean value</td><td>True or False</td><td>False</td></tr>
<tr><td>byte</td><td>8-bit unsigned integer</td><td>0 to 255</td><td>0</td></tr>
<tr><td>char</td><td>16-bit Unicode character</td><td>U +0000 to U +ffff</td><td>'\0'</td></tr>
<tr><td>decimal</td><td>128-bit precise decimal values with 28-29 significant digits</td><td>(-7.9 x 10<sup>28</sup> to 7.9 x 10<sup>28</sup>) 
/ 10<sup>0 to 28</sup>
</td><td>0.0M</td></tr>
<tr><td>double</td><td>64-bit double-precision floating point type</td><td>(+/-)5.0 x 10<sup>-324</sup> to (+/-)1.7 x 10<sup>308</sup></td><td>0.0D</td></tr>
<tr><td>float</td><td>32-bit single-precision floating point type</td><td>-3.4 x 10<sup>38</sup> to + 3.4 x 10<sup>38</sup></td><td>0.0F</td></tr>
<tr><td>int</td><td>32-bit signed integer type</td><td>-2,147,483,648 to 2,147,483,647</td><td>0</td></tr>
<tr><td>long</td><td>64-bit signed integer type</td><td>-923,372,036,854,775,808 to 
9,223,372,036,854,775,807
</td><td>0L</td></tr>
<tr><td>sbyte</td><td>8-bit signed integer type</td><td>-128 to 127</td><td>0</td></tr>
<tr><td>short</td><td>16-bit signed integer type</td><td>-32,768 to 32,767</td><td>0</td></tr>
<tr><td>uint</td><td>32-bit signed integer type</td><td>0 to 4,294,967,295</td><td>0</td></tr>
<tr><td>ulong</td><td>64-bit signed integer type</td><td>0 to 18,446,744,073,709,551,615</td><td>0</td></tr>
<tr><td>ushort</td><td>16-bit signed integer type</td><td>0 to 65,535</td><td>0</td></tr>
</table>
<h2>Reference Types</h2>
<p>The reference types do not contain the actual data stored in a variable, but they contain a reference to the variables.</p>
<p>In other words, they refer to a memory location. Using more than one variable, the reference types can refer to a memory location. If the data in the memory location is changed by one of the variables, the other variable automatically reflects this change in value.  Example of <b>built in</b> reference types are: <b>object</b>, <b>dynamic</b> and <b>string</b>. </p>
<h3>Object Type</h3>
<p>The <b>Object Type</b> is the ultimate base class for all data types in C# Common Type System(CTS). Object is an alias for System.Object class. So object types can be assigned values of any other types, value types, reference types, predefined or user-defined types. However, before assigning values, it needs type conversion. </p>
<p>When a value type is converted to object type, it is called <b>boxing</b> and on the other hand, when an object type is converted to a value type it is called <b>unboxing</b>.</p>
<pre class="prettyprint">
object obj;
obj = 100; // this is boxing
</pre>
<h3>Dynamic Type</h3>
<p>You can store any type of value in the dynamic data type variable. Type checking for these types of variables takes place at runtime. </p>
<p>Syntax for declaring a dynamic type is:</p>
<pre class="prettyprint">
dynamic &lt;variable_name&gt; = value;
</pre>
<p>For example,</p>
<pre class="prettyprint">
dynamic d = 20;
</pre>
<p>Dynamic types are similar to object types except that, type checking for object type variables takes place at compile time, whereas that for the dynamic type variables take place at run time. </p>
<h3>String Type</h3>
<p>The <b>String Type</b> allows you to assign any string values to a variable. The string type is an alias for the System.String class. It is derived from object type. The value for a string type can be assigned using string literals in two forms: quoted and @quoted.</p> 
<p>For example,</p>
<pre class="prettyprint">
String str = "Tutorials Point";
</pre>
<p>A @quoted string literal looks like:</p>
<pre class="prettyprint">
@"Tutorials Point";
</pre>
<p>The user defined reference types are: class, interface, or delegate. We will discuss these types in later chapter.</p>
<h2>Pointer Types</h2>
<p>Pointer type variables store the memory address of another type. Pointers in C# have the same capabilities as in C or C++. </p>
<p>Syntax for declaring a pointer type is:</p>
<pre class="prettyprint">
type* identifier;
</pre>
<p>For example,</p>
<pre class="prettyprint">
char* cptr;
int* iptr;
</pre>

<h1>C# - Type Conversion</h1>
<p>Type conversion is basically type casting, or converting one type of data to another type. In C#, type casting has two forms:</p>
<ul class="list">
<li><p><b>Implicit type conversion</b> - these conversions are performed by C# in a type-safe manner. Examples are conversions from smaller to larger integral types, and conversions from derived classes to base classes.</p></li>
<li><p><b>Explicit type conversion</b> - these conversions are done explicitly by users using the pre-defined functions. Explicit conversions require a cast operator.</p></li>
</ul>
<h2>C# Type Conversion Methods</h2>
<p>C# provides the following built-in type conversion methods:</p>
<table class="src">
<tr><th style="width:5%;">S.N</th><th>Methods & Description</th></tr>
<tr><td>1</td><td><b>ToBoolean</b><br>Converts a type to a Boolean value, where possible.</td></tr>
<tr><td>2</td><td><b>ToByte</b><br>Converts a type to a byte.</td></tr>
<tr><td>3</td><td><b>ToChar</b><br>Converts a type to a single Unicode character, where possible.</td></tr>
<tr><td>4</td><td><b>ToDateTime</b><br>Converts a type (integer or string type) to date-time structures.</td></tr>
<tr><td>5</td><td><b>ToDecimal</b><br>Converts a floating point or integer type to a decimal type.</td></tr>
<tr><td>6</td><td><b>ToDouble</b><br>Converts a type to a double type.</td></tr>
<tr><td>7</td><td><b>ToInt16</b><br>Converts a type to a 16-bit integer.</td></tr>
<tr><td>8</td><td><b>ToInt32</b><br>Converts a type to a 32-bit integer.</td></tr>
<tr><td>9</td><td><b>ToInt64</b><br>Converts a type to a 64-bit integer.</td></tr>
<tr><td>10</td><td><b>ToSbyte</b><br>Converts a type to a signed byte type.</td></tr>
<tr><td>11</td><td><b>ToSingle</b><br>Converts a type to a small floating point number.</td></tr>
<tr><td>12</td><td><b>ToString</b><br>Converts a type to a string.</td></tr>
<tr><td>13</td><td><b>ToType</b><br>Converts a type to a specified type.</td></tr>
<tr><td>14</td><td><b>ToUInt16</b><br>Converts a type to an unsigned int type.</td></tr>
<tr><td>15</td><td><b>ToUInt32</b><br>Converts a type to an unsigned long type.</td></tr>
<tr><td>16</td><td><b>ToUInt64</b><br>Converts a type to an unsigned big integer.</td></tr>
</table>
<p>The following example converts various value types to string type:</p>
<pre class="prettyprint">
namespace TypeConversionApplication
{
    class StringConversion
    {
        static void Main(string[] args)
        {
            int i = 75;
            float f = 53.005f;
            double d = 2345.7652;
            bool b = true;

            Console.WriteLine(i.ToString());
            Console.WriteLine(f.ToString());
            Console.WriteLine(d.ToString());
            Console.WriteLine(b.ToString());
            Console.ReadKey();
            
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
75
53.005
2345.7652
True
</pre>
<h1>C# - Variables</h1>
<p>A variable is nothing but a name given to a storage area that our programs can manipulate. Each variable in C# has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>We have already discussed various data types. The basic value types provided in C# can be categorized as:</p>
<table class="src">
<tr><th style="width:25%;">Type</th><th>Example</th></tr>
<tr><td>Integral types</td><td>sbyte, byte, short, ushort, int, uint, long, ulong and char</td></tr>
<tr><td>Floating point types</td><td>float and double</td></tr>
<tr><td>Decimal types</td><td>decimal</td></tr>
<tr><td>Boolean types</td><td>true or false values, as assigned</td></tr>
<tr><td>Nullable types</td><td>Nullable data types</td></tr>
</table>
<p>C# also allows defining other value types of variable like <b>enum</b> and reference types of variables like <b>class</b>, which we will cover in subsequent chapters. For this chapter, let us study only basic variable types.</p>
<h2>Variable Declaration in C#</h2>
<p>Syntax for variable declaration in C# is:</p>
<pre class="prettyprint">
&lt;data_type&gt; &lt;variable_list&gt;;
</pre>
<p>Here, data_type must be a valid C# data type including char, int, float, double, or any user defined data type etc., and variable_list may consist of one or more identifier names separated by commas. </p>
<p>Some valid variable declarations along with their definition are shown here:</p>
<pre class="prettyprint">
int i, j, k;
char c, ch;
float f, salary;
double d;
</pre>
<p>You can initialize a variable at the time of declaration as:</p>
<pre class="prettyprint">
int i = 100;
</pre>
<h2>Variable Initialization in C#</h2>
<p>Variables are initialized (assigned a value) with an equal sign followed by a constant expression. The general form of initialization is:</p>
<pre class="prettyprint">
variable_name = value;
</pre>
<p>Variables can be initialized (assigned an initial value) in their declaration. The initializer consists of an equal sign followed by a constant expression as:</p>
<pre class="prettyprint">
&lt;data_type&gt; &lt;variable_name&gt; = value;
</pre>
<p>Some examples are:</p>
<pre class="prettyprint">
int d = 3, f = 5;    /* initializing d and f. */
byte z = 22;         /* initializes z. */
double pi = 3.14159; /* declares an approximation of pi. */
char x = 'x';        /* the variable x has the value 'x'. */
</pre>
<h2>Lvalues and Rvalues in C#:</h2>
<p>There are two kinds of expressions in C#:</p>
<ol class="list">
<li><p><b>lvalue :</b> An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p></li>
<li><p><b>rvalue :</b> An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p></li>
</ol>
<p>Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned and can not appear on the left-hand side. Following is a valid statement:</p>
<pre class="prettyprint">
int g = 20;
</pre>
<p>But following is not a valid statement and would generate compile-time error:</p>
<pre class="prettyprint">
10 = 20;
</pre>
<h1>C# - Constants and Literals</h1>
<p>The constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals. Constants can be of any of the basic data types like an integer constant, a floating constant, a character constant, or a string literal. There are also enumeration constants as well.</p>
<p>The constants are treated just like regular variables except that their values cannot be modified after their definition.</p>
<h2>Integer Literals</h2>
<p>An integer literal can be a decimal, octal, or hexadecimal constant. A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for <p>An integer literal can also have a suffix that is a combination of U and L, for unsigned and long, respectively. The suffix can be uppercase or lowercase and can be in any order.</p>
<p>Here are some examples of integer literals:</p>
<pre class="prettyprint">
212         /* Legal */
215u        /* Legal */
0xFeeL      /* Legal */
078         /* Illegal: 8 is not an octal digit */
032UU       /* Illegal: cannot repeat a suffix */
</pre>
<p>Following are other examples of various types of Integer literals:</p>
<pre class="prettyprint">
85         /* decimal */
0213       /* octal */
0x4b       /* hexadecimal */
30         /* int */
30u        /* unsigned int */
30l        /* long */
30ul       /* unsigned long */
</pre>
<h2>Floating-point Literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or exponential form.</p>
<p>Here are some examples of floating-point literals:</p>
<pre class="prettyprint">
3.14159       /* Legal */
314159E-5L    /* Legal */
510E          /* Illegal: incomplete exponent */
210f          /* Illegal: no decimal or exponent */
.e55          /* Illegal: missing integer or fraction */
</pre>
<p>While representing using decimal form, you must include the decimal point, the exponent, or both and while representing using exponential form you must include the integer part, the fractional part, or both. The signed exponent is introduced by e or E.</p>
<h2>Character Constants</h2>
<p>Character literals are enclosed in single quotes e.g., 'x' and can be stored in a simple variable of char type. A character literal can be a plain character (e.g., 'x'), an escape sequence (e.g., '\t'), or a universal character (e.g., '\u02C0').</p>
<p>There are certain characters in C# when they are proceeded by a back slash they will have special meaning and they are used to represent like newline (\n) or tab (\t). Here you have a list of some of such escape sequence codes:</p>
<table class="src">
<tr><th style="width:20%">Escape sequence</th><th>Meaning</th></tr>
<tr><td>\\</td><td>\ character</td></tr>
<tr><td>\'</td><td> ' character</td></tr>
<tr><td>\"</td><td>" character</td></tr>
<tr><td>\?</td><td>? character</td></tr>
<tr><td>\a</td><td>Alert or bell</td></tr>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>Newline</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\ooo</td><td>Octal number of one to three digits</td></tr>
<tr><td>\xhh . . .</td><td>Hexadecimal number of one or more digits</td></tr>
</table>
<h2>String Literals</h2>
<p>String literals or constants are enclosed in double quotes "" or with @"". A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.</p>
<p>You can break a long line into multiple lines using string literals and separating the parts using whitespaces.</p>
<p>Here are some examples of string literals. All the three forms are identical strings.</p>
<pre class="prettyprint">
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
@"hello dear"
</pre>
<h2>Defining Constants</h2>
<p>Constants are defined using the <b>const</b> keyword. Syntax for defining a constant is:</p>
<pre class="prettyprint">
const &lt;data_type&gt; &lt;constant_name&gt; = value;
</pre>
<h1>C# - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. C# is rich in built-in operators and provides the following type of operators:</p>
<ul class="list">
<li><p>Arithmetic Operators</p></li>
<li><p>Relational Operators</p></li>
<li><p>Logical Operators</p></li>
<li><p>Bitwise Operators</p></li>
<li><p>Assignment Operators</p></li>
<li><p>Misc Operators</p></li>
</ul>
<p>This tutorial will explain the arithmetic, relational, and logical, bitwise, assignment and other operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>Following table shows all the arithmetic operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>
<p><a href="csharp_arithmetic_operators.html" title="Arithmetic Operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>+</td><td>Adds two operands</td><td> A + B will give 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first</td><td> A - B will give -10</td></tr>
<tr><td>*</td><td>Multiply both operands</td><td> A * B will give 200</td></tr>
<tr><td>/</td><td>Divide numerator by de-numerator</td><td> B / A will give 2</td></tr>
<tr><td>%</td><td>Modulus Operator and remainder of after an integer division</td><td> B % A will give 0</td></tr>
<tr><td>++</td><td>Increment operator increases integer value by one</td><td> A++ will give 11</td></tr>
<tr><td>--</td><td>Decrement operator decreases integer value by one</td><td> A-- will give 9</td></tr>
</table>
<h2>Relational Operators</h2>
<p>Following table shows all the relational operators supported by C#. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then:</p>
<p><a href="csharp_relational_operators.html" title="Relational Operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>==</td><td> Checks if the value of two operands is equal or not, if yes then condition becomes true.</td><td> (A == B) is not true. </td></tr>
<tr><td>!=</td><td> Checks if the value of two operands is equal or not, if values are not equal then condition becomes true.</td><td> (A != B) is true. </td></tr>
<tr><td>&gt;</td><td> Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td><td> (A &gt; B) is not true. </td></tr>
<tr><td>&lt;</td><td> Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td><td> (A &lt; B) is true. </td></tr>
<tr><td>&gt;=</td><td> Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &gt;= B) is not true. </td></tr>
<tr><td>&lt;=</td><td> Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td> (A &lt;= B) is true. </td></tr>
</table>
<h2>Logical Operators</h2>
<p>Following table shows all the logical operators supported by C#. Assume variable <b>A</b> holds Boolean value true and variable <b>B</b> holds Boolean value false then:</p>
<p><a href="csharp_logical_operators.html" title="Logical Operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;&amp;</td><td> Called Logical AND  operator. If both the operands are non zero then condition becomes true.</td><td> (A &amp;&amp; B) is false. </td></tr>
<tr><td>||</td><td>Called Logical OR Operator.  If any of the two operands is non zero then condition becomes true.</td><td> (A || B) is true. </td></tr>
<tr><td>!</td><td>Called Logical NOT Operator.  Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td><td> !(A &amp;&amp; B) is true. </td></tr>
</table>
<h2>Bitwise Operators</h2>
<p><a href="csharp_bitwise_operators.html" title="Bitwise Operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>&amp;</td><td> Binary AND Operator copies a bit to the result if it exists in both operands. </td><td> (A &amp; B) will give 12 which is 0000 1100</td></tr>
<tr><td>|</td><td> Binary OR Operator copies a bit if it exists in either operand. </td><td> (A | B) will give 61 which is 0011 1101</td></tr>
<tr><td>^</td><td> Binary XOR Operator copies the bit if it is set in one operand but not both. </td><td> (A ^ B) will give 49 which is 0011 0001</td></tr>
<tr><td>~</td><td> Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. </td><td> (~A ) will give -60 which is 1100 0011</td></tr>
<tr><td>&lt;&lt;</td><td> Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. </td><td> A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
<tr><td>&gt;&gt;</td><td> Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. </td><td> A &gt;&gt; 2 will give 15 which is 0000 1111</td></tr>
</table>
<h2>Assignment Operators</h2>
<p>There are following assignment operators supported by C#:</p>
<p><a href="csharp_assignment_operators.html" title="Assignment Operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr><td>=</td><td>Simple assignment operator, Assigns values from right side operands to left side operand</td><td> C = A + B will assign value of A + B into C</td></tr>
<tr><td>+=</td><td>Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand</td><td> C += A is equivalent to C = C + A</td></tr>
<tr><td>-=</td><td>Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand</td><td> C -= A is equivalent to C = C - A</td></tr>
<tr><td>*=</td><td>Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand</td><td> C *= A is equivalent to C = C * A</td></tr>
<tr><td>/=</td><td>Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand</td><td> C /= A is equivalent to C = C / A</td></tr>
<tr><td>%=</td><td>Modulus AND assignment operator, It takes modulus using two operands and assign the result to  left operand</td><td> C %= A is equivalent to C = C % A</td></tr>
<tr><td>&lt;&lt;=</td><td>Left shift AND assignment operator </td><td> C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td></tr>
<tr><td>&gt;&gt;=</td><td>Right shift AND assignment operator </td><td> C &gt;&gt;= 2 is same as  C = C &gt;&gt; 2</td></tr>
<tr><td>&amp;=</td><td>Bitwise AND assignment operator</td><td> C &amp;= 2 is same as  C = C &amp; 2</td></tr>
<tr><td>^=</td><td>bitwise exclusive OR and assignment operator</td><td> C ^= 2 is same as  C = C ^ 2</td></tr>
<tr><td>|=</td><td>bitwise inclusive OR and assignment operator</td><td> C |= 2 is same as  C = C | 2</td></tr>
</table>
<h2>Misc Operators</h2>
<p>There are few other important operators including <b>sizeof, typeof</b> and <b>? :</b>  supported by C#.</p>
<p><a href="csharp_misc_operators.html" title="misc operators in C#">Show Examples</a></p>
<table class="src">
<tr><th style="width:10%">Operator</th><th style="width:55%;">Description</th><th>Example</th></tr>
<tr>
<td>sizeof()</td><td>Returns the size of a data type.</td><td>sizeof(int), will return 4.</td>
</tr>
<tr>
<td>typeof()</td><td>Returns the type of a class.</td><td>typeof(StreamReader);</td>
</tr>
<tr>
<td>&amp;</td><td>Returns the address of an variable.</td><td>&amp;a; will give actual address of the variable.</td>
</tr>
<tr>
<td>*</td><td>Pointer to a variable.</td><td>*a; will pointer to a variable.</td>
</tr>
<tr>
<td>? :</td><td>Conditional Expression</td><td> If Condition is true ? Then value X : Otherwise value Y</td>
</tr>
<tr>
<td>is</td><td>Determines whether an object is of a certain type.</td><td>If( Ford is Car)  // checks if Ford is an object of the Car class.</td>
</tr>
<tr>
<td>as</td><td>Cast without raising an exception if the cast fails.</td><td>Object obj = new StringReader("Hello");<br>    
StringReader r = obj as StringReader;
</td>
</tr>
</table>
<h2>Operators Precedence in C#</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:</p>
<p>For example x = 7 + 3 * 2;  Here  x is assigned 13, not 20 because operator * has higher precedence than + so it first get multiplied with 3*2 and then adds into 7.</p>
 <p>Here operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<p><a href="csharp_operators_precedence.html" title="Operators Precedence in C#">Show Examples</a></p>
<table class="src">
<tr> <th>Category&nbsp;</th> <th>Operator&nbsp;</th><th>Associativity&nbsp;</th> </tr> 
<tr> <td>Postfix&nbsp;</td><td>() [] -&gt; .  ++   - - &nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Unary&nbsp;</td> <td>+  -   !  ~  ++  - -   (type)*  &amp;  sizeof&nbsp;</td> <td>Right to left&nbsp;</td></tr> 
<tr> <td>Multiplicative &nbsp;</td> <td>*  /  %&nbsp;</td><td>Left to right&nbsp;</td> </tr> 
<tr> <td>Additive &nbsp;</td><td>+  -&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Shift &nbsp;</td> <td>&lt;&lt; &gt;&gt;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Relational &nbsp;</td><td>&lt; &lt;=  &gt; &gt;=&nbsp;</td> <td>Left to right&nbsp;</td> </tr>
<tr> <td>Equality &nbsp;</td> <td>==  !=&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise AND&nbsp;</td><td>&amp;&nbsp;</td> <td>Left to right&nbsp;</td> </tr> 
<tr> <td>Bitwise XOR&nbsp;</td> <td>^&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Bitwise OR&nbsp;</td> <td>|&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Logical AND&nbsp;</td><td>&amp;&amp;&nbsp;</td> <td>Left to right&nbsp;</td></tr>
<tr><td>Logical OR&nbsp;</td> <td>||&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
<tr> <td>Conditional&nbsp;</td><td>?:&nbsp;</td> <td>Right to left&nbsp;</td> </tr>
<tr><td>Assignment&nbsp;</td> <td>=  +=  -=  *=  /=  %=&gt;&gt;=  &lt;&lt;=  &amp;=  ^=   |=&nbsp;</td><td>Right to left&nbsp;</td></tr>
<tr> <td>Comma&nbsp;</td> <td>,&nbsp;</td> <td>Left to right&nbsp;</td></tr> 
</table>
<h1>C# - Decision Making</h1>
<p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
<p>Following is the general from of a typical decision making structure found in most of the programming languages:</p>
<img src="../images/decision_making.jpg" alt="Decision making statements in C#" />
<p>C# provides following types of decision making statements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:35%">Statement</th><th>Description</th></tr>
<tr><td><a href="if_statement_in_csharp.html" title="if statement in C#">if statement</a></td><td>An <b>if statement</b> consists of a boolean expression followed by one or more statements.</td></tr>
<tr><td><a href="if_else_statement_in_csharp.html" title="if...else statement in C#">if...else statement</a></td><td>An <b>if statement</b> can be followed by an optional <b>else statement</b>, which executes when the boolean expression is false.</td></tr>
<tr><td><a href="nested_if_statements_in_csharp.html" title="nested if statements in C#">nested if statements</a></td><td>You can use one <b>if</b> or <b>else if</b> statement inside another <b>if</b> or <b>else if</b> statement(s).</td></tr>
<tr><td><a href="switch_statement_in_csharp.html" title="switch statement in C#">switch statement</a></td><td>A <b>switch</b> statement allows a variable to be tested for equality against a list of values.</td></tr>
<tr><td><a href="nested_switch_statements_in_csharp.html" title="nested switch statements in C#">nested switch statements</a></td><td>You can use one <b>swicth</b> statement inside another <b>switch</b> statement(s).</td></tr>
</table>
<h1>C# - Loops</h1>
<p>There may be a situation when you need to execute a block of code several number of times. In general statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general from of a loop statement in most of the programming languages:</p>
<img src="../images/loop_architecture.jpg" alt="Loop Architecture" />
<p>C# provides following types of loop to handle looping requirements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:30%">Loop Type</th><th>Description</th></tr>
<tr><td><a href="csharp_while_loop.html" title="while loop in C#">while loop</a></td><td>Repeats a statement or group of statements until a given condition is true. It tests the condition before executing the loop body.</td></tr>
<tr><td><a href="csharp_for_loop.html" title="for loop in C#">for loop</a></td><td>Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.</td></tr>
<tr><td><a href="csharp_do_while_loop.html" title="do...while loop in C#">do...while loop</a></td><td>Like a while statement, except that it tests the condition at the end of the loop body</td></tr>
<tr><td><a href="csharp_nested_loops.html" title="nested loops in C#">nested loops</a></td><td>You can use one or more loop inside any another while, for or do..while loop.</td></tr>
</table>
<h2>Loop Control Statements:</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>C# provides the following control statements. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:30%">Control Statement</th><th>Description</th></tr>
<tr><td><a href="csharp_break_statement.html" title="break statement in C#">break statement</a></td><td>Terminates the <b>loop</b> or <b>switch</b> statement and transfers execution to the statement immediately following the loop or switch.</td></tr>
<tr><td><a href="csharp_continue_statement.html" title="continue statement in C#">continue statement</a></td><td>Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.</td></tr>
</table>
<h1>C# - Encapsulation</h1>
<p><b>Encapsulation</b> is defined 'as the process of enclosing one or more items within a physical or logical package'. Encapsulation, in object oriented programming methodology, prevents access to implementation details. </p>
<p>Abstraction and encapsulation are related features in object oriented programming. Abstraction allows making relevant information visible and encapsulation enables a programmer to <i>implement the desired level of abstraction</i>.</p>
<p>Encapsulation is implemented by using <b>access specifiers</b>. An <b>access specifier</b> defines the scope and visibility of a class member. C# supports the following access specifiers:</p>
<ul class="list">
<li><p>Public</p></li>
<li><p>Private</p></li>
<li><p>Protected</p></li>
<li><p>Internal</p></li>
<li><p>Protected internal</p></li>
</ul>
<h2>Public Access Specifier</h2>
<p>Public access specifier allows a class to expose its member variables and member functions to other functions and objects. Any public member can be accessed from outside the class.</p> 
<p>The following example illustrates this:</p>
<pre class="prettyprint">
using System;

namespace RectangleApplication
{
    class Rectangle
    {
        //member variables
        public double length;
        public double width;

        public double GetArea()
        {
            return length * width;
        }
        public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }//end class Rectangle    
    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.length = 4.5;
			r.width = 3.5;
            r.Display();
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<p>In the preceding example, the member variables length and width are declared <b>public</b>, so they can be accessed from the function Main() using an instance of the Rectangle class, named <b>r</b>.</p>
<p>The member function <i>Display()</i> and <i>GetArea()</i> can also access these variables directly without using any instance of the class.</p>
<p>The member functions <i>Display()</i> is also declared <b>public</b>, so it can also be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>
<h2>Private Access Specifier</h2>
<p>Private access specifier allows a class to hide its member variables and member functions from other functions and objects. Only functions of the same class can access its private members. Even an instance of a class cannot access its private members. </p>
<p>The following example illustrates this:</p>
<pre class="prettyprint">
using System;

namespace RectangleApplication
{
    class Rectangle
    {
        //member variables
        private double length;
        private double width;

        public void Acceptdetails()
        {
            Console.WriteLine("Enter Length: ");
            length = Convert.ToDouble(Console.ReadLine());
            Console.WriteLine("Enter Width: ");
            width = Convert.ToDouble(Console.ReadLine());
        }
        public double GetArea()
        {
            return length * width;
        }
        public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }//end class Rectangle    
    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.Acceptdetails();
            r.Display();
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Enter Length:
4.4
Enter Width:
3.3
Length: 4.4
Width: 3.3
Area: 14.52
</pre>
<p>In the preceding example, the member variables length and width are declared <b>private</b>, so they cannot be accessed from the function Main(). The member functions <i>AcceptDetails()</i> and <i>Display()</i> can access these variables. Since the member functions <i>AcceptDetails()</i> and <i>Display()</i> are declared <b>public</b>, they can be accessed from <i>Main()</i> using an instance of the Rectangle class, named <b>r</b>. </p>
<h2>Protected Access Specifier</h2>
<p>Protected access specifier allows a child class to access the member variables and member functions of its base class. This way it helps in implementing inheritance. We will discuss this in more details in the inheritance chapter. </p>
<h2>Internal Access Specifier</h2>
<p>Internal access specifier allows a class to expose its member variables and member functions to other functions and objects in the current assembly. In other words, any member with internal access specifier can be accessed from any class or method defined within the application in which the member is defined. </p>
<p>The following program illustrates this:</p>
<pre class="prettyprint">
using System;

namespace RectangleApplication
{
    class Rectangle
    {
        //member variables
        internal double length;
        internal double width;
        
        double GetArea()
        {
            return length * width;
        }
       public void Display()
        {
            Console.WriteLine("Length: {0}", length);
            Console.WriteLine("Width: {0}", width);
            Console.WriteLine("Area: {0}", GetArea());
        }
    }//end class Rectangle    
    class ExecuteRectangle
    {
        static void Main(string[] args)
        {
            Rectangle r = new Rectangle();
            r.length = 4.5;
            r.width = 3.5;
            r.Display();
            Console.ReadLine();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Length: 4.5
Width: 3.5
Area: 15.75
</pre>
<p>In the preceding example, notice that the member function <i>GetArea()</i> is not declared with any access specifier. Then what would be the default access specifier of a class member if we don't mention any? It is <b>private</b>.</p>
<h2>Protected Internal Access Specifier</h2>
<p>The protected internal access specifier allows a class to hide its member variables and member functions from other class objects and functions, except a child class within the same application. This is also used while implementing inheritance. </p>
<h1>C# - Methods</h1>
<p>A method is a group of statements that together perform a task. Every C# program has at least one class with a method named Main.</p>
<p>To use a method, you need to:</p>
<ul class="list">
<li><p>Define the method</p></li>
<li><p>Call the method</p></li>
</ul>
<h2>Defining Methods in C#</h2>
<p>When you define a method, you basically declare the elements of its structure. The syntax for defining a method in C# is as follows:</p>
<pre class="prettyprint">
&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)
{
   Method Body
}
</pre>
<p>Following are the various elements of a method:</p>
<ul class="list">
<li><p><b>Access Specifier</b>:  This determines the visibility of a variable or a method from another class.</p></li>
<li><p><b>Return type</b>: A method may return a value. The return type is the data type of the value the method returns. If the method is not returning any values, then the return type is <b>void</b>.</p></li>
<li><p><b>Method name</b>: Method name is a unique identifier and it is case sensitive. It cannot be same as any other identifier declared in the class. </p></li>
<li><p><b>Parameter list</b>: Enclosed between parentheses, the parameters are used to pass and receive data from a method. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.</p></li>
<li><p><b>Method body</b>: This contains the set of instructions needed to complete the required activity. </p></li>
</ul>
<h2>Example:</h2>
<p>Following code snippet shows a function <i>FindMax</i> that takes two integer values and returns the larger of the two. It has public access specifier, so it can be accessed from outside the class using an instance of the class.</p>
<pre class="prettyprint">
class NumberManipulator
{
   public int FindMax(int num1, int num2)
   {
      /* local variable declaration */
      int result;

      if (num1 &gt; num2)
         result = num1;
      else
         result = num2;

      return result;
   }
   ...
}
</pre>
<h2>Calling Methods in C#</h2>
<p>You can call a method using the name of the method. The following example illustrates this:</p>
<pre class="prettyprint">
using System;

namespace CalculatorApplication
{
   class NumberManipulator
   {
      public int FindMax(int num1, int num2)
      {
         /* local variable declaration */
         int result;

         if (num1 &gt; num2)
            result = num1;
         else
            result = num2;

         return result;
      }
      static void Main(string[] args)
      {
         /* local variable definition */
         int a = 100;
         int b = 200;
         int ret;
         NumberManipulator n = new NumberManipulator();

         //calling the FindMax method
         ret = n.FindMax(a, b);
         Console.WriteLine("Max value is : {0}", ret );
         Console.ReadLine();
      }
   }
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Max value is : 200
</pre>
<h1>C# - Nullables</h1>
<p>C# provides a special data types, the <b>nullable</b> types, to which you can assign normal range of values as well as null values.</p>
<p>For example, you can store any value from -2,147,483,648 to 2,147,483,647 or null in a Nullable&lt; Int32 &gt; variable. Similarly, you can assign true, false or null in a Nullable&lt; bool &gt; variable. Syntax for declaring a <b>nullable</b> type is as follows:</p>
<pre class="prettyprint">
&lt; data_type&gt; ? &lt;variable_name&gt; = null;
</pre>
<p>The following example demonstrates use of nullable data types:</p>
<pre class="prettyprint">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
      static void Main(string[] args)
      {
         int? num1 = null;
         int? num2 = 45;
         double? num3 = new double?();
         double? num4 = 3.14157;
         
         bool? boolval = new bool?();

         // display the values
         
         Console.WriteLine("Nullables at Show: {0}, {1}, {2}, {3}", 
                            num1, num2, num3, num4);
         Console.WriteLine("A Nullable boolean value: {0}", boolval);
         Console.ReadLine();

      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Nullables at Show: , 45,  , 3.14157
A Nullable boolean value:
</pre>
<h2>The Null Coalescing Operator (??)</h2>
<p>The null coalescing operator is used with the nullable value types and reference types. It is used for converting an operand to the type of another nullable( or not) value type operand, where an implicit conversion is possible.</p> 
<p>If the value of the first operand is null, then the operator returns the value of the second operand, otherwise it returns the value of the first operand. The following example explains this:</p>
<pre class="prettyprint">
using System;
namespace CalculatorApplication
{
   class NullablesAtShow
   {
         
      static void Main(string[] args)
      {
         
         double? num1 = null;
         double? num2 = 3.14157;
         double num3;
         num3 = num1 ?? 5.34;      
         Console.WriteLine(" Value of num3: {0}", num3);
         num3 = num2 ?? 5.34;
         Console.WriteLine(" Value of num3: {0}", num3);
         Console.ReadLine();

      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Value of num3: 5.34
Value of num3: 3.14157
</pre>
<h1>C# - Arrays</h1>
<p>An array stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.</p>
<p>Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables. A specific element in an array is accessed by an index.</p>
<p>All arrays consist of contiguous memory locations. The lowest address corresponds to the first element and the highest address to the last element.</p>
<img src="../images/arrays.jpg" alt="Arrays in C#" />
<h2>Declaring Arrays</h2>
<p>To declare an array in C#, you can use the following syntax:</p>
<pre class="prettyprint">
datatype[] arrayName;
</pre>
<p>where, </p>
<ul class="list">
<li><p>d<i>atatype</i> is used to specify the type of elements to be stored in the array.</p></li>
<li><p><i>[ ]</i> specifies the rank of the array. The rank specifies the size of the array. </p></li>
<li><p><i>arrayName</i> specifies the name of the array.</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint">
double[] balance;
</pre>
<h2>Initializing an Array</h2>
<p>Declaring an array does not initialize the array in the memory. When the array variable is initialized, you can assign values to the array. </p>
<p>Array is a reference type, so you need to use the <b>new</b> keyword to create an instance of the array.</p> 
<p>For example,</p>
<pre class="prettyprint">
double[] balance = new double[10];
</pre>
<h2>Assigning Values to an Array</h2>
<p>You can assign values to individual array elements, by using the index number, like:</p>
<pre class="prettyprint">
double[] balance = new double[10];
balance[0] = 4500.0;
</pre>
<p>You can assign values to the array at the time of declaration, like:</p>
<pre class="prettyprint">
double[] balance = { 2340.0, 4523.69, 3421.0};
</pre>
<p>You can also create and initialize an array, like:</p>
<pre class="prettyprint">
int [] marks = new int[5]  { 99,  98, 92, 97, 95};
</pre>
<p>In the preceding case, you may also omit the size of the array, like:</p>
<pre class="prettyprint">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
</pre>
<p>You can also copy an array variable into another target array variable. In that case, both the target and source would point to the same memory location:</p>
<pre class="prettyprint">
int [] marks = new int[]  { 99,  98, 92, 97, 95};
int[] score = marks;
</pre>
<p>When you create an array, C# compiler implicitly initializes each array element to a default value depending on the array type. For example for an int array all elements would be initialized to 0. </p>
<h2>Accessing Array Elements</h2>
<p>An element is accessed by indexing the array name. This is done by placing the index of the element within square brackets after the name of the array. For example:</p>
<pre class="prettyprint">
double salary = balance[9];
</pre>
<p>Following is an example which will use all the above mentioned three concepts viz. declaration, assignment and accessing arrays:</p>
<pre class="prettyprint">
using System;
namespace ArrayApplication
{
   class MyArray
   {
      static void Main(string[] args)
      {
         int []  n = new int[10]; /* n is an array of 10 integers */
         int i,j;


         /* initialize elements of array n */         
         for ( i = 0; i &lt; 10; i++ )
         {
            n[ i ] = i + 100;
         }

         /* output each array element's value */
         for (j = 0; j &lt; 10; j++ )
         {
            Console.WriteLine("Element[{0}] = {1}", j, n[j]);
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
</pre>
<h1>C# - Strings</h1>
<p>In C# you can use strings as array of characters, however, more common practice is to use the <b>string</b> keyword to declare a string variable. The string keyword is an alias for the <b>System.String</b> class. </p>
<h2>Creating a String Object</h2>
<p>You can create string object using one of the following methods:</p>
<ul class="list">
<li><p>By assigning a string literal to a String variable</p></li>
<li><p>By using a String class constructor</p></li>
<li><p>By using the string concatenation operator (+)</p></li>
<li><p>By retrieving a property or calling a method that returns a string</p></li>
<li><p>By calling a formatting method to convert a value or object to its string representation</p></li>
</ul>
<p>The following example demonstrates this:</p>
<pre class="prettyprint">
using System;

namespace StringApplication
{
    class Program
    {
        static void Main(string[] args)
        {
           //from string literal and string concatenation
            string fname, lname;
            fname = "Rowan";
            lname = "Atkinson";

            string fullname = fname + lname;
            Console.WriteLine("Full Name: {0}", fullname);

            //by using string constructor
            char[] letters = { 'H', 'e', 'l', 'l','o' };
            string greetings = new string(letters);
            Console.WriteLine("Greetings: {0}", greetings);

            //methods returning string
            string[] sarray = { "Hello", "From", "Tutorials", "Point" };
            string message = String.Join(" ", sarray);
            Console.WriteLine("Message: {0}", message);

            //formatting method to convert a value 
            DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1);
            string chat = String.Format("Message sent at {0:t} on {0:D}", 
            waiting);
            Console.WriteLine("Message: {0}", chat);
            Console.ReadKey() ;
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Full Name: Rowan Atkinson
Greetings: Hello
Message: Hello From Tutorials Point
Message: Message sent at 5:58 PM on Wednesday, October 10, 2012
</pre>

<h1>C# - Structures</h1>
<p>In C#, a structure is a value type data type. It helps you to make a single variable hold related data of various data types. The <b>struct</b> keyword is used for creating a structure. </p>
<p>Structures are used to represent a record. Suppose you want to keep track of your books in a library. You might want to track the following attributes about each book:</p>
<ul class="list">
<li><p>Title</p></li>
<li><p>Author</p></li>
<li><p>Subject</p></li>
<li><p>Book ID</p></li>
</ul>
<h2>Defining a Structure</h2>
<p>To define a structure, you must use the struct statement. The struct statement defines a new data type, with more than one member for your program.</p> 
<p>For example, here is the way you would declare the Book structure:</p>
<pre class="prettyprint">
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  
</pre>
<p>The following program shows the use of the structure:</p>
<pre class="prettyprint">
using System;
     
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
};  

public class testStructure
{
   public static void Main(string[] args)
   {

      Books Book1;        /* Declare Book1 of type Book */
      Books Book2;        /* Declare Book2 of type Book */

      /* book 1 specification */
      Book1.title = "C Programming";
      Book1.author = "Nuha Ali"; 
      Book1.subject = "C Programming Tutorial";
      Book1.book_id = 6495407;

      /* book 2 specification */
      Book2.title = "Telecom Billing";
      Book2.author = "Zara Ali";
      Book2.subject =  "Telecom Billing Tutorial";
      Book2.book_id = 6495700;

      /* print Book1 info */
      Console.WriteLine( "Book 1 title : {0}", Book1.title);
      Console.WriteLine("Book 1 author : {0}", Book1.author);
      Console.WriteLine("Book 1 subject : {0}", Book1.subject);
      Console.WriteLine("Book 1 book_id :{0}", Book1.book_id);

      /* print Book2 info */
      Console.WriteLine("Book 2 title : {0}", Book2.title);
      Console.WriteLine("Book 2 author : {0}", Book2.author);
      Console.WriteLine("Book 2 subject : {0}", Book2.subject);
      Console.WriteLine("Book 2 book_id : {0}", Book2.book_id);       

      Console.ReadKey();

   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
</pre>
<h1>C# - Enums</h1>
<p>An enumeration is a set of named integer constants. An enumerated type is declared using the <b>enum</b> keyword.</p>
<p>C# enumerations are value data type. In other words, enumeration contains its own values and cannot inherit or cannot pass inheritance.</p>
<h2>Declaring <i>enum</i> Variable</h2>
<p>The general syntax for declaring an enumeration is:</p>
<pre class="prettyprint">
enum &lt;enum_name&gt; 
{ 
    enumeration list 
};
</pre>
<p>Where,</p>
<ul class="list">
<li><p>The <i>enum_name</i> specifies the enumeration type name.</p></li>
<li><p>The <i>enumeration list</i> is a comma-separated list of identifiers.</p></li>
</ul>
<p>Each of the symbols in the enumeration list stands for an integer value, one greater than the symbol that precedes it. By default, the value of the first enumeration symbol is 0. For example:</p>
<pre class="prettyprint">
enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };
</pre>
<h2>Example:</h2>
<p>The following example demonstrates use of enum variable:</p>
<pre class="prettyprint">
using System;
namespace EnumApplication
{
   class EnumProgram
   {
      enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat };

      static void Main(string[] args)
      {
         int WeekdayStart = (int)Days.Mon;
         int WeekdayEnd = (int)Days.Fri;
         Console.WriteLine("Monday: {0}", WeekdayStart);
         Console.WriteLine("Friday: {0}", WeekdayEnd);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Monday: 1
Friday: 5
</pre>
<h1>C# - Classes</h1>
<p>When you define a class, you define a blueprint for a data type. This doesn't actually define any data, but it does define what the class name means, that is, what an object of the class will consist of and what operations can be performed on such an object. Objects are instances of a class. The methods and variables that constitute a class are called members of the class.</p>
<h2>Class Definition</h2>
<p>A class definition starts with the keyword class followed by the class name; and the class body, enclosed by a pair of curly braces. Following is the general form of a class definition:</p>
<pre class="prettyprint">
&lt;access specifier&gt; class  class_name 
{
    // member variables
    &lt;access specifier&gt; &lt;data type&gt; variable1;
    &lt;access specifier&gt; &lt;data type&gt; variable2;
    ...
    &lt;access specifier&gt; &lt;data type&gt; variableN;
    // member methods
    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list) 
    {
        // method body 
    }
    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list) 
    {
        // method body 
    }
    ...
    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list) 
    {
        // method body 
    }
}
</pre>
<p>Please note that,</p>
<ul class="list">
<li><p>Access specifiers specify the access rules for the members as well as the class itself, if not mentioned then the default access specifier for a class type is <b>internal</b>. Default access for the members is <b>private</b>. </p></li>
<li><p>Data type specifies the type of variable, and return type specifies the data type of the data, the method returns, if any.</p></li>
<li><p>To access the class members, you will use the dot (.) operator.</p></li>
<li><p>The dot operator links the name of an object with the name of a member.</p></li>
</ul>
<p>The following example illustrates the concepts discussed so far:</p>
<pre class="prettyprint">
using System;
namespace BoxApplication
{
    class Box
    {
       public double length;   // Length of a box
       public double breadth;  // Breadth of a box
       public double height;   // Height of a box
    }
    class Boxtester
    {
        static void Main(string[] args)
        {
            Box Box1 = new Box();        // Declare Box1 of type Box
            Box Box2 = new Box();        // Declare Box2 of type Box
            double volume = 0.0;         // Store the volume of a box here

            // box 1 specification
            Box1.height = 5.0;
            Box1.length = 6.0;
            Box1.breadth = 7.0;

            // box 2 specification
            Box2.height = 10.0;
            Box2.length = 12.0;
            Box2.breadth = 13.0;
           
            // volume of box 1
            volume = Box1.height * Box1.length * Box1.breadth;
            Console.WriteLine("Volume of Box1 : {0}",  volume);

            // volume of box 2
            volume = Box2.height * Box2.length * Box2.breadth;
            Console.WriteLine("Volume of Box2 : {0}", volume);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Volume of Box1 : 210
Volume of Box2 : 1560
</pre>
<h2>Constructors in C#</h2>
<p>A class <b>constructor</b> is a special member function of a class that is executed whenever we create new objects of that class.</p>
<p>A constructor will have exact same name as the class and it does not have any return type. Following example explains the concept of constructor:</p>
<pre class="prettyprint">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()
      {
         Console.WriteLine("Object is being created");
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();    
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Object is being created
Length of line : 6
</pre>
<h2>Destructors in C#</h2>
<p>A <b>destructor</b> is a special member function of a class that is executed whenever an object of its class goes out of scope. A <b>destructor</b> will have exact same name as the class prefixed with a tilde (~) and it can neither return a value nor can it take any parameters.</p>
<p>Destructor can be very useful for releasing resources before coming out of the program like closing files, releasing memories etc. Destructors cannot be inherited or overloaded.</p>
<p>Following example explain the concept of destructor:</p>
<pre class="prettyprint">
using System;
namespace LineApplication
{
   class Line
   {
      private double length;   // Length of a line
      public Line()  // constructor
      {
         Console.WriteLine("Object is being created");
      }
      ~Line() //destructor
      {
         Console.WriteLine("Object is being deleted");
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line();
         // set line length
         line.setLength(6.0);
         Console.WriteLine("Length of line : {0}", line.getLength());           
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Object is being created
Length of line : 6
Object is being deleted
</pre>
<h1>C# - Inheritance</h1>
<p>One of the most important concepts in object-oriented programming is that of inheritance. Inheritance allows us to define a class in terms of another class, which makes it easier to create and maintain an application. This also provides an opportunity to reuse the code functionality and fast implementation time.</p>
<p>When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the <b>base</b> class, and the new class is referred to as the <b>derived</b> class.</p>
<p>The idea of inheritance implements the <b>IS-A</b> relationship. For example, mammal <b>IS A</b> animal, dog <b>IS-A</b> mammal hence dog <b>IS-A</b> animal as well and so on.</p>
<h2>Base and Derived Classes</h2>
<p>A class can be derived from more than one class or interface, which means that it can inherit data and functions from multiple base class or interface. </p>
<p>The syntax used in C# for creating derived classes is as follows:</p>
<pre class="prettyprint">
&lt;acess-specifier&gt; class &lt;base_class&gt;
{
 ...
}
class &lt;derived_class&gt; : &lt;base_class&gt;
{
 ...
}
</pre>
<p>Consider a base class Shape and its derived class Rectangle:</p>
<pre class="prettyprint">
using System;
namespace InheritanceApplication
{
   class Shape 
   {
      public void setWidth(int w)
      {
         width = w;
      }
      public void setHeight(int h)
      {
         height = h;
      }
      protected int width;
      protected int height;
   }

   // Derived class
   class Rectangle: Shape
   {
      public int getArea()
      { 
         return (width * height); 
      }
   }
   
   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle Rect = new Rectangle();

         Rect.setWidth(5);
         Rect.setHeight(7);

         // Print the area of the object.
         Console.WriteLine("Total area: {0}",  Rect.getArea());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Total area: 35
</pre>
<h1>C# - Polymorphism</h1>
<p>The word <b>polymorphism</b> means having many forms. In object oriented programming paradigm, polymorphism is often expressed as 'one interface, multiple functions'. </p>
<p>Polymorphism can be static or dynamic. In <b>static polymorphism</b> the response to a function is determined at the compile time. In <b>dynamic polymorphism</b> it is decided at run time. </p>
<h2>Static Polymorphism</h2>
<p>The mechanism of linking a function with an object during compile time is called early binding. It is also called static binding. C# provides two techniques to implement static polymorphism. These are:</p>
<ul class="list">
<li><p>Function overloading</p></li>
<li><p>Operator overloading</p></li>
</ul>
<p>We will discuss function overloading in the next section and operator overloading will be dealt with in next chapter. </p>
<h2>Function Overloading</h2>
<p>You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.</p>
<p>Following is the example where same function <b>print()</b> is being used to print different data types:</p>
<pre class="prettyprint">
using System;
namespace PolymorphismApplication
{
   class Printdata
   {
      void print(int i)
      {
         Console.WriteLine("Printing int: {0}", i );
      }

      void print(double f)
      {
         Console.WriteLine("Printing float: {0}" , f);
      }

      void print(string s)
      {
         Console.WriteLine("Printing string: {0}", s);
      }
      static void Main(string[] args)
      {
         Printdata p = new Printdata();
         // Call print to print integer
         p.print(5);
         // Call print to print float
         p.print(500.263);
         // Call print to print string
         p.print("Hello C++");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Printing int: 5
Printing float: 500.263
Printing string: Hello C++
</pre>
<h2>Dynamic Polymorphism</h2>
<p>C# allows you to create abstract classes that are used to provide partial class implementation of an interface. Implementation is completed when a derived class inherits from it. <b>Abstract</b> classes contain abstract methods which are implemented by the derived class. The derived classes have more specialized functionality.</p>
<p>Please note the following rules about abstract classes:</p>
<ul class="list">
<li><p>You cannot create an instance of an abstract class</p></li>
<li><p>You cannot declare an abstract method outside an abstract class</p></li>
<li><p>When a class is declared <b>sealed</b>, it cannot be inherited, abstract classes cannot be declared sealed. </p></li>
</ul>
<p>The following program demonstrates an abstract class:</p>
<pre class="prettyprint">
using System;
namespace PolymorphismApplication
{
   abstract class Shape
   {
      public abstract int area();
   }
   class Rectangle:  Shape
   {
      private int length;
      private int width;
      public Rectangle( int a=0, int b=0)
      {
         length = a;
         width = b;
      }
      public override int area ()
      { 
         Console.WriteLine("Rectangle class area :");
         return (width * length); 
      }
   }

   class RectangleTester
   {
      static void Main(string[] args)
      {
         Rectangle r = new Rectangle(10, 7);
         double a = r.area();
         Console.WriteLine("Area: {0}",a);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Rectangle class area :
Area: 70
</pre>
<h1>C# - Operator Overloading</h1>
<p>You can redefine or overload most of the built-in operators available in C#. Thus a programmer can use operators with user-defined types as well. Overloaded operators are functions with special names the keyword <b>operator</b> followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type and a parameter list.</p>
<p>For example, look at the following function:</p>
<pre class="prettyprint">
public static Box operator+ (Box b, Box c)
{
   Box box = new Box();
   box.length = b.length + c.length;
   box.breadth = b.breadth + c.breadth;
   box.height = b.height + c.height;
   return box;
}
</pre>
<p>The above function implements the addition operator (+) for a user-defined class Box. It adds the attributes of two Box objects and returns the resultant Box object.</p>
<h2>Implementation of Operator Overloading</h2>
<p>The following program shows the complete implementation:</p>
<pre class="prettyprint">
using System;

namespace OperatorOvlApplication
{
   class Box
   {
      private double length;      // Length of a box
      private double breadth;     // Breadth of a box
      private double height;      // Height of a box

      public double getVolume()
      {
         return length * breadth * height;
      }
      public void setLength( double len )
      {
         length = len;
      }

      public void setBreadth( double bre )
      {
         breadth = bre;
      }

      public void setHeight( double hei )
      {
         height = hei;
      }
      // Overload + operator to add two Box objects.
      public static Box operator+ (Box b, Box c)
      {
         Box box = new Box();
         box.length = b.length + c.length;
         box.breadth = b.breadth + c.breadth;
         box.height = b.height + c.height;
         return box;
      }

   }

   class Tester
   {
      static void Main(string[] args)
      {
         Box Box1 = new Box();         // Declare Box1 of type Box
         Box Box2 = new Box();         // Declare Box2 of type Box
         Box Box3 = new Box();         // Declare Box3 of type Box
         double volume = 0.0;          // Store the volume of a box here

         // box 1 specification
         Box1.setLength(6.0);
         Box1.setBreadth(7.0);
         Box1.setHeight(5.0);

         // box 2 specification
         Box2.setLength(12.0);
         Box2.setBreadth(13.0);
         Box2.setHeight(10.0);

         // volume of box 1
         volume = Box1.getVolume();
         Console.WriteLine("Volume of Box1 : {0}", volume);

         // volume of box 2
         volume = Box2.getVolume();
         Console.WriteLine("Volume of Box2 : {0}", volume);

         // Add two object as follows:
         Box3 = Box1 + Box2;

         // volume of box 3
         volume = Box3.getVolume();
         Console.WriteLine("Volume of Box3 : {0}", volume);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Volume of Box1 : 210
Volume of Box2 : 1560
Volume of Box3 : 5400
</pre>
<h2>Overloadable and Non-Overloadable Operators</h2>
<p>The following table describes the overload ability of the operators in C#:</p>
<table class="src">
<tr><th style="width:25%;">Operators</th><th>Description</th></tr>
<tr><td>+, -, !, ~, ++, --</td><td>These unary operators take one operand and can be overloaded.</td></tr>
<tr><td>+, -, *, /, %</td><td>These binary operators take one operand and can be overloaded.</td></tr>
<tr><td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td><td>The comparison operators can be overloaded</td></tr>
<tr><td>&amp;&amp;, ||</td><td>The conditional logical operators cannot be overloaded directly. </td></tr>
<tr><td>+=, -=, *=, /=, %=</td><td>The assignment operators cannot be overloaded.</td></tr>
<tr><td>=, ., ?:, ->, new, is, sizeof, typeof</td><td>These operators cannot be overloaded.</td></tr>
</table>
<h1>C# - Interfaces</h1>
<p>An interface is defined as a syntactical contract that all the classes inheriting the interface should follow. The interface defines the <b>'what'</b> part of the syntactical contract and the deriving classes define the <b>'how'</b> part of the syntactical contract. </p>
<p>Interfaces define properties, methods and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure that the deriving classes would follow. </p>
<p>Abstract classes to some extent serve the same purpose, however, they are mostly used when only few methods are to be declared by the base class and the deriving class implements the functionalities. </p>
<h2>Declaring Interfaces</h2>
<p>Interfaces are declared using the interface keyword. It is similar to class declaration. Interface statements are public by default. Following is an example of an interface declaration:</p>
<pre class="prettyprint">
public interface ITransactions
{
   // interface members
   void showTransaction();
   double getAmount();
}
</pre>
<h2>Example</h2>
<p>The following example demonstrates implementation of the above interface:</p>
<pre class="prettyprint">
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace InterfaceApplication
{

   public interface ITransactions
   {
      // interface members
      void showTransaction();
      double getAmount();
   }
   public class Transaction : ITransactions
   {
      private string tCode;
      private string date;
      private double amount;
      public Transaction()
      {
         tCode = " ";
         date = " ";
         amount = 0.0;
      }
      public Transaction(string c, string d, double a)
      {
         tCode = c;
         date = d;
         amount = a;
      }
      public double getAmount()
      {
         return amount;
      }
      public void showTransaction()
      {
         Console.WriteLine("Transaction: {0}", tCode);
         Console.WriteLine("Date: {0}", date);
         Console.WriteLine("Amount: {0}", getAmount());

      }

   }
   class Tester
   {
      static void Main(string[] args)
      {
         Transaction t1 = new Transaction("001", "8/10/2012", 78900.00);
         Transaction t2 = new Transaction("002", "9/10/2012", 451900.00);
         t1.showTransaction();
         t2.showTransaction();
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Transaction: 001
Date: 8/10/2012
Amount: 78900
Transaction: 002
Date: 9/10/2012
Amount: 451900
</pre>
<h1>C# - Namespaces</h1>
<p>A <b>namespace</b> is designed for providing a way to keep one set of names separate from another. The class names declared in one namespace will not conflict with the same class names declared in another.</p>
<h2>Defining a Namespace</h2>
<p>A namespace definition begins with the keyword <b>namespace</b> followed by the namespace name as follows:</p>
<pre class="prettyprint">
namespace namespace_name
{
   // code declarations
}
</pre>
<p>To call the namespace-enabled version of either function or variable, prepend the namespace name as follows:</p>
<pre class="prettyprint">
namespace_name.item_name;
</pre>
<p>The following program demonstrates use of namespaces:</p>
<pre class="prettyprint">
using System;
namespace first_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}
namespace second_space
{
   class namespace_cl
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}   
class TestClass
{
   static void Main(string[] args)
   {
      first_space.namespace_cl fc = new first_space.namespace_cl();
      second_space.namespace_cl sc = new second_space.namespace_cl();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Inside first_space
Inside second_space
</pre>
<h2>The <i>using</i> Keyword</h2>
<p>The <b>using</b> keyword states that the program is using the names in the given namespace. For example, we are using the <b>System</b> namespace in our programs. The class Console is defined there. We just write:</p>
<pre class="prettyprint">
Console.WriteLine ("Hello there");
</pre>
<p>We could have written the fully qualified name as:</p>
<pre class="prettyprint">
System.Console.WriteLine("Hello there");
</pre>
<p>You can also avoid prepending of namespaces with the <b>using</b> namespace directive. This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the following code:</p>
<p>Let us rewrite our preceding example, with using directive:</p>
<pre class="prettyprint">
using System;
using first_space;
using second_space;

namespace first_space
{
   class abc
   {
      public void func()
      {
         Console.WriteLine("Inside first_space");
      }
   }
}
namespace second_space
{
   class efg
   {
      public void func()
      {
         Console.WriteLine("Inside second_space");
      }
   }
}   
class TestClass
{
   static void Main(string[] args)
   {
      abc fc = new abc();
      efg sc = new efg();
      fc.func();
      sc.func();
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Inside first_space
Inside second_space
</pre>
<h1>C# - Preprocessor Directives</h1>
<p>The preprocessors directives give instruction to the compiler to preprocess the information before actual compilation starts.</p>
<p>All preprocessor directives begin with #, and only white-space characters may appear before a preprocessor directive on a line. Preprocessor directives are not statements, so they do not end with a semicolon (;).</p>
<p>C# compiler does not have a separate preprocessor; however, the directives are processed as if there was one. In C# the preprocessor directives are used to help in conditional compilation. Unlike C and C++ directives, they are not used to create macros. A preprocessor directive must be the only instruction on a line.</p>
<h2>List of Preprocessor Directives in C#</h2>
<p>The following table lists the preprocessor directives available in C#:</p>
<table class="src">
<tr><th style="width:20%;">Preprocessor Directive</th><th>Description. </th></tr>
<tr><td>#define</td><td>It defines a sequence of characters, called symbol. </td></tr>
<tr><td>#undef</td><td>It allows you to undefine a symbol.</td></tr>
<tr><td>#if</td><td>It allows testing a symbol or symbols to see if they evaluate to true.</td></tr>
<tr><td>#else</td><td>It allows to create a compound conditional directive, along with #if.</td></tr>
<tr><td>#elif</td><td>It allows creating a compound conditional directive.</td></tr>
<tr><td>#endif</td><td>specifies the end of a conditional directive.</td></tr>
<tr><td>#line</td><td>It lets you modify the compiler's line number and (optionally) the file name output for errors and warnings.</td></tr>
<tr><td>#error</td><td>It allows generating an error from a specific location in your code.</td></tr>
<tr><td>#warning</td><td>It allows generating a level one warning from a specific location in your code.</td></tr>
<tr><td>#region</td><td>It lets you specify a block of code that you can expand or collapse when using the outlining feature of the Visual Studio Code Editor.</td></tr>
<tr><td>#endregion</td><td>It marks the end of a #region block.</td></tr>
</table>
<h2>The #define Preprocessor</h2>
<p>The #define preprocessor directive creates symbolic constants.</p>
<p>#define lets you define a symbol, such that, by using the symbol as the expression passed to the #if directive, the expression will evaluate to true. Its syntax is as follows:</p>
<pre class="prettyprint">
#define symbol
</pre>
<p>The following program illustrates this:</p>
<pre class="prettyprint">
#define PI 
using System;
namespace PreprocessorDAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         #if (PI)
            Console.WriteLine("PI is defined");
         #else
            Console.WriteLine("PI is not defined");
         #endif
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
PI is defined
</pre>
<h2>Conditional Directives</h2>
<p>You can use the #if directive to create a conditional directive. Conditional directives are useful for testing a symbol or symbols to see if they evaluate to true. If they do evaluate to true, the compiler evaluates all the code between the #if and the next directive.</p>
<p>Syntax for conditional directive is:</p>
<pre class="prettyprint">
#if symbol [operator symbol]...
</pre>
<p>Where, <i>symbol</i> is the name of the symbol you want to test. You can also use true and false or prepend the symbol with the negation operator.</p>
<p>The <i>operator symbol</i> is the operator used for evaluating the symbol. Operators could be either of the following:</p>
<ul class="list">
<li><p>== (equality)</p></li>
<li><p>!= (inequality)</p></li>
<li><p>&amp;&amp; (and)</p></li>
<li><p>|| (or)</p></li>
</ul>
<p>You can also group symbols and operators with parentheses. Conditional directives are used for compiling code for a debug build or when compiling for a specific configuration. A conditional directive beginning with a <b>#if</b> directive must explicitly be terminated with a <b>#endif</b> directive.</p>
<p>The following program demonstrates use of conditional directives:</p>
<pre class="prettyprint">
#define DEBUG
#define VC_V10
using System;
public class TestClass
{
   public static void Main()
   {

      #if (DEBUG && !VC_V10)
         Console.WriteLine("DEBUG is defined");
      #elif (!DEBUG && VC_V10)
         Console.WriteLine("VC_V10 is defined");
      #elif (DEBUG && VC_V10)
         Console.WriteLine("DEBUG and VC_V10 are defined");
      #else
         Console.WriteLine("DEBUG and VC_V10 are not defined");
      #endif
      Console.ReadKey();
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
DEBUG and VC_V10 are defined
</pre>
<h1>C# - Regular Expressions</h1>
<p>A <b>regular expression</b> is a pattern that could be matched against an input text. The .Net framework provides a regular expression engine that allows such matching. A pattern consists of one or more character literals, operators, or constructs.</p>
<h2>Constructs for Defining Regular Expressions</h2>
<p>There are various categories of characters, operators, and constructs that lets you to define regular expressions. Click the follwoing links to find these constructs.</p>
<ul class="list">
<li><p><a href="csharp_character_escapes.html" title="csharp character escapes regular expression">Character escapes</a></p></li>
<li><p><a href="csharp_character_classes.html" title="csharp character classes regular expression">Character classes</a></p></li>
<li><p><a href="csharp_anchors.html" title="csharp anchors regular expression">Anchors</p></li>
<li><p><a href="csharp_grouping_constructs.html" title="csharp grouping constructs regular expression">Grouping constructs</a></p></li>
<li><p><a href="csharp_quantifiers.html" title="csharp quantifiers regular expression">Quantifiers</a></p></li>
<li><p><a href="csharp_backreference_constructs.html" title="csharp backreference constructs regular expression">Backreference constructs</a></p></li>
<li><p><a href="csharp_alternation_constructs.html" title="csharp alternation constructs regular expression">Alternation constructs</a></p></li>
<li><p><a href="csharp_substitutions.html" title="csharp substitutions regular expression">Substitutions</a></p></li>
<li><p><a href="csharp_miscellaneous_constructs.html" title="csharp miscellaneous constructs regular expression">Miscellaneous constructs</a></p></li>
</ul>
<h2>The Regex Class</h2>
<p>The Regex class is used for representing a regular expression.</p>
<p>The Regex class has the following commonly used methods:</p>
<table class="src">
<tr><th style="width:5%;">S.N</th><th>Methods &amp; Description</th></tr>
<tr><td>1</td><td><b>public bool IsMatch(
	string input
)
</b><br/>Indicates whether the regular expression specified in the Regex constructor finds a match in a specified input string.</td></tr>
<tr><td>2</td><td><b>public bool IsMatch(
	string input,
	int startat
)
</b><br/>Indicates whether the regular expression specified in the Regex constructor finds a match in the specified input string, beginning at the specified starting position in the string.</td></tr>
<tr><td>3</td><td><b>public static bool IsMatch(
	string input,
	string pattern
)
</b><br/>Indicates whether the specified regular expression finds a match in the specified input string.</td></tr>
<tr><td>4</td><td><b>public MatchCollection Matches(
	string input
)
</b><br/>Searches the specified input string for all occurrences of a regular expression.</td></tr>
<tr><td>5</td><td><b>public string Replace(
	string input,
	string replacement
)
</b><br/>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</td></tr>
<tr><td>6</td><td><b>public string[] Split(
	string input
)
</b><br/>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the Regex constructor.</td></tr>
</table>
<p>For the complete list of methods and properties, please read the Microsoft documentation on C#.</p>
<h2>Example 1</h2>
<p>The following example matches words that start with 'S':</p>
<pre class="prettyprint">
using System;
using System.Text.RegularExpressions;

namespace RegExApplication
{
   class Program
   {
      private static void showMatch(string text, string expr)
      {
         Console.WriteLine("The Expression: " + expr);
         MatchCollection mc = Regex.Matches(text, expr);
         foreach (Match m in mc)
         {
            Console.WriteLine(m);
         }
      }
      static void Main(string[] args)
      {
         string str = "A Thousand Splendid Suns";

         Console.WriteLine("Matching words that start with 'S': ");
         showMatch(str, @"\bS\S*");
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Matching words that start with 'S':
The Expression: \bS\S*
Splendid
Suns
</pre>
<h1>C# - Exception Handling</h1>
<p>An exception is a problem that arises during the execution of a program. A C# exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.</p>
<p>Exceptions provide a way to transfer control from one part of a program to another. C# exception handling is built upon four keywords: <b>try</b>, <b>catch</b>, <b>finally</b> and <b>throw</b>.</p>
<ul class="list">
<li><p><b>try</b>: A try block identifies a block of code for which particular exceptions will be activated. It's followed by one or more catch blocks.</p></li>
<li><p><b>catch</b>: A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.</p></li>
<li><p><b>finally</b>: The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. For example, if you open a file, it must be closed whether an exception is raised or not. </p></li>
<li><p><b>throw</b>: A program throws an exception when a problem shows up. This is done using a throw keyword.</p></li>
</ul>
<h2>Syntax</h2>
<p>Assuming a block will raise and exception, a method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:</p>
<pre class="prettyprint">
try
{
   // statements causing exception
}
catch( ExceptionName e1 )
{
   // error handling code
}
catch( ExceptionName e2 )
{
   // error handling code
}
catch( ExceptionName eN )
{
   // error handling code
}
finally
{
   // statements to be executed
}
</pre>
<p>You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.</p>
<h2>Exception Classes in C#</h2>
<p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <b>System.Exception</b> class. Some of the exception classes derived from the System.Exception class are the <b>System.ApplicationException</b> and <b>System.SystemException</b> classes. </p>
<p>The <b>System.ApplicationException</b> class supports exceptions generated by application programs. So the exceptions defined by the programmers should derive from this class.</p>
<p>The <b>System.SystemException</b> class is the base class for all predefined system exception. </p>
<p>The following table provides some of the predefined exception classes derived from the Sytem.SystemException class:</p>
<table class="src">
<tr><th style="width:40%;">Exception Class</th><th>Description</th></tr>
<tr><td>System.IO.IOException</td><td>Handles I/O errors.</td></tr>
<tr><td>System.IndexOutOfRangeException</td><td>Handles errors generated when a method refers to an array index out of range.</td></tr>
<tr><td>System.ArrayTypeMismatchException</td><td>Handles errors generated when type is mismatched with the array type.</td></tr>
<tr><td>System.NullReferenceException</td><td>Handles errors generated from deferencing a null object. </td></tr>
<tr><td>System.DivideByZeroException</td><td>Handles errors generated from dividing a dividend with zero.</td></tr>
<tr><td>System.InvalidCastException</td><td>Handles errors generated during typecasting.</td></tr>
<tr><td>System.OutOfMemoryException</td><td>Handles errors generated from insufficient free memory. </td></tr>
<tr><td>System.StackOverflowException</td><td>Handles errors generated from stack overflow.</td></tr>
</table>
<h2>Handling Exceptions</h2>
<p>C# provides a structured solution to the exception handling problems in the form of try and catch blocks. Using these blocks the core program statements are separated from the error-handling statements. </p>
<p>These error handling blocks are implemented using the <b>try</b>, <b>catch</b> and <b>finally</b> keywords. Following is an example of throwing an exception when dividing by zero condition occurs:</p>
<pre class="prettyprint">
using System;
namespace ErrorHandlingApplication
{
    class DivNumbers
    {
        int result;
        DivNumbers()
        {
            result = 0;
        }
        public void division(int num1, int num2)
        {
            try
            {
                result = num1 / num2;
            }
            catch (DivideByZeroException e)
            {
                Console.WriteLine("Exception caught: {0}", e);
            }
            finally
            {
                Console.WriteLine("Result: {0}", result);
            }

        }
        static void Main(string[] args)
        {
            DivNumbers d = new DivNumbers();
            d.division(25, 0);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Exception caught: System.DivideByZeroException: Attempted to divide by zero. 
at ...
Result: 0
</pre>
<h1>C# - File I/O</h1>
<p>A <b>file</b> is a collection of data stored in a disk with a specific name and a directory path. When a file is opened for reading or writing, it becomes a <b>stream</b>. </p>
<p>The stream is basically the sequence of bytes passing through the communication path. There are two main streams: the <b>input stream</b> and the <b>output stream</b>. The <b>input stream</b> is used for reading data from file (read operation) and the <b>output stream</b> is used for writing into the file (write operation). </p>
<h2>C# I/O Classes</h2>
<p>The System.IO namespace has various class that are used for performing various operation with files, like creating and deleting files, reading from or writing to a file, closing a file etc. </p>
<p>The following table shows some commonly used non-abstract classes in the System.IO namespace:</p>
<table class="src">
<tr><th style="width:25%;">I/O Class</th><th>Description</th></tr>
<tr><td>BinaryReader</td><td>Reads primitive data from a binary stream.</td></tr>
<tr><td>BinaryWriter</td><td>Writes primitive data in binary format.</td></tr>
<tr><td>BufferedStream</td><td>A temporary storage for a stream of bytes.</td></tr>
<tr><td>Directory</td><td>Helps in manipulating a directory structure.</td></tr>
<tr><td>DirectoryInfo</td><td>Used for performing operations on directories.</td></tr>
<tr><td>DriveInfo</td><td>Provides information for the drives.</td></tr>
<tr><td>File</td><td>Helps in manipulating files. </td></tr>
<tr><td>FileInfo</td><td>Used for performing operations on files. </td></tr>
<tr><td>FileStream</td><td>Used to read from and write to any location in a file. </td></tr>
<tr><td>MemoryStream</td><td>Used for random access to streamed data stored in memory.</td></tr>
<tr><td>Path</td><td>Performs operations on path information.</td></tr>
<tr><td>StreamReader</td><td>Used for reading characters from a byte stream.</td></tr>
<tr><td>StreamWriter</td><td>Is used for writing characters to a stream.</td></tr>
<tr><td>StringReader</td><td>Is used for reading from a string buffer.</td></tr>
<tr><td>StringWriter</td><td>Is used for writing into a string buffer.</td></tr>
</table>
<h2>The FileStream Class</h2>
<p>The <b>FileStream</b> class in the System.IO namespace helps in reading from, writing to and closing files. This class derives from the abstract class Stream. </p>
<p>You need to create a <b>FileStream</b> object to create a new file or open an existing file. The syntax for creating a <b>FileStream</b> object is as follows:</p>
<pre class="prettyprint">
FileStream &lt;object_name&gt; = new FileStream( &lt;file_name&gt;,
&lt;FileMode Enumerator&gt;, &lt;FileAccess Enumerator&gt;, &lt;FileShare Enumerator&gt;);
</pre>
<p>For example, for creating a FileStream object <b>F</b> for reading a file named <b>sample.txt</b>:</p>
<pre class="prettyprint">
FileStream F = new FileStream("sample.txt", FileMode.Open, FileAccess.Read, FileShare.Read);
</pre>
<table class="src">
<tr><th style="width:20%;">Parameter</th><th>Description</th></tr>
<tr><td>FileMode</td><td><p>The <b>FileMode</b> enumerator defines various methods for opening files. The members of the FileMode enumerator are:</p>
<ul class="list">
<li><p><b>Append</b>: It opens an existing file and puts cursor at the end of file, or creates the file, if the file does not exist. </p></li>
<li><p><b>Create</b>: It creates a new file.</p></li>
<li><p><b>CreateNew</b>: It specifies to the operating system, that it should create a new file. </p></li>
<li><p><b>Open</b>: It opens an existing file.</p></li>
<li><p><b>OpenOrCreate</b>: It specifies to the operating system that it should open a file if it exists, otherwise it should create a new file.</p></li>
<li><p><b>Truncate</b>: It opens an existing file and truncates its size to zero bytes.</p></li>
</ul>
</td></tr>
<tr><td>FileAccess</td><td><p><b>FileAccess</b> enumerators have members: <b>Read</b>, <b>ReadWrite</b> and <b>Write</b>.</p>
</td></tr>
<tr><td>FileShare</td><td><p><b>FileShare</b> enumerators have the following members:</p>
<ul class="list">
<li><p><b>Inheritable</b>: It allows a file handle to pass inheritance to the child processes</p></li>
<li><p><b>None</b>: It declines sharing of the current file</p></li>
<li><p><b>Read</b>: It allows opening the file for reading </p></li>
<li><p><b>ReadWrite</b>: It allows opening the file for reading and writing</p></li>
<li><p><b>Write</b>: It allows opening the file for writing</p></li>
</ul>
</td></tr>
</table>
<h2>Example:</h2>
<p>The following program demonstrates use of the <b>FileStream </b>class:</p>
<pre class="prettyprint">
using System;
using System.IO;

namespace FileIOApplication
{
    class Program
    {
        static void Main(string[] args)
        {
            FileStream F = new FileStream("test.dat", 
            FileMode.OpenOrCreate, FileAccess.ReadWrite);

            for (int i = 1; i &lt;= 20; i++)
            {
                F.WriteByte((byte)i);
            }

            F.Position = 0;

            for (int i = 0; i &lt;= 20; i++)
            {
                Console.Write(F.ReadByte() + " ");
            }
            F.Close();
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -1
</pre>
<h1>C# - Attributes</h1>
<p>An <b>attribute</b> is a declarative tag that is used to convey information to runtime about the behaviors of various elements like classes, methods, structures, enumerators, assemblies etc., in your program. You can add declarative information to a program by using an attribute. A declarative tag is depicted by square ([ ]) brackets placed above the element it is used for.</p>
<p>Attributes are used for adding metadata, such as compiler instruction and other information such as comments, description, methods and classes to a program. The .Net Framework provides two types of attributes: <i>the pre-defined</i> attributes and <i>custom built</i> attributes.</p>
<h2>Specifying an Attribute</h2>
<p>Syntax for specifying an attribute is as follows:</p>
<pre class="prettyprint">
[attribute(positional_parameters, name_parameter = value, ...)]
element
</pre>
<p>Name of the attribute and its values are specified within the square brackets, before the element to which the attribute is applied. Positional parameters specify the essential information and the name parameters specify the optional information.</p>
<h2>Predefined Attributes</h2>
<p>The .Net Framework provides three pre-defined attributes:</p>
<ul class="list">
<li><p>AttributeUsage</p></li>
<li><p>Conditional</p></li>
<li><p>Obsolete</p></li>
</ul>
<h2>AttributeUsage:</h2> 
<p>The pre-defined attribute <b>AttributeUsage</b> describes how a custom attribute class can be used. It specifies the types of items to which the attribute can be applied. </p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint">
[AttributeUsage(
   validon,
   AllowMultiple=allowmultiple,
   Inherited=inherited
)]
</pre>
<p>Where, </p>
<ul class="list">
<li><p>The parameter validon specifies the language elements on which the attribute can be placed. It is a combination of the value of an enumerator <i>AttributeTargets</i>. The default value is <i>AttributeTargets.All</i>.</p></li>
<li><p>The parameter <i>allowmultiple</i> (optional) provides value for the <i>AllowMultiple</i> property of this attribute, a Boolean value. If this is true, the attribute is multiuse. The default is false (single-use).</p></li>
<li><p>The parameter inherited (optional) provides value for the <i>Inherited</i> property of this attribute, a Boolean value. If it is true, the attribute is inherited by derived classes. The default value is false (not inherited).</p></li>
</ul>
<p>For example,</p>
<pre class="prettyprint">
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Feild |
AttributeTargets.Method |
AttributeTargets.Property, 
AllowMultiple = true)]
</pre>
<h2>Conditional</h2>
<p>This predefined attribute marks a conditional method whose execution depends on a specified preprocessing identifier.</p>
<p>It causes conditional compilation of method calls, depending on the specified value such as <b>Debug</b> or <b>Trace</b>. For example, it displays the values of the variables while debugging a code. </p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint">
[Conditional(
   conditionalSymbol
)]
</pre>
<p>For example,</p>
<pre class="prettyprint">
[Conditional("DEBUG")]
</pre>
<p>The following example demonstrates the attribute:</p>
<pre class="prettyprint">
#define DEBUG
using System;
using System.Diagnostics;
public class Myclass
{
    [Conditional("DEBUG")]
    public static void Message(string msg)
    {
        Console.WriteLine(msg);
    }
}
class Test
{
    static void function1()
    {
        Myclass.Message("In Function 1.");
        function2();
    }
    static void function2()
    {
        Myclass.Message("In Function 2.");
    }
    public static void Main()
    {
        Myclass.Message("In Main function.");
        function1();
        Console.ReadKey();
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
In Main function
In Function 1
In Function 2
</pre>
<h2>Obsolete</h2>
<p>This predefined attribute marks a program entity that should not be used. It enables you to inform the compiler to discard a particular target element. For example, when a new method is being used in a class, but you still want to retain the old method in the class, you may mark it as obsolete by displaying a message the new method should be used, instead of the old method.</p>
<p>Syntax for specifying this attribute is as follows:</p>
<pre class="prettyprint">
[Obsolete(
   message
)]
[Obsolete(
   message,
   iserror
)]
</pre>
<p>Where, </p>
<ul class="list">
<li><p>The parameter <i>message</i>, is a string describing the reason why the item is obsolete and what to use instead.</p></li>
<li><p>The parameter <i>iserror</i>, is a Boolean value. If its value is true, the compiler should treat the use of the item as an error. Default value is false (compiler generates a warning).</p></li>
</ul>
<p>The following program demonstrates this:</p>
<pre class="prettyprint">
using System;
public class MyClass
{
   [Obsolete("Don't use OldMethod, use NewMethod instead", true)]
   static void OldMethod()
   { 
      Console.WriteLine("It is the old method");
   }
   static void NewMethod()
   { 
      Console.WriteLine("It is the new method"); 
   }
   public static void Main()
   {
      OldMethod();
   }
}
</pre>
<p>When you try to compile the program, the compiler gives an error message stating:</p>
<pre class="result">
 Don't use OldMethod, use NewMethod instead
</pre>
<h2>Creating Custom Attributes</h2>
<p>The .Net Framework allows creation of custom attributes that can be used to store declarative information and can be retrieved at run time. This information can be related to any target element depending upon the design criteria and application need.</p>
<p>Creating and using custom attributes involve four steps:</p>
<ul class="list">
<li><p>Declaring a custom attribute</p></li>
<li><p>Constructing the custom attribute</p></li>
<li><p>Apply the custom attribute on a target program element</p></li>
<li><p>Accessing Attributes Through Reflection</p></li>
</ul>
<p>The Last step involves writing a simple program to read through the metadata to find various notations. Metadata is data about data or information used for describing other data. This program should use reflections for accessing attributes at runtime. This we will discuss in the next chapter. </p>
<h2>Declaring a Custom Attribute</h2>
<p>A new custom attribute should is derived from the <b>System.Attribute</b> class. For example,</p>
<pre class="prettyprint">
//a custom attribute BugFix to be assigned to a class and its members
[AttributeUsage(AttributeTargets.Class |
AttributeTargets.Constructor |
AttributeTargets.Field |
AttributeTargets.Method |
AttributeTargets.Property,
AllowMultiple = true)]

public class DeBugInfo : System.Attribute
</pre>
<p>In the preceding code, we have declared a custom attribute named <i>DeBugInfo</i>. </p>
<h1>C# - Reflection</h1>
<p><b>Reflection</b> objects are used for obtaining type information at runtime. The classes that give access to the metadata of a running program are in the <b>System.Reflection</b> namespace. </p>
<p>The <b>System.Reflection</b> namespace contains classes that allow you to obtain information about the application and to dynamically add types, values and objects to the application. </p>
<h2>Uses of Reflection</h2>
<p>Reflection has the following uses:</p>
<ul class="list">
<li><p>It allows view attribute information at runtime.</p></li>
<li><p>It allows examining various types in an assembly and instantiate these types.</p></li>
<li><p>It allows late binding to methods and properties</p></li>
<li><p>It allows creating new types at runtime and then performs some tasks using those types. </p></li>
</ul>
<h2>Viewing Metadata</h2>
<p>We have mentioned in the preceding chapter that using reflection you can view the attribute information. </p>
<p>The <b>MemberInfo</b> object of the <b>System.Reflection</b> class need to be initialized for discovering the attributes asscociated with a class. To do this, you define an object of the target class, as:</p>
<pre class="prettyprint">
System.Reflection.MemberInfo info = typeof(MyClass);
</pre>
<p>The following program demonstrates this:</p>
<pre class="prettyprint">
using System;

[AttributeUsage(AttributeTargets.All)]
public class HelpAttribute : System.Attribute
{
   public readonly string Url;

   public string Topic  // Topic is a named parameter
   {
      get
      {
         return topic;
      }
      set
      {

         topic = value;
      }
   }

   public HelpAttribute(string url)  // url is a positional parameter
   {
      this.Url = url;
   }

   private string topic;
}
[HelpAttribute("Information on the class MyClass")]
class MyClass
{
}

namespace AttributeAppl
{
   class Program
   {
      static void Main(string[] args)
      {
         System.Reflection.MemberInfo info = typeof(MyClass);
         object[] attributes = info.GetCustomAttributes(true);
         for (int i = 0; i &lt; attributes.Length; i++)
         {
            System.Console.WriteLine(attributes[i]);
         }
         Console.ReadKey();

      }
   }
}
</pre>
<p>When it is compiled and run, it displays the name of the custom attributes attached to the class <i>MyClass</i>: </p>
<pre class="result">
HelpAttribute
</pre>
<h1>C# - Properties</h1>
<p><b>Properties</b> are named members of classes, structures, and interfaces. Member variables or methods in a class or structures are called <b>Fields</b>. Properties are an extension of fields and are accessed using the same syntax. They use <b>accessors</b> through which the values of the private fields can be read, written or manipulated.  </p>
<p>Properties do not name the storage locations. Instead, they have <b>accessors</b> that read, write, or compute their values.</p>
<p>For example, let us have a class named Student, with private fields for age, name and code. We cannot directly access these fields from outside the class scope, but we can have properties for accessing these private fields.</p>
<h2>Accessors</h2>
<p>The <b>accessor</b> of a property contains the executable statements that helps in getting (reading or computing) or setting (writing) the property. The accessor declarations can contain a get accessor, a set accessor, or both.  For example:</p>
<pre class="prettyprint">
// Declare a Code property of type string:
public string Code
{
   get
   {
      return code;
   }
   set
   {
      code = value;
   }
}

// Declare a Name property of type string:
public string Name
{
   get
   {
     return name;
   }
   set
   {
     name = value;
   }
}

// Declare a Age property of type int:
public int Age
{ 
   get
   {
      return age;
   }
   set
   {
      age = value;
   }
}
</pre>
<h2>Example:</h2>
<p>The following example demonstrates use of properties:</p>
<pre class="prettyprint">
using System;
class Student
{

   private string code = "N.A";
   private string name = "not known";
   private int age = 0;

   // Declare a Code property of type string:
   public string Code
   {
      get
      {
         return code;
      }
      set
      {
         code = value;
      }
   }
   
   // Declare a Name property of type string:
   public string Name
   {
      get
      {
         return name;
      }
      set
      {
         name = value;
      }
   }

   // Declare a Age property of type int:
   public int Age
   {
      get
      {
         return age;
      }
      set
      {
         age = value;
      }
   }
   public override string ToString()
   {
      return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
   }

   public static void Main()
   {
      // Create a new Student object:
      Student s = new Student();
            
      // Setting code, name and the age of the student
      s.Code = "001";
      s.Name = "Zara";
      s.Age = 9;
      Console.WriteLine("Student Info: {0}", s);
      //let us increase age
      s.Age += 1;
      Console.WriteLine("Student Info: {0}", s);
      Console.ReadKey();
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>
<h2>Abstract Properties</h2>
<p>An abstract class may have an abstract property, which should be implemented in the derived class. The following program illustrates this:</p>
<pre class="prettyprint">
using System;
public abstract class Person
{
   public abstract string Name
   {
      get;
      set;
   }
   public abstract int Age
   {
      get;
      set;
   }
}
class Student : Person
{

   private string code = "N.A";
   private string name = "N.A";
   private int age = 0;

   // Declare a Code property of type string:
   public string Code
   {
      get
      {
         return code;
      }
      set
      {
         code = value;
      }
   }
   
   // Declare a Name property of type string:
   public override string Name
   {
      get
      {
         return name;
      }
      set
      {
         name = value;
      }
   }

   // Declare a Age property of type int:
   public override int Age
   {
      get
      {
         return age;
      }
      set
      {
         age = value;
      }
   }
   public override string ToString()
   {
      return "Code = " + Code +", Name = " + Name + ", Age = " + Age;
   }

   public static void Main()
   {
      // Create a new Student object:
      Student s = new Student();
            
      // Setting code, name and the age of the student
      s.Code = "001";
      s.Name = "Zara";
      s.Age = 9;
      Console.WriteLine("Student Info:- {0}", s);
      //let us increase age
      s.Age += 1;
      Console.WriteLine("Student Info:- {0}", s);
      Console.ReadKey();
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Student Info: Code = 001, Name = Zara, Age = 9
Student Info: Code = 001, Name = Zara, Age = 10
</pre>
<h1>C# - Indexers</h1>
<p>An <b>indexer</b> allows an object to be indexed like an array.  When you define an indexer for a class, this class behaves like a <b>virtual array</b>. You can then access the instance of this class using the array access operator ([ ]). </p>
<h2>Syntax</h2>
<p>A one dimensional indexer has the following syntax:</p>
<pre class="prettyprint">
element-type this[int index] 
{
   // The get accessor.
   get 
   {
      // return the value specified by index 
   }

   // The set accessor.
   set 
   {
      // set the value specified by index 
   }
}
</pre>
<h2>Use of Indexers</h2>
<p>Declaration of behavior of an indexer is to some extent similar to a property. Like properties, you use <b>get</b> and <b>set</b> accessors for defining an indexer. However, properties return or set a specific data member, whereas indexers returns or sets a particular value from the object instance. In other words, it breaks the instance data into smaller parts and indexes each part, gets or sets each part. </p>
<p>Defining a property involves providing a property name. Indexers are not defined with names, but with the <b>this</b> keyword, which refers to the object instance. The following example demonstrates the concept:</p>
<pre class="prettyprint">
using System;
namespace IndexerApplication
{
   class IndexedNames
   {
      private string[] namelist = new string[size];
      static public int size = 10;
      public IndexedNames()
      {
         for (int i = 0; i &lt; size; i++)
         namelist[i] = "N. A.";
      }
      public string this[int index]
      {
         get
         {
            string tmp;

            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               tmp = namelist[index];
            }
            else
            {
               tmp = "";
            }

            return ( tmp );
         }
         set
         {
            if( index &gt;= 0 &amp;&amp; index &lt;= size-1 )
            {
               namelist[index] = value;
            }
         }
      }

      static void Main(string[] args)
      {
         IndexedNames names = new IndexedNames();
         names[0] = "Zara";
         names[1] = "Riz";
         names[2] = "Nuha";
         names[3] = "Asif";
         names[4] = "Davinder";
         names[5] = "Sunil";
         names[6] = "Rubic";
         for ( int i = 0; i &lt; IndexedNames.size; i++ )
         {
            Console.WriteLine(names[i]);
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Zara
Riz
Nuha
Asif
Davinder
Sunil
Rubic
N. A.
N. A.
N. A.
</pre>
<h1>C# - Delegates</h1>
<p>C# delegates are similar to pointers to functions, in C or C++. A <b>delegate</b> is a reference type variable that holds the reference to a method. The reference can be changed at runtime.</p>
<p>Delegates are especially used for implementing events and the call-back methods. All delegates are implicitly derived from the <b>System.Delegate</b> class.</p>
<h2>Declaring Delegates</h2>
<p>Delegate declaration determines the methods that can be referenced by the delegate. A delegate can refer to a method, which have the same signature as that of the delegate. </p>
<p>For example, consider a delegate:</p>
<pre class="prettyprint">
public delegate int MyDelegate (string s);
</pre>
<p>The preceding delegate can be used to reference any method that has a single <i>string</i> parameter and returns an <i>int</i> type variable.  </p>
<p>Syntax for delegate declaration is:</p>
<pre class="prettyprint">
delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt;
</pre>
<h2>Instantiating Delegates</h2>
<p>Once a delegate type has been declared, a delegate object must be created with the <b>new</b> keyword and be associated with a particular method. When creating a delegate, the argument passed to the <b>new</b> expression is written like a method call, but without the arguments to the method. For example:</p>
<pre class="prettyprint">
public delegate void printString(string s);
...
printString ps1 = new printString(WriteToScreen);
printString ps2 = new printString(WriteToFile);
</pre>
<p>Following example demonstrates declaration, instantiation and use of a delegate that can be used to reference methods that take an integer parameter and returns an integer value. </p>
<pre class="prettyprint">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         //calling the methods using the delegate objects
         nc1(25);
         Console.WriteLine("Value of Num: {0}", getNum());
         nc2(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Value of Num: 35
Value of Num: 175
</pre>
<h2>Multicasting of a Delegate</h2>
<p>Delegate objects can be composed using the "+" operator. A composed delegate calls the two delegates it was composed from. Only delegates of the same type can be composed. The "-" operator can be used to remove a component delegate from a composed delegate.</p>
<p>Using this useful property of delegates you can create an invocation list of methods that will be called when a delegate is invoked. This is called <b>multicasting</b> of a delegate. The following program demonstrates multicasting of a delegate:</p>
<pre class="prettyprint">
using System;

delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         //create delegate instances
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         //calling multicast
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Value of Num: 75
</pre>
<h2>Use of Delegate</h2>
<p>The following example demonstrates the use of delegate. The delegate <i>printString</i> can be used to reference methods that take a string as input and return nothing.</p>
<p>We use this delegate to call two methods, the first prints the string to the console, and the second one prints it to a file:</p>
<pre class="prettyprint">
using System;
using System.IO;

namespace DelegateAppl
{
   class PrintString
   {
      static FileStream fs;
      static StreamWriter sw;
      // delegate declaration
      public delegate void printString(string s);

      // this method prints to the console
      public static void WriteToScreen(string str)
      {
         Console.WriteLine("The String is: {0}", str);
      }
      //this method prints to a file
      public static void WriteToFile(string s)
      {
         fs = new FileStream("c:\\message.txt",
         FileMode.Append, FileAccess.Write);
         sw = new StreamWriter(fs);
         sw.WriteLine(s);
         sw.Flush();
         sw.Close();
         fs.Close();
      }
      // this method takes the delegate as parameter and uses it to
      // call the methods as required
      public static void sendString(printString ps)
      {
         ps("Hello World");
      }
      static void Main(string[] args)
      {
         printString ps1 = new printString(WriteToScreen);
         printString ps2 = new printString(WriteToFile);
         sendString(ps1);
         sendString(ps2);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
The String is: Hello World
</pre>
<h1>C# - Events</h1>
<p><b>Events</b> are basically a user action like key press, clicks, mouse movements etc., or some occurrence like system generated notifications. Applications need to respond to events when they occur. For example, interrupts. Events are used for inter-process communication. </p>
<h2>Using Delegates with Events</h2>
<p>The events are declared and raised in a class and associated with the event handlers using delegates within the same class or some other class. The class containing the event is used to publish the event. This is called the <b>publisher</b> class. Some other class that accepts this event is called the <b>subscriber</b> class. Events use the <b>publisher-subscriber</b> model.</p>
<p>A <b>publisher</b> is an object that contains the definition of the event and the delegate. The event-delegate association is also defined in this object. A publisher class object invokes the event and it is notified to other objects. </p>
<p>A <b>subscriber</b> is an object that accepts the event and provides an event handler. The delegate in the publisher class invokes the method (event handler) of the subscriber class. </p>
<h2>Declaring Events</h2>
<p>To declare an event inside a class, first a delegate type for the event must be declared. For example,</p>
<pre class="prettyprint">
public delegate void BoilerLogHandler(string status);
</pre>
<p>Next, the event itself is declared, using the <b>event</b> keyword:</p>
<pre class="prettyprint">
//Defining event based on the above delegate
public event BoilerLogHandler BoilerEventLog;
</pre>
<p>The preceding code defines a delegate named <i>BoilerLogHandler</i> and an event named <i>BoilerEventLog</i>, which invokes the delegate when it is raised.</p>
<h2>Example:</h2>
<pre class="prettyprint">
using System;
namespace SimpleEvent
{
   using System;

   public class EventTest
   {
      private int value;

      public delegate void NumManipulationHandler();

      public event NumManipulationHandler ChangeNum;

      protected virtual void OnNumChanged()
      {
         if (ChangeNum != null)
         {
            ChangeNum();
         }
         else
         {
            Console.WriteLine("Event fired!");
         }

      }
      public EventTest(int n )
      {
         SetValue(n);
      }
      public void SetValue(int n)
      {
         if (value != n)
         {
            value = n;
            OnNumChanged();
         }
      }
   }
   public class MainClass
   {
      public static void Main()
      {
         EventTest e = new EventTest(5);
         e.SetValue(7);
         e.SetValue(11);
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Event Fired!
Event Fired!
Event Fired!
</pre>
<h1>C# - Collections</h1>
<p>Collection classes are specialized classes for data storage and retrieval. These classes provide support for stacks, queues, lists, and hash tables. Most collection classes implement the same interfaces. </p>
<p>Collection classes serve various purposes, such as allocating memory dynamically to elements and accessing a list of items on the basis of an index etc. These classes create collections of objects of the Object class, which is the base class for all data types in C#. </p>
<h2>Various Collection Classes and Their Usage</h2>
<p>The following are the various commonly used classes of the <b>System.Collection</b> namespace. Click the following links to check their detail.</p>
<table class="src">
<tr><th style="width:20%;">Class</th><th>Description and Useage</th></tr>
<tr><td><a href="csharp_arraylist.html" title="C# ArrayList">ArrayList</a></td><td><p>It represents ordered collection of an object that can be <b>indexed</b> individually.</p><p>It is basically an alternative to an array. However unlike array you can add and remove items from a list at a specified position using an <b>index</b> and the array resizes itself automatically. It also allows dynamic memory allocation, add, search and sort items in the list.</p> </td></tr>
<tr><td><a href="csharp_hashtable.html" title="C# Hashtable">Hashtable</a></td><td><p>It uses a <b>key</b> to access the elements in the collection.</p><p>A hash table is used when you need to access elements by using key, and you can identify a useful key value. Each item in the hash table has a <b>key/value</b> pair. The key is used to access the items in the collection.</p></td></tr>
<tr><td><a href="csharp_sortedlist.html" title="C# SortedList">SortedList</a></td><td><p>It uses a <b>key</b> as well as an <b>index</b> to access the items in a list.</p><p>A sorted list is a combination of an array and a hash table. It contains a list of items that can be accessed using a key or an index. If you access items using an index, it is an ArrayList, and if you access items using a key, it is a Hashtable. The collection of items is always sorted by the key value.</p> </td></tr>
<tr><td><a href="csharp_stack.html" title="C# Stack">Stack</a></td><td><p>It represents a <b>last-in, first out</b> collection of object.</p></p>It is used when you need a last-in, first-out access of items. When you add an item in the list, it is called <b>pushing</b> the item and when you remove it, it is called <b>popping</b> the item.</p></td></tr>
<tr><td><a href="csharp_queue.html" title="C# Queue">Queue</a></td><td>It represents a <b>first-in, first out</b> collection of object.</p><p>It is used when you need a first-in, first-out access of items. When you add an item in the list, it is called <b>enqueue</b> and when you remove an item, it is called <b>deque</b>.</p></td></tr>
<tr><td><a href="csharp_bitarray.html" title="C# BitArray">BitArray</a></td><td><p>It represents an array of the <b>binary representation</b> using the values 1 and 0. </p></p>It is used when you need to store the bits but do not know the number of bits in advance. You can access items from the BitArray collection by using an <b>integer index</b>, which starts from zero.</p></td></tr>
</table>

<h1>C# - Generics</h1>
<p><b>Generics</b> allow you to delay the specification of the data type of programming elements in a class or a method, until it is actually used in the program. In other words, generics allow you to write a class or method that can work with any data type.</p>
<p>You write the specifications for the class or the method, with substitute parameters for data types. When the compiler encounters a constructor for the class or a function call for the method, it generates code to handle the specific data type. A simple example would help understanding the concept:</p>
<pre class="prettyprint">
using System;
using System.Collections.Generic;

namespace GenericApplication
{
    public class MyGenericArray&lt;T&gt;
    {
        private T[] array;
        public MyGenericArray(int size)
        {
            array = new T[size + 1];
        }
        public T getItem(int index)
        {
            return array[index];
        }
        public void setItem(int index, T value)
        {
            array[index] = value;
        }
    }
           
    class Tester
    {
        static void Main(string[] args)
        {
            //declaring an int array
            MyGenericArray&lt;int&gt; intArray = new MyGenericArray&lt;int&gt;(5);
            //setting values
            for (int c = 0; c &lt; 5; c++)
            {
                intArray.setItem(c, c*5);
            }
            //retrieving the values
            for (int c = 0; c < 5; c++)
            {
                Console.Write(intArray.getItem(c) + " ");
            }
            Console.WriteLine();
            //declaring a character array
            MyGenericArray&lt;char&gt; charArray = new MyGenericArray&lt;char&gt;(5);
            //setting values
            for (int c = 0; c &lt; 5; c++)
            {
                charArray.setItem(c, (char)(c+97));
            }
            //retrieving the values
            for (int c = 0; c&lt; 5; c++)
            {
                Console.Write(charArray.getItem(c) + " ");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
0 5 10 15 20
a b c d e
</pre>
<h2>Features of Generics</h2> 
<p>Using generics is a technique that enriches your programs in the following ways:</p>
<ul class="list">
<li><p>It helps you to maximize code reuse, type safety, and performance.</p></li>
<li><p>You can create generic collection classes. The .NET Framework class library contains several new generic collection classes in the <i>System.Collections.Generic</i> namespace. You may use these generic collection classes instead of the collection classes in the <i>System.Collections</i> namespace.</p></li>
<li><p>You can create your own generic interfaces, classes, methods, events and delegates.</p></li>
<li><p>You may create generic classes constrained to enable access to methods on particular data types.</p></li>
<li><p>You may get information on the types used in a generic data type at run-time by means of reflection.</p></li>
</ul>
<h2>Generic Methods</h2>
<p>In the previous example, we have used a generic class; we can declare a generic method with a type parameter. The following program illustrates the concept:</p>
<pre class="prettyprint">
using System;
using System.Collections.Generic;

namespace GenericMethodAppl
{
    class Program
    {
        static void Swap&lt;T&gt;(ref T lhs, ref T rhs)
        {
            T temp;
            temp = lhs;
            lhs = rhs;
            rhs = temp;
        }
        static void Main(string[] args)
        {
            int a, b;
            char c, d;
            a = 10;
            b = 20;
            c = 'I';
            d = 'V';

            //display values before swap:
            Console.WriteLine("Int values before calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values before calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);

            //call swap
            Swap&lt;int&gt;(ref a, ref b);
            Swap&lt;char&gt;(ref c, ref d);

            //display values after swap:
            Console.WriteLine("Int values after calling swap:");
            Console.WriteLine("a = {0}, b = {1}", a, b);
            Console.WriteLine("Char values after calling swap:");
            Console.WriteLine("c = {0}, d = {1}", c, d);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Int values before calling swap:
a = 10, b = 20
Char values before calling swap:
c = I, d = V
Int values after calling swap:
a = 20, b = 10
Char values after calling swap:
c = V, d = I
</pre>
<h2>Generic Delegates</h2>
<p>You can define a generic delegate with type parameters. For example:</p>
<pre class="prettyprint">
delegate T NumberChanger&lt;T&gt;(T n);
</pre>
<p>The following example shows use of this delegate:</p>
<pre class="prettyprint">
using System;
using System.Collections.Generic;

delegate T NumberChanger&lt;T&gt;(T n);
namespace GenericDelegateAppl
{
    class TestDelegate
    {
        static int num = 10;
        public static int AddNum(int p)
        {
            num += p;
            return num;
        }

        public static int MultNum(int q)
        {
            num *= q;
            return num;
        }
        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            //create delegate instances
            NumberChanger&lt;int&gt; nc1 = new NumberChanger&lt;int&gt;(AddNum);
            NumberChanger&lt;int&gt; nc2 = new NumberChanger&lt;int&gt;(MultNum);
            //calling the methods using the delegate objects
            nc1(25);
            Console.WriteLine("Value of Num: {0}", getNum());
            nc2(5);
            Console.WriteLine("Value of Num: {0}", getNum());
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Value of Num: 35
Value of Num: 175
</pre>
<h1>C# - Anonymous Methods</h1>
<p><b>Anonymous methods</b> provide a technique to pass a code block as a delegate parameter. Anonymous methods are basically methods without a name, just the body. </p>
<p>You need not specify the return type in an anonymous method; it is inferred from the return statement inside the method body. </p>
<h2>Syntax for Writing an Anonymous Method</h2>
<p>Anonymous methods are declared with the creation of the delegate instance, with a <b>delegate</b> keyword. For example,</p>
<pre class="prettyprint">
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
    Console.WriteLine("Anonymous Method: {0}", x);
};

</pre>
<p>The code block <i>Console.WriteLine("Anonymous Method: {0}", x);</i> is the body of the anonymous method. </p>
<p>The delegate could be called both with anonymous methods as well as named methods in the same way, i.e., by passing the method parameters to the delegate object. </p>
<p>For example,</p>
<pre class="prettyprint">
nc(10);
</pre>
<h2>Example:</h2>
<p>The following example demonstrates the concept:</p>
<pre class="prettyprint">
using System;

delegate void NumberChanger(int n);
namespace DelegateAppl
{
    class TestDelegate
    {
        static int num = 10;
        public static void AddNum(int p)
        {
            num += p;
            Console.WriteLine("Named Method: {0}", num);
        }

        public static void MultNum(int q)
        {
            num *= q;
            Console.WriteLine("Named Method: {0}", num);
        }
        public static int getNum()
        {
            return num;
        }

        static void Main(string[] args)
        {
            //create delegate instances using anonymous method
            NumberChanger nc = delegate(int x)
            {
               Console.WriteLine("Anonymous Method: {0}", x);
            };
            
            //calling the delegate using the anonymous method 
            nc(10);

            //instantiating the delegate using the named methods 
            nc =  new NumberChanger(AddNum);
            
            //calling the delegate using the named methods 
            nc(5);

            //instantiating the delegate using another named methods 
            nc =  new NumberChanger(MultNum);
            
            //calling the delegate using the named methods 
            nc(2);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code is compiled and executed, it produces following result:</p>
<pre class="result">
Anonymous Method: 10
Named Method: 15
Named Method: 30
</pre>
<h1>C# - Unsafe Codes</h1>
<p>C# allows using pointer variables in a function of code block when it is marked by the <b>unsafe</b> modifier. The <b>unsafe code</b> or the unmanaged code is a code block that uses a <b>pointer</b> variable.</p>
<h2>Pointer Variables</h2>
<p>A <b>pointer</b> is a variable whose value is the address of another variable i.e., the direct address of the memory location. Like any variable or constant, you must declare a pointer before you can use it to store any variable address.</p>
<p>The general form of a pointer variable declaration is:</p>
<pre class="prettyprint">
type *var-name;
</pre>
<p>Following are valid pointer declarations:</p>
<pre class="prettyprint">
int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */
</pre>
<p>The following example illustrates use of pointers in C#, using the unsafe modifier:</p>
<pre class="prettyprint">
using System;
namespace UnsafeCodeApplication
{
    class Program
    {
        static unsafe void Main(string[] args)
        {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} ",  var);
            Console.WriteLine("Address is: {0}",  (int)p);
            Console.ReadKey();
        }
    }
}
</pre>
<p>When the above code wass compiled and executed, it produced following result:</p>
<pre class="result">
Data is: 20
Address is: 99215364
</pre>
<p>Instead of declaring an entire method as unsafe, you can also declare a part of the code as unsafe. The example in the following section shows this.</p>
<h2>Retrieving the Data Value Using a Pointer</h2>
<p>You can retrieve the data stored at the located referenced by the pointer variable, using the <b>ToString()</b> method. Following example demonstrates this:</p>
<pre class="prettyprint">
using System;
namespace UnsafeCodeApplication
{
   class Program
   {
      public static void Main()
      {
         unsafe
         {
            int var = 20;
            int* p = &var;
            Console.WriteLine("Data is: {0} " , var);
            Console.WriteLine("Data is: {0} " , p->ToString());
            Console.WriteLine("Address is: {0} " , (int)p);
         }
         Console.ReadKey();
      }
   }
}
</pre>
<p>When the above code was compiled and executed, it produced following result:</p>
<pre class="result">
Data is: 20
Data is: 20
Address is: 77128984
</pre>
<h2>Compiling Unsafe Code</h2>
<p>For compiling unsafe code, you have to specify the <b>/unsafe</b> command line switch with command line compiler. </p>
<p>For example, to compile a program named prog1.cs containing unsafe code, from command line, give the command:</p>
<pre class="prettyprint">
csc /unsafe prog1.cs
</pre>
<p>If you are using Visual Studio IDE then you need to enable use of unsafe code in the project properties.</p>
<p>To do this:</p>
<ul class="list">
<li><p>Open <b>project properties</b> by double clicking the properties node in the Solution Explorer.</p></li>
<li><p>Click on the <b>Build</b> tab. </p></li>
<li><p>Select the option "<b>Allow unsafe code</b>".</p></li>
</ul>
<hr />
<div class="pre-btn">
<a href="csharp_multithreading.html">Previous Page</a>
</div>
<div class="print-btn">
<a href="../cgi-bin/printpage.html" target="_blank">Print Version</a>
</div>
<div class="pdf-btn">
<a href="pdf/csharp_quick_guide.html" alt="C# Quick Guide" target="_blank">PDF Version</a>
</div>
<div class="nxt-btn">
<a href="csharp_useful_resources.html">Next Page</a>
</div>
<div class="clearer"></div>
<hr />
</div>
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 336;
google_ad_height = 280;
google_ad_format = "336x280_as";
google_ad_type = "text";
google_ad_channel ="9030538898";
google_color_border="ffffff";
google_color_link="900b09";
google_color_url="000000";
google_color_text="000000";
//--></script>
<script type="text/javascript" src="../../pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div>
</div><!-- middlecol -->
<div id="rightcol">
<!-- AddThis Button BEGIN -->
<div class="addthis">
<div class="addthis_toolbox addthis_default_style">
<a class="addthis_button_facebook"></a>
<a class="addthis_button_twitter"></a>
<script type="text/javascript">
<!--
 document.write('<a class="addthis_button_google_plusone" g:plusone:count="false"></a>');
//-->
</script>
<a class="addthis_button_linkedin"></a>
<a class="addthis_button_email"></a>
<a class="addthis_button_compact"></a>
</div>
<script type="text/javascript" src="../../s7.addthis.com/js/250/addthis_widget.js#pubid=ra-4f661ec623a400f0"></script>
</div>
<!-- AddThis Button END -->
<div class="localad">
<a rel="nofollow" href="http://www.modernindianbabynames.com/" target="_blank" title="Modern Baby Names">Modern Baby Names</a>
</div>
<div class="localad">
<a rel="nofollow" href="http://www.photofuntoos.com/" target="_blank" title="Online Photo Editing">Online Photo Editing</a>
</div>
<div class="rightgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
</div><!-- rightcol -->
<div style="clear:both;"></div>
</div><!-- wrapper -->
<div id="footer">
<div class="wrapper">
<div id="bottommenu">
<a href="../asp.net/index.html" target="_top">ASP.NET </a> |
<a href="../jquery/index.html" target="_top">jQuery </a> |
<a href="../ajax/index.html" target="_top">AJAX </a> |
<a href="../ant/index.html" target="_top">ANT</a> |
<a href="../jsp/index.html" target="_top">JSP </a> |
<a href="../servlets/index.html" target="_top">Servlets </a> |
<a href="../log4j/index.html" target="_top">log4j </a> |
<a href="../ibatis/index.html" target="_top">iBATIS </a> |
<a href="../hibernate/index.html" target="_top">Hibernate </a> |
<a href="../jdbc/index.html" target="_top">JDBC </a> |
<a href="../struts_2/index.html" target="_top">Struts </a> |
<a href="../html5/index.html" target="_top">HTML5 </a> |
<a href="../sql/index.html" target="_top">SQL </a> |
<a href="../mysql/index.html" target="_top">MySQL </a> |
<a href="../cplusplus/index.html" target="_top">C++ </a> |
<a href="../unix/index.html" target="_top">UNIX </a>
</div>
<div id="copyright">
<p>Copyright &copy; 2013 by tutorialspoint. All Rights Reserved.</p>
</div>
</div>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/csharp/csharp_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2010], Mon, 15 Apr 2013 05:01:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
</html>
